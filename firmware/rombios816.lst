ca65 V2.18 - Ubuntu 2.19-1
Main file   : rombios816.asm
Current file: rombios816.asm

000000r 1               .P816
000000r 1               ;__ROMBIOS816_______________________________________________________________________________________
000000r 1               ;
000000r 1               ;	ROM BIOS FOR THE RBC 65c816 SBC - NATIVE MODE
000000r 1               ;
000000r 1               ;	WRITTEN BY: DAN WERNER -- 10/7/2017
000000r 1               ;   Modified 8/10/2024 for WE816-MARK2
000000r 1               ;
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; DATA CONSTANTS
000000r 1               ;__________________________________________________________________________________________________
000000r 1               
000000r 1                       .SEGMENT "ROM"
000000r 1               
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ; $8000-$8007 UART 16C550
000000r 1               ;__________________________________________________________________________________________________
000000r 1               UART0           = $FE00         ;   DATA IN/OUT
000000r 1               UART1           = $FE01         ;   CHECK RX
000000r 1               UART2           = $FE02         ;   INTERRUPTS
000000r 1               UART3           = $FE03         ;   LINE CONTROL
000000r 1               UART4           = $FE04         ;   MODEM CONTROL
000000r 1               UART5           = $FE05         ;   LINE STATUS
000000r 1               UART6           = $FE06         ;   MODEM STATUS
000000r 1               
000000r 1               RTC             = $FE08         ;   RTC REG.
000000r 1               
000000r 1               via1regb        = $FE10         ; Register
000000r 1               via1rega        = $FE11         ; Register
000000r 1               via1ddrb        = $FE12         ; Register
000000r 1               via1ddra        = $FE13         ; Register
000000r 1               via1t1cl        = $FE14         ; Register
000000r 1               via1t1ch        = $FE15         ; Register
000000r 1               via1t1ll        = $FE16         ; Register
000000r 1               via1t1lh        = $FE17         ; Register
000000r 1               via1t2cl        = $FE18         ; Register
000000r 1               via1t2ch        = $FE19         ; Register
000000r 1               via1sr          = $FE1A         ; Register
000000r 1               via1acr         = $FE1B         ; Register
000000r 1               via1pcr         = $FE1C         ; Register
000000r 1               via1ifr         = $FE1D         ; Register
000000r 1               via1ier         = $FE1E         ; Register
000000r 1               via1ora         = $FE1F         ; Register
000000r 1               
000000r 1               
000000r 1               
000000r 1               via2regb        = $FE20         ; Register
000000r 1               via2rega        = $FE21         ; Register
000000r 1               via2ddrb        = $FE22         ; Register
000000r 1               via2ddra        = $FE23         ; Register
000000r 1               via2t1cl        = $FE24         ; Register
000000r 1               via2t1ch        = $FE25         ; Register
000000r 1               via2t1ll        = $FE26         ; Register
000000r 1               via2t1lh        = $FE27         ; Register
000000r 1               via2t2cl        = $FE28         ; Register
000000r 1               via2t2ch        = $FE29         ; Register
000000r 1               via2sr          = $FE2A         ; Register
000000r 1               via2acr         = $FE2B         ; Register
000000r 1               via2pcr         = $FE2C         ; Register
000000r 1               via2ifr         = $FE2D         ; Register
000000r 1               via2ier         = $FE2E         ; Register
000000r 1               via2ora         = $FE2F         ; Register
000000r 1               
000000r 1               
000000r 1               STACK           = $BFFF         ;   POINTER TO TOP OF STACK
000000r 1               
000000r 1               ;
000000r 1               KEYBUFF         = $0200         ; 256 BYTE KEYBOARD BUFFER
000000r 1               ; NATIVE VECTORS
000000r 1               ICOPVECTOR      = $0300         ;COP handler indirect vector...
000000r 1               IBRKVECTOR      = $0302         ;BRK handler indirect vector...
000000r 1               IABTVECTOR      = $0304         ;ABT handler indirect vector...
000000r 1               INMIVECTOR      = $0306         ;NMI handler indirect vector...
000000r 1               IIRQVECTOR      = $0308         ;IRQ handler indirect vector...
000000r 1               ; 6502 Emulation Vectors
000000r 1               IECOPVECTOR     = $030A         ;ECOP handler indirect vector...
000000r 1               IEABTVECTOR     = $030C         ;EABT handler indirect vector...
000000r 1               IENMIVECTOR     = $030E         ;ENMI handler indirect vector...
000000r 1               IEINTVECTOR     = $0310         ;EINT handler indirect vector...
000000r 1               
000000r 1               ;;; These are as yet unused
000000r 1               ;------------------------------------------------------------------------------
000000r 1               IECDCF          = $0312         ; Serial output: deferred char flag
000000r 1               IECDC           = $0313         ; Serial deferred character
000000r 1               IECBCI          = $0314         ; Serial bit count/EOI flag
000000r 1               IECBTC          = $0315         ; Countdown, bit count
000000r 1               IECCYC          = $0316         ; Cycle count
000000r 1               IECSTW          = $0317         ; Status word
000000r 1               IECFNLN         = $0318         ; File Name Length
000000r 1               IECSECAD        = $0319         ; IEC Secondary Address
000000r 1               IECBUFFL        = $031A         ; low byte IEC buffer Pointer
000000r 1               IECBUFFH        = $031B         ; High byte IEC buffer Pointer
000000r 1               IECDEVN         = $031C         ; IEC Device Number
000000r 1               IECSTRTL        = $031D         ; low byte IEC Start Address Pointer
000000r 1               IECSTRTH        = $031E         ; High byte IEC Start Address Pointer
000000r 1               IECMSGM         = $031F         ; message mode flag,
000000r 1               ; $C0 = both control and kernal messages,
000000r 1               ; $80 = control messages only,
000000r 1               ; $40 = kernal messages only,
000000r 1               ; $00 = neither control or kernal messages
000000r 1               IECFNPL         = $0320         ; File Name Pointer Low,
000000r 1               IECFNPH         = $0321         ; File Name Pointer High,
000000r 1               LOADBUFL        = $0322         ; low byte IEC buffer Pointer
000000r 1               LOADBUFH        = $0323         ; High byte IEC buffer Pointer
000000r 1               LOADBANK        = $0324         ; BANK buffer Pointer
000000r 1               IECOPENF        = $0325         ; OPEN FILE COUNT
000000r 1               IECLFN          = $0326         ; IEC LOGICAL FILE NUMBER
000000r 1               IECIDN          = $0327         ; input device number
000000r 1               IECODN          = $0328         ; output device number
000000r 1               ;------------------------------------------------------------------------------
000000r 1               
000000r 1               ; VIDEO/KEYBOARD PARAMETER AREA
000000r 1               
000000r 1               CSRX            = $0330         ; CURRENT X POSITION
000000r 1               CSRY            = $0331         ; CURRENT Y POSITION
000000r 1               LEDS            = $0332
000000r 1               KeyLock         = $0333
000000r 1               ScannedKey      = $0334
000000r 1               ScrollCount     = $0335         ;
000000r 1               TEMP            = $0336         ; TEMP AREA
000000r 1               
000000r 1               ConsoleDevice   = $0341         ; Current Console Device
000000r 1                                               ; $00 Serial, $01 On-Board 9918/KB
000000r 1               CSRCHAR         = $0342         ; Character under the Cursor
000000r 1               VIDEOWIDTH      = $0343         ; SCREEN WIDTH -- 32 or 40 (80 in the future)
000000r 1               DEFAULT_COLOR   = $0344         ; DEFAULT COLOR FOR PRINTING
000000r 1               
000000r 1               ; Tables
000000r 1               PTRLFT          = $03B0         ; .. to $03B9 logical file table
000000r 1               PTRDNT          = $03BA         ; .. to $03C3 device number table
000000r 1               PTRSAT          = $03C4         ; .. to $03CD secondary address table
000000r 1               LINEFLGS        = $03D0         ; 24 BYTES OF LINE POINTERS (3D0 - 3E9 , one extra for scrolling)
000000r 1               
000000r 1               
000000r 1               TRUE            = 1
000000r 1               FALSE           = 0
000000r 1               
000000r 1               KBD_DELAY       = 64            ; keyboard delay in MS.   Set higher if keys bounce, set lower if keyboard feels slow
000000r 1               
000000r 1                       .INCLUDE "macros.asm"
000000r 2               ;___________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	USEFUL 65186 MACROS
000000r 2               ;__________________________________________________________________________________________________
000000r 2               
000000r 2               .macro       STORECONTEXT             ; Store Complete Context at the beginning of a Sub
000000r 2                       PHX
000000r 2                       phy
000000r 2                       pha
000000r 2                       php
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       RESTORECONTEXT                 ; Restore Complete Context at the end of a Sub
000000r 2                       plp
000000r 2                       pla
000000r 2                       ply
000000r 2                       plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       INDEX16                         ; Set 16bit Index Registers
000000r 2               		REP #$10 		; 16 bit Index registers
000000r 2               		.I16
000000r 2               .endmacro
000000r 2               .macro       INDEX8                          ; Set 8bit Index Registers
000000r 2               		SEP #$10 		; 8 bit Index registers
000000r 2               		.I8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATOR16                  ; Set 16bit Index Registers
000000r 2               		REP #$20 		; 16 bit Index registers
000000r 2               		.A16
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATOR8                   ; Set 8bit Index Registers
000000r 2               		SEP #$20 		; 8 bit Index registers
000000r 2               		.A8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATORINDEX16             ; Set 16bit Index Registers
000000r 2               		REP #$30 		; 16 bit Index registers
000000r 2               		.A16
000000r 2                               .I16
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATORINDEX8              ; Set 8bit Index Registers
000000r 2               		SEP #$30 		; 8 bit Index registers
000000r 2               		.A8
000000r 2                               .I8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       LBEQ PARM1
000000r 2                    bne *+5
000000r 2                    jmp PARM1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       LBNE PARM1
000000r 2                    beq *+5
000000r 2                    jmp PARM1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       LBCC PARM1
000000r 2                    bcc *+4
000000r 2                    bra *+5
000000r 2                    jmp PARM1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       LBCS PARM1
000000r 2                    bcs *+4
000000r 2                    bra *+5
000000r 2                    jmp PARM1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       SETBANK PARM1
000000r 2                   PHX
000000r 2               	LDX #PARM1
000000r 2               	PHX
000000r 2               	PLB
000000r 2                   PLX
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               ; CHOOSE ONE CONSOLE IO DEVICE
000000r 1               
000000r 1                       .ORG    $C000
00C000  1               
00C000  1               ;__COLD_START___________________________________________________
00C000  1               ;
00C000  1               ; PERFORM SYSTEM COLD INIT
00C000  1               ;
00C000  1               ;_______________________________________________________________
00C000  1               COLD_START:
00C000  1  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
00C001  1               
00C001  1  18                   CLC                     ;
00C002  1  FB                   XCE                     ; SET NATIVE MODE
00C003  1  C2 30                ACCUMULATORINDEX16
00C005  1  A9 FF BF             LDA     #STACK          ; get the stack address
00C008  1  1B                   TCS                     ; and set the stack to it
00C009  1               
00C009  1  A9 FB D1             LDA     #INTRETURN      ;
00C00C  1  8D 00 03             STA     ICOPVECTOR
00C00F  1  8D 02 03             STA     IBRKVECTOR
00C012  1  8D 04 03             STA     IABTVECTOR
00C015  1  8D 06 03             STA     INMIVECTOR
00C018  1  8D 08 03             STA     IIRQVECTOR
00C01B  1  8D 0A 03             STA     IECOPVECTOR
00C01E  1  8D 0C 03             STA     IEABTVECTOR
00C021  1  8D 0E 03             STA     IENMIVECTOR
00C024  1  8D 10 03             STA     IEINTVECTOR
00C027  1               
00C027  1  E2 30                ACCUMULATORINDEX8
00C029  1  20 FD D1             JSR     CONSOLE_INIT    ; Init UART
00C02C  1               ;       JSR     INITIEC        ; Init IEC port
00C02C  1               ;       JSR     BATEST         ; Perform Basic Assurance Test
00C02C  1               
00C02C  1               ;       JML     $FF1000         ; START BASIC
00C02C  1  4C 4E C0             JMP     mon
00C02F  1               
00C02F  1               
00C02F  1               RCOPVECTOR:
00C02F  1  6C 00 03             JMP     (ICOPVECTOR)
00C032  1               RBRKVECTOR:
00C032  1  6C 02 03             JMP     (IBRKVECTOR)
00C035  1               RABTVECTOR:
00C035  1  6C 04 03             JMP     (IABTVECTOR)
00C038  1               RNMIVECTOR:
00C038  1  6C 06 03             JMP     (INMIVECTOR)
00C03B  1               RIRQVECTOR:
00C03B  1  6C 08 03             JMP     (IIRQVECTOR)
00C03E  1               RECOPVECTOR:
00C03E  1  6C 0A 03             JMP     (IECOPVECTOR)
00C041  1               REABTVECTOR:
00C041  1  6C 0C 03             JMP     (IEABTVECTOR)
00C044  1               RENMIVECTOR:
00C044  1  6C 0E 03             JMP     (IENMIVECTOR)
00C047  1               REINTVECTOR:
00C047  1  6C 10 03             JMP     (IEINTVECTOR)
00C04A  1               
00C04A  1                       .INCLUDE "supermon816.asm"
00C04A  2               ;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*      SUPERMON 816 MACHINE LANGUAGE MONITOR FOR THE W65C816S MICROPROCESSOR      *
00C04A  2               ;* ------------------------------------------------------------------------------- *
00C04A  2               ;*      Copyright Â©1991-2014 by BCS Technology Limited.  All rights reserved.      *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* Permission is hereby granted to use, copy, modify and distribute this software, *
00C04A  2               ;* provided this copyright notice remains in the source code and  proper  attribu- *
00C04A  2               ;* tion is given.  Redistribution, regardless of form, must be at no charge to the *
00C04A  2               ;* end  user.  This code or any part thereof, including any derivation, MAY NOT be *
00C04A  2               ;* incorporated into any package intended for sale,  unless written permission has *
00C04A  2               ;* been given by the copyright holder.                                             *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* THERE IS NO WARRANTY OF ANY KIND WITH THIS SOFTWARE.  The user assumes all risk *
00C04A  2               ;* in connection with the incorporation of this software into any system.          *
00C04A  2               ;* ------------------------------------------------------------------------------- *
00C04A  2               ;* Supermon 816 is a salute to Jim Butterfield, who passed away on June 29, 2007.  *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* Jim, who was the unofficial  spokesman for  Commodore  International during the *
00C04A  2               ;* heyday of the company's 8 bit supremacy, scratch-developed the Supermon machine *
00C04A  2               ;* language monitor for the PET & CBM computers.   When the best-selling Commodore *
00C04A  2               ;* 64 was introduced, Jim adapted his software to the new machine & gave the adap- *
00C04A  2               ;* tation the name Supermon 64.   Commodore  subsequently  integrated a customized *
00C04A  2               ;* version of Supermon 64 into the C-128 to act as the resident M/L monitor.       *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* Although Supermon 816 is not an adaptation of Supermon 64,  it was  decided  to *
00C04A  2               ;* keep the Supermon name alive, since Supermon 816's general operation & user in- *
00C04A  2               ;* terface is similar to that of Supermon 64.   Supermon 816 is 100 percent native *
00C04A  2               ;* mode 65C816 code & was developed from a blank canvas.                           *
00C04A  2               ;* ------------------------------------------------------------------------------- *
00C04A  2               ;* Supermon 816 is a full featured monitor and supports the following operations:  *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     A - Assemble code                                                           *
00C04A  2               ;*     C - Compare memory regions                                                  *
00C04A  2               ;*     D - Disassemble code                                                        *
00C04A  2               ;*     F - Fill memory region (cannot span banks)                                  *
00C04A  2               ;*     G - Execute code (stops at BRK)                                             *
00C04A  2               ;*     H - Search (hunt) memory region                                             *
00C04A  2               ;*     J - Execute code as a subroutine (stops at BRK or RTS)                      *
00C04A  2               ;*     M - Dump & display memory range                                             *
00C04A  2               ;*     R - Dump & display 65C816 registers                                         *
00C04A  2               ;*     T - Copy (transfer) memory region                                           *
00C04A  2               ;*     X - Exit Supermon 816 & return to operating environment                     *
00C04A  2               ;*     > - Modify up to 32 bytes of memory                                         *
00C04A  2               ;*     ; - Modify 65C816 registers                                                 *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* Supermon 816 accepts binary (%), octal (%), decimal (+) and hexadecimal ($) as  *
00C04A  2               ;* input for numeric parameters.  Additionally, the H and > operations accept an   *
00C04A  2               ;* ASCII string in place of numeric values by preceding the string with ', e.g.:   *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     h 042000 042FFF 'BCS Technology Limited                                     *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* If no radix symbol is entered hex is assumed.                                   *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* Numeric conversion is also available.  For example, typing:                     *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     +1234567 <CR>                                                               *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* will display:                                                                   *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*         $12D687                                                                 *
00C04A  2               ;*         +1234567                                                                *
00C04A  2               ;*         %04553207                                                               *
00C04A  2               ;*         %100101101011010000111                                                  *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* In the above example, <CR> means the console keyboard's return or enter key.    *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* All numeric values are internally processed as 32 bit unsigned integers.  Addr- *
00C04A  2               ;* esses may be entered as 8, 16 or 24 bit values.  During instruction assembly,   *
00C04A  2               ;* immediate mode operands may be forced to 16 bits by preceding the operand with  *
00C04A  2               ;* an exclamation point if the instruction can accept a 16 bit operand, e.g.:      *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     a 1f2000 lda !#4                                                            *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* The above will assemble as:                                                     *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     A 1F2000  A9 04 00     LDA #$0004                                           *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* Entering:                                                                       *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     a 1f2000 ldx !#+157                                                         *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* will assemble as:                                                               *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     A 1F2000  A2 9D 00     LDX #$009D                                           *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* Absent the ! in the operand field, the above would have been assembled as:      *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     A 1F2000  A2 9D        LDX #$9D                                             *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* If an immediate mode operand is greater than $FF assembly of a 16 bit operand   *
00C04A  2               ;* is implied.                                                                     *
00C04A  2               ;* ------------------------------------------------------------------------------- *
00C04A  2               ;* A Note on the PEA & PEI Instructions                                            *
00C04A  2               ;* ------------------------------------                                            *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* The Eyes and Lichty programming manual uses the following syntax for the PEA    *
00C04A  2               ;* and PEI instructions:                                                           *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     PEA <operand>                                                               *
00C04A  2               ;*     PEI (<operand>)                                                             *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* The WDC data sheet that was published at the time of the 65C816's release in    *
00C04A  2               ;* 1984 does not indicate a recommended or preferred syntax for any of the above   *
00C04A  2               ;* instructions.  PEA pushes its operand to the stack and hence operates like any  *
00C04A  2               ;* other immediate mode instruction, in that the operand is the data (however, PEA *
00C04A  2               ;* doesn't affect the status register).  Similarly, PEI pushes the 16 bit value    *
00C04A  2               ;* stored at <operand> and <operand>+1, and hence operates like any other direct   *
00C04A  2               ;* (zero) page instruction, again without affecting the status register.           *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* BCS Technology Limited is of the opinion that the developer of the ORCA/M as-   *
00C04A  2               ;* sembler, which is the assembler referred to in the Eyes and Lichty manual, mis- *
00C04A  2               ;* understood how PEA and PEI behave during runtime, and hence chose an incorrect  *
00C04A  2               ;* syntax for these two instructions.  This error was subsequently carried forward *
00C04A  2               ;* by Eyes and Lichty.                                                             *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* Supermon 816's assembler uses the following syntax for PEA and PEI:             *
00C04A  2               ;*                                                                                 *
00C04A  2               ;*     PEA #<operand>                                                              *
00C04A  2               ;*     PEI <operand>                                                               *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* The operand for PEA is treated as a 16 bit value, even if entered as an 8 bit   *
00C04A  2               ;* value.  The operand for PEI must be 8 bits.                                     *
00C04A  2               ;*                                                                                 *
00C04A  2               ;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
00C04A  2               ;
00C04A  2               ;	* * * * * * * * * * * *
00C04A  2               ;	* VERSION INFORMATION *
00C04A  2               ;	* * * * * * * * * * * *
00C04A  2               ;
00C04A  2                       .MACRO  SOFTVERS        ;software version - change with each revision...
00C04A  2                       .BYTE   "1"             ;major
00C04A  2                       .BYTE   "."
00C04A  2                       .BYTE   "0"             ;minor
00C04A  2                       .BYTE   "."
00C04A  2                       .BYTE   "2"             ;revision
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2               ;REVISION TABLE
00C04A  2               ;
00C04A  2               ;Ver  Rev Date    Description
00C04A  2               ;-------------------------------------------------------------------------------
00C04A  2               ;1.0  2013/11/01  A) Original derived from the POC V1.1 single-board computer
00C04A  2               ;                    firmware.
00C04A  2               ;     2013/11/04  A) Fixed a problem where the B-accumulator wasn't always being
00C04A  2               ;                    be copied to shadow storage after return from execution of
00C04A  2               ;                    a J command.
00C04A  2               ;     2017/10/07  A) Converted to use WDC's 65816 assembler (D.WERNER)
00C04A  2               ;		  B) Adapt for the RBC 65c816 SBC
00C04A  2               ;		  C) Disable X command
00C04A  2               ;-------------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	        COMMENT ABBREVIATIONS
00C04A  2               ;	----------------------------------------------------
00C04A  2               ;	  BCD   binary-coded decimal
00C04A  2               ;	   DP   direct page or page zero
00C04A  2               ;	  EOF   end-of-field
00C04A  2               ;	  EOI   end-of-input
00C04A  2               ;	  LSB   least significant byte/bit
00C04A  2               ;	  LSD   least significant digit
00C04A  2               ;	  LSN   least significant nybble
00C04A  2               ;	  LSW   least significant word
00C04A  2               ;	  MPU   microprocessor
00C04A  2               ;	  MSB   most significant byte/bit
00C04A  2               ;	  MSD   most significant digit
00C04A  2               ;	  MSN   most significant nybble
00C04A  2               ;	  MSW   most-significant word
00C04A  2               ;	  RAM   random access memory
00C04A  2               ;	   WS   whitespace, i.e., blanks & horizontal tabs
00C04A  2               ;	----------------------------------------------------
00C04A  2               ;	A word is defined as 16 bits.
00C04A  2               ;
00C04A  2               ;	   MPU REGISTER SYMBOLS
00C04A  2               ;	--------------------------
00C04A  2               ;	   .A   accumulator LSB
00C04A  2               ;	   .B   accumulator MSB
00C04A  2               ;	   .C   16 bit accumulator
00C04A  2               ;	   .X   X-index
00C04A  2               ;	   .Y   Y-index
00C04A  2               ;	   DB   data bank
00C04A  2               ;	   DP   direct page
00C04A  2               ;	   PB   program bank
00C04A  2               ;	   PC   program counter
00C04A  2               ;	   SP   stack pointer
00C04A  2               ;	   SR   MPU status
00C04A  2               ;	----------------------------
00C04A  2               ;
00C04A  2               ;	  MPU STATUS REGISTER SYMBOLS
00C04A  2               ;	-------------------------------
00C04A  2               ;	    C   carry
00C04A  2               ;	    D   decimal mode
00C04A  2               ;	    I   maskable interrupts
00C04A  2               ;	    m   accumulator/memory size
00C04A  2               ;	    N   result negative
00C04A  2               ;	    V   sign overflow
00C04A  2               ;	    x   index registers size
00C04A  2               ;	    Z   result zero
00C04A  2               ;	-------------------------------
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;SYSTEM INTERFACE DEFINITIONS
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------
00C04A  2               ;	This section defines the interface between Supermon 816 & the host
00C04A  2               ;	system.   Change these definitions to suit your system, but do not
00C04A  2               ;	change any label names.  All definitions must have valid values in
00C04A  2               ;	order to assemble Supermon 816.
00C04A  2               ;	------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;	--------------------------------------------------------
00C04A  2               ;.org  $008000              ;assembly address...
00C04A  2               ;
00C04A  2               ;	Set _ORIGIN_ to Supermon 816's desired assembly address.
00C04A  2               ;	--------------------------------------------------------
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;vecexit  = $002000              ;exit to environment address...
00C04A  2               ;
00C04A  2               ;	Set VECEXIT to where Supermon 816 should go when it exits.  Supermon 816
00C04A  2               ;	will do a JML (long jump) to this address, which means VECEXIT must be a
00C04A  2               ;	24 bit address.
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;getcha                  ;get keystroke from console...
00C04A  2               ;
00C04A  2               ;	GETCHA refers to an operating system API call that returns a keystroke
00C04A  2               ;	in the 8 bit accumulator.  Supermon 816  assumes that GETCHA is a non-
00C04A  2               ;	blocking subroutine & returns with carry clear to indicate that a key-
00C04A  2               ;	stroke is in .A, or with carry set to indicate that no keystroke was
00C04A  2               ;	available.  GETCHA will be called with a JSR instruction.
00C04A  2               ;
00C04A  2               ;	Supermon 816 expects .X & .Y to be preserved upon return from GETCHA.
00C04A  2               ;	You may have to modify Supermon 816 at all calls to GETCHA if your "get
00C04A  2               ;	keystroke" routine works differently than described.
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               getcha          = $FF74
00C04A  2               ;------------------------------------------------------------------------
00C04A  2               ;putcha   print character on console...
00C04A  2               ;
00C04A  2               ;	PUTCHA refers to an operating system API call that prints a character to
00C04A  2               ;	the console screen.  The character to be printed will be in .A, which
00C04A  2               ;	will be set to 8-bit width.  Supermon 816 assumes that PUTCHA will block
00C04A  2               ;	until the character can be processed.  PUTCHA will be called with a JSR
00C04A  2               ;	instructions.
00C04A  2               ;
00C04A  2               ;	Supermon 816 expects .X & .Y to be preserved upon return from PUTCHA.
00C04A  2               ;	You may have to modify Supermon 816 at all calls to PUTCHA if your "put
00C04A  2               ;	character" routine works differently than described.
00C04A  2               ;
00C04A  2               putcha          = $FF71
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               vecbrki         = IBRKVECTOR         ;BRK handler indirect vector...
00C04A  2               ;
00C04A  2               ;	Supermon 816 will modify this vector so that execution of a BRK instruc-
00C04A  2               ;	tion is intercepted & the registers  are  captured.   Your BRK front end
00C04A  2               ;	should jump through this vector after pushing the registers as follows:
00C04A  2               ;
00C04A  2               ;	         phb                   ;save DB
00C04A  2               ;	         phd                   ;save DP
00C04A  2               ;	         rep #%00110000        ;16 bit registers
00C04A  2               ;	         pha
00C04A  2               ;	         phx
00C04A  2               ;	         phy
00C04A  2               ;	         jmp (vecbrki)         ;indirect vector
00C04A  2               ;
00C04A  2               ;	When a G or J command is issued, the above sequence will be reversed be-
00C04A  2               ;	fore a jump is made to the code to be executed.  Upon exit from Supermon
00C04A  2               ;	816, the original address at VECBRKI will be restored.
00C04A  2               ;
00C04A  2               ;	If your BRK front end doesn't conform to the above you will have to mod-
00C04A  2               ;	ify Supermon 816 to accommodate the differences.  The most likely needed
00C04A  2               ;	changes will be in the order in which registers are pushed to the stack.
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               hwstack         = $7FFF         ;top of hardware stack...
00C04A  2               ;
00C04A  2               ;	Supermon 816 initializes the stack pointer to this address when the cold
00C04A  2               ;	start at MONCOLD is called to enter the monitor.  The stack pointer will
00C04A  2               ;	be undisturbed when entry into Supermon 816 is through JMONBRK (see jump
00C04A  2               ;	table definitions).
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               zeropage        = $10           ;Supermon 816's direct page...
00C04A  2               ;
00C04A  2               ;	Supermon 816 uses direct page starting at this address.  Be sure that no
00C04A  2               ;	conflict occurs with other software.
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               stopkey         = $03           ;display abort key...
00C04A  2               ;
00C04A  2               ;	Supermon 816 will poll for a "stop key" during display operations, such
00C04A  2               ;	as code disassembly & memory dumps, so as to abort further processing &
00C04A  2               ;	return to the command prompt.  STOPKEY must be defined with the ASCII
00C04A  2               ;	value that the "stop key" will emit when typed.  The polling is via a
00C04A  2               ;	call to GETCHA (described above).  The default STOPKEY definition of $03
00C04A  2               ;	is for ASCII <ETX> or [Ctrl-C].
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ibuffer         = $000200       ;input buffer &...
00C04A  2               auxbuf          = ibuffer+s_ibuf+s_byte;auxiliary buffer...
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;	Supermon 816 will use the above definitions for input buffers.  These
00C04A  2               ;	buffers may be located anywhere in RAM that is convenient.  The buffers
00C04A  2               ;	are stateless, which means that unless Supermon 816 has control of your
00C04A  2               ;	system, they may be overwritten without consequence.
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;W65C816S INSTRUCTION SYNTHESIS MACROS -- !!!!! DO NOT EDIT !!!!!
00C04A  2               ;
00C04A  2               
00C04A  2               
00C04A  2                       .MACRO  _ASM24_ _ad
00C04A  2                       .BYTE   <_ad,>_ad,_ad>>16
00C04A  2                       .ENDMACRO
00C04A  2               
00C04A  2               ;brl      .macro _ad
00C04A  2               ;_ba      =*+3
00C04A  2               ;         .BYTE $82
00C04A  2               ;         .WORD _ad-_ba
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;jml      .macro _ad
00C04A  2               ;         .BYTE $5c
00C04A  2               ;         _asm24_ _ad
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;mvn      .macro _s,_d
00C04A  2               ;         .BYTE $54,_d,_s
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;mvp      .macro _s,_d
00C04A  2               ;         .BYTE $44,_d,_s
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;pea      .macro _op
00C04A  2               ;         .BYTE $f4
00C04A  2               ;         .WORD _op
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;phb      .macro
00C04A  2               ;         .BYTE $8b
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;phk      .macro
00C04A  2               ;         .BYTE $4b
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;plb      .macro
00C04A  2               ;         .BYTE $ab
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;rep      .macro _op
00C04A  2               ;         .BYTE $c2,_op
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;sep      .macro _op
00C04A  2               ;         .BYTE $e2,_op
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;tcd      .macro
00C04A  2               ;         .BYTE $5b
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;tcs      .macro
00C04A  2               ;         .BYTE $1b
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;tdc      .macro
00C04A  2               ;         .BYTE $7b
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;tsc      .macro
00C04A  2               ;         .BYTE $3b
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;txy      .macro
00C04A  2               ;         .BYTE $9b
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;tyx      .macro
00C04A  2               ;         .BYTE $bb
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2               ;wai      .macro
00C04A  2               ;         .BYTE $cb
00C04A  2               ;        .ENDMACRO
00C04A  2               ;
00C04A  2               ;xba      .macro
00C04A  2               ;         .BYTE $eb
00C04A  2               ;         .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ADCW _OP
00C04A  2                       ADC     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ANDW _OP
00C04A  2                       AND     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  BITW _OP
00C04A  2                       BIT     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  CMPW _OP
00C04A  2                       CMP     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  CPXW        _OP
00C04A  2                       CPX     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  CPYW        _OP
00C04A  2                       CPY     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  EORW        _OP
00C04A  2                       EOR     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LDAW        _OP
00C04A  2                       LDA     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LDXW        _OP
00C04A  2                       LDX     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LDYW        _OP
00C04A  2                       LDY     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ORAW        _OP
00C04A  2                       ORA     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SBCW        _OP
00C04A  2                       SBC     #<_OP
00C04A  2                       .BYTE   >_OP
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LDALX _AD
00C04A  2                       .BYTE   $BF
00C04A  2                       _ASM24_ _AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ADCIL        _AD
00C04A  2                       .BYTE   $67,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ADCILY        _AD
00C04A  2                       .BYTE   $77,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ANDIL        _AD
00C04A  2                       .BYTE   $27,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ANDILY        _AD
00C04A  2                       .BYTE   $37,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  CMPIL        _AD
00C04A  2                       .BYTE   $C7,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  CMPILY        _AD
00C04A  2                       .BYTE   $D7,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  EORIL        _AD
00C04A  2                       .BYTE   $47,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  EORILY        _AD
00C04A  2                       .BYTE   $57,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LDAIL        _AD
00C04A  2                       .BYTE   $A7,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LDAILY        _AD
00C04A  2                       .BYTE   $B7,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ORAIL        _AD
00C04A  2                       .BYTE   $07,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ORAILY        _AD
00C04A  2                       .BYTE   $17,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SBCIL        _AD
00C04A  2                       .BYTE   $E7,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SBCILY        _AD
00C04A  2                       .BYTE   $F7,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  STAIL        _AD
00C04A  2                       .BYTE   $87,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  STAILY        _AD
00C04A  2                       .BYTE   $97,_AD
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ADCS        _OF
00C04A  2                       .BYTE   $63,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ADCSI        _OF
00C04A  2                       .BYTE   $73,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ANDS        _OF
00C04A  2                       .BYTE   $23,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ANDSI        _OF
00C04A  2                       .BYTE   $33,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  CMPS        _OF
00C04A  2                       .BYTE   $C3,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  CMPSI        _OF
00C04A  2                       .BYTE   $D3,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  EORS        _OF
00C04A  2                       .BYTE   $43,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  EORSI        _OF
00C04A  2                       .BYTE   $53,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LDAS        _OF
00C04A  2                       .BYTE   $A3,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LDASI        _OF
00C04A  2                       .BYTE   $B3,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ORAS        _OF
00C04A  2                       .BYTE   $03,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  ORASI        _OF
00C04A  2                       .BYTE   $13,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SBCS        _OF
00C04A  2                       .BYTE   $E3,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SBCSI        _OF
00C04A  2                       .BYTE   $F3,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  STAS        _OF
00C04A  2                       .BYTE   $83,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  STASI        _OF
00C04A  2                       .BYTE   $93,_OF
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SLONGA
00C04A  2                       .BYTE   $C2,$20
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LONGR
00C04A  2                       .BYTE   $C2,$30
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  LONGX
00C04A  2                       .BYTE   $C2,$10
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SHORTA
00C04A  2                       .BYTE   $E2,$20
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SHORTI
00C04A  2                       .BYTE   $E2,$10
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SHORTR
00C04A  2                       .BYTE   $E2,$30
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2                       .MACRO  SHORTX
00C04A  2                       .BYTE   $E2,$10
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;CONSOLE DISPLAY CONTROL MACROS
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;	The following macros execute terminal  control procedures  that  perform
00C04A  2               ;	such tasks as clearing the screen,  switching  between  normal & reverse
00C04A  2               ;	video, etc.  These macros are for WYSE 60 & compatible displays, such as
00C04A  2               ;	the WYSE 150, WYSE 160, WYSE 325 & WYSE GPT.   Only the functions needed
00C04A  2               ;	by Supermon 816 are included.
00C04A  2               ;
00C04A  2               ;	If your console is not WYSE 60 compatible, you will need to  edit  these
00C04A  2               ;	macros as required to control your particular console or terminal.  Note
00C04A  2               ;	that in some cases one macro may call another.  Exercise caution in your
00C04A  2               ;	edits to avoid introducing display bugs.
00C04A  2               ;
00C04A  2               ;	If your console display cannot execute one of these procedures,  such as
00C04A  2               ;	'CL' (clear to end of line), you will have to develop an alternative.
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	cursor control...
00C04A  2               ;
00C04A  2                       .MACRO  CRR             ;carriage return
00C04A  2                       .BYTE   a_cr
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2               
00C04A  2                       .MACRO  LF              ;carriage return/line feed
00C04A  2                       CRR
00C04A  2                       .BYTE   a_lf
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2               ;	miscellaneous control...
00C04A  2               ;
00C04A  2                       .MACRO  RB              ;ring "bell"
00C04A  2                       .BYTE   a_bel
00C04A  2                       .ENDMACRO
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;ASCII CONTROL DEFINITIONS (menmonic order)
00C04A  2               ;
00C04A  2               a_bel           = $07           ;<BEL> alert/ring bell
00C04A  2               a_bs            = $08           ;<BS>  backspace
00C04A  2               a_cr            = $0d           ;<CR>  carriage return
00C04A  2               a_del           = $7f           ;<DEL> delete
00C04A  2               a_esc           = $1b           ;<ESC> escape
00C04A  2               a_ht            = $09           ;<HT>  horizontal tabulation
00C04A  2               a_lf            = $0a           ;<LF>  linefeed
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	miscellaneous (description order)...
00C04A  2               ;
00C04A  2               a_blank         = ' '           ;blank (whitespace)
00C04A  2               a_asclch        = 'z'           ;end of lowercase ASCII
00C04A  2               a_lctouc        = $5f           ;LC to UC conversion mask
00C04A  2               a_asclcl        = 'a'           ;start of lowercase ASCII
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;GLOBAL ATOMIC CONSTANTS
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	data type sizes...
00C04A  2               ;
00C04A  2               s_byte          = 1             ;byte
00C04A  2               s_word          = 2             ;word (16 bits)
00C04A  2               s_xword         = 3             ;extended word (24 bits)
00C04A  2               s_dword         = 4             ;double word (32 bits)
00C04A  2               s_rampag        = $0100         ;65xx RAM page
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	data type sizes in bits...
00C04A  2               ;
00C04A  2               s_bibyte        = 8             ;byte
00C04A  2               s_bnybbl        = 4             ;nybble
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	miscellaneous...
00C04A  2               ;
00C04A  2               bitabs          = $2c           ;absolute BIT opcode
00C04A  2               bitzp           = $24           ;zero page BIT opcode
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;W65C816S NATIVE MODE STATUS REGISTER DEFINITIONS
00C04A  2               ;
00C04A  2               s_mpudbx        = s_byte        ;data bank size
00C04A  2               s_mpudpx        = s_word        ;direct page size
00C04A  2               s_mpupbx        = s_byte        ;program bank size
00C04A  2               s_mpupcx        = s_word        ;program counter size
00C04A  2               s_mpuspx        = s_word        ;stack pointer size
00C04A  2               s_mpusrx        = s_byte        ;status size
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	status register flags...
00C04A  2               ;
00C04A  2               sr_car          = %00000001     ;C
00C04A  2               sr_zer          = sr_car<<1     ;Z
00C04A  2               sr_irq          = sr_zer<<1     ;I
00C04A  2               sr_bdm          = sr_irq<<1     ;D
00C04A  2               sr_ixw          = sr_bdm<<1     ;x
00C04A  2               sr_amw          = sr_ixw<<1     ;m
00C04A  2               sr_ovl          = sr_amw<<1     ;V
00C04A  2               sr_neg          = sr_ovl<<1     ;N
00C04A  2               ;
00C04A  2               ;	NVmxDIZC
00C04A  2               ;	xxxxxxxx
00C04A  2               ;	||||||||
00C04A  2               ;	|||||||+---> 1 = carry set/generated
00C04A  2               ;	||||||+----> 1 = result = zero
00C04A  2               ;	|||||+-----> 1 = IRQs ignored
00C04A  2               ;	||||+------> 0 = binary arithmetic mode
00C04A  2               ;	||||         1 = decimal arithmetic mode
00C04A  2               ;	|||+-------> 0 = 16 bit index
00C04A  2               ;	|||          1 = 8 bit index
00C04A  2               ;	||+--------> 0 = 16 bit .A & memory
00C04A  2               ;	||           1 = 8 bit .A & memory
00C04A  2               ;	|+---------> 1 = sign overflow
00C04A  2               ;	+----------> 1 = result = negative
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;"SIZE-OF" CONSTANTS
00C04A  2               ;
00C04A  2               s_addr          = s_xword       ;24 bit address
00C04A  2               s_auxbuf        = 32            ;auxiliary buffer
00C04A  2               s_ibuf          = 69            ;input buffer
00C04A  2               s_mnemon        = 3             ;MPU ASCII mnemonic
00C04A  2               s_mnepck        = 2             ;MPU encoded mnemonic
00C04A  2               s_mvinst        = 3             ;MVN/MVP instruction
00C04A  2               s_opcode        = s_byte        ;MPU opcode
00C04A  2               s_oper          = s_xword       ;operand
00C04A  2               s_pfac          = s_dword       ;primary math accumulator
00C04A  2               s_sfac          = s_dword+s_word;secondary math accumulators
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;"NUMBER-OF" CONSTANTS
00C04A  2               ;
00C04A  2               n_dbytes        = 21            ;default disassembly bytes
00C04A  2               n_dump          = 8             ;bytes per memory dump line
00C04A  2               n_mbytes        = s_rampag-1    ;default memory dump bytes
00C04A  2               n_hccols        = 10            ;compare/hunt display columns
00C04A  2               n_opcols        = 3*s_oper      ;disassembly operand columns
00C04A  2               n_opslsr        = 4             ;LSRs to extract instruction size
00C04A  2               n_shfenc        = 5             ;shifts to encode/decode mnemonic
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;NUMERIC CONVERSION CONSTANTS
00C04A  2               ;
00C04A  2               a_hexdec        = 'A'-'9'-2     ;hex to decimal difference
00C04A  2               c_bin           = '%'           ;binary prefix
00C04A  2               c_dec           = '+'           ;decimal prefix
00C04A  2               c_hex           = '$'           ;hexadecimal prefix
00C04A  2               c_oct           = '@'           ;octal prefix
00C04A  2               k_hex           = 'f'           ;hex ASCII conversion
00C04A  2               m_bits          = s_pfac*s_bibyte;operand bit size
00C04A  2               m_cbits         = s_sfac*s_bibyte;workspace bit size
00C04A  2               bcdumask        = %00001111     ;isolate BCD units mask
00C04A  2               btoamask        = %00110000     ;binary to ASCII mask
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;ASSEMBLER/DISASSEMBLER CONSTANTS
00C04A  2               ;
00C04A  2               a_mnecvt        = '?'           ;encoded mnemonic conversion base
00C04A  2               aimmaska        = %00011111     ;.A immediate opcode test #1
00C04A  2               aimmaskb        = %00001001     ;.A immediate opcode test #2
00C04A  2               asmprfx         = 'A'           ;assemble code prefix
00C04A  2               ascprmct        = 9             ;assembler prompt "size-of"
00C04A  2               disprfx         = '.'           ;disassemble code prefix
00C04A  2               flimmask        = %11000000     ;force long immediate flag
00C04A  2               opc_cpxi        = $e0           ;CPX # opcode
00C04A  2               opc_cpyi        = $c0           ;CPY # opcode
00C04A  2               opc_ldxi        = $a2           ;LDX # opcode
00C04A  2               opc_ldyi        = $a0           ;LDY # opcode
00C04A  2               opc_mvn         = $54           ;MVN opcode
00C04A  2               opc_mvp         = $44           ;MVP opcode
00C04A  2               opc_rep         = $c2           ;REP opcode
00C04A  2               opc_sep         = $e2           ;SEP opcode
00C04A  2               pfmxmask        = sr_amw|sr_ixw ;MPU m & x flag bits mask
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	assembler prompt buffer offsets...
00C04A  2               ;
00C04A  2               apadrbkh        = s_word        ;instruction address bank MSN
00C04A  2               apadrbkl        = apadrbkh+s_byte;instruction address bank LSN
00C04A  2               apadrmbh        = apadrbkl+s_byte;instruction address MSB MSN
00C04A  2               apadrmbl        = apadrmbh+s_byte;instruction address MSB LSN
00C04A  2               apadrlbh        = apadrmbl+s_byte;instruction address LSB MSN
00C04A  2               apadrlbl        = apadrlbh+s_byte;instruction address LSB LSN
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	addressing mode preamble symbols...
00C04A  2               ;
00C04A  2               amp_flim        = '!'           ;force long immediate
00C04A  2               amp_imm         = '#'           ;immediate
00C04A  2               amp_ind         = '('           ;indirect
00C04A  2               amp_indl        = '['           ;indirect long
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	addressing mode symbolic translation indices...
00C04A  2               ;
00C04A  2               am_nam          = %0000         ;no symbol
00C04A  2               am_imm          = %0001         ;#
00C04A  2               am_adrx         = %0010         ;<addr>,X
00C04A  2               am_adry         = %0011         ;<addr>,Y
00C04A  2               am_ind          = %0100         ;(<addr>)
00C04A  2               am_indl         = %0101         ;[<dp>]
00C04A  2               am_indly        = %0110         ;[<dp>],Y
00C04A  2               am_indx         = %0111         ;(<addr>,X)
00C04A  2               am_indy         = %1000         ;(<dp>),Y
00C04A  2               am_stk          = %1001         ;<offset>,S
00C04A  2               am_stky         = %1010         ;(<offset>,S),Y
00C04A  2               am_move         = %1011         ;<sbnk>,<dbnk>
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	operand size translation indices...
00C04A  2               ;
00C04A  2               ops0            = %0000<<4      ;no operand
00C04A  2               ops1            = %0001<<4      ;8 bit operand
00C04A  2               ops2            = %0010<<4      ;16 bit operand
00C04A  2               ops3            = %0011<<4      ;24 bit operand
00C04A  2               bop1            = %0101<<4      ;8 bit relative branch
00C04A  2               bop2            = %0110<<4      ;16 bit relative branch
00C04A  2               vops            = %1001<<4      ;8 or 16 bit operand
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	operand size & addressing mode extraction masks...
00C04A  2               ;
00C04A  2               amodmask        = %00001111     ;addressing mode index
00C04A  2               opsmask         = %00110000     ;operand size
00C04A  2               vopsmask        = %11000000     ;BOPx & VOPS flag bits
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	instruction mnemonic encoding...
00C04A  2               ;
00C04A  2               mne_adc         = $2144         ;ADC
00C04A  2               mne_and         = $2bc4         ;AND
00C04A  2               mne_asl         = $6d04         ;ASL
00C04A  2               mne_bcc         = $2106         ;BCC
00C04A  2               mne_bcs         = $a106         ;BCS
00C04A  2               mne_beq         = $9186         ;BEQ
00C04A  2               mne_bit         = $aa86         ;BIT
00C04A  2               mne_bmi         = $5386         ;BMI
00C04A  2               mne_bne         = $33c6         ;BNE
00C04A  2               mne_bpl         = $6c46         ;BPL
00C04A  2               mne_bra         = $14c6         ;BRA
00C04A  2               mne_brk         = $64c6         ;BRK
00C04A  2               mne_brl         = $6cc6         ;BRL
00C04A  2               mne_bvc         = $25c6         ;BVC
00C04A  2               mne_bvs         = $a5c6         ;BVS
00C04A  2               mne_clc         = $2348         ;CLC
00C04A  2               mne_cld         = $2b48         ;CLD
00C04A  2               mne_cli         = $5348         ;CLI
00C04A  2               mne_clv         = $bb48         ;CLV
00C04A  2               mne_cmp         = $8b88         ;CMP
00C04A  2               mne_cop         = $8c08         ;COP
00C04A  2               mne_cpx         = $cc48         ;CPX
00C04A  2               mne_cpy         = $d448         ;CPY
00C04A  2               mne_dec         = $218a         ;DEC
00C04A  2               mne_dex         = $c98a         ;DEX
00C04A  2               mne_dey         = $d18a         ;DEY
00C04A  2               mne_eor         = $9c0c         ;EOR
00C04A  2               mne_inc         = $23d4         ;INC
00C04A  2               mne_inx         = $cbd4         ;INX
00C04A  2               mne_iny         = $d3d4         ;INY
00C04A  2               mne_jml         = $6b96         ;JML
00C04A  2               mne_jmp         = $8b96         ;JMP
00C04A  2               mne_jsl         = $6d16         ;JSL
00C04A  2               mne_jsr         = $9d16         ;JSR
00C04A  2               mne_lda         = $115a         ;LDA
00C04A  2               mne_ldx         = $c95a         ;LDX
00C04A  2               mne_ldy         = $d15a         ;LDY
00C04A  2               mne_lsr         = $9d1a         ;LSR
00C04A  2               mne_mvn         = $7ddc         ;MVN
00C04A  2               mne_mvp         = $8ddc         ;MVP
00C04A  2               mne_nop         = $8c1e         ;NOP
00C04A  2               mne_ora         = $14e0         ;ORA
00C04A  2               mne_pea         = $11a2         ;PEA
00C04A  2               mne_pei         = $51a2         ;PEI
00C04A  2               mne_per         = $99a2         ;PER
00C04A  2               mne_pha         = $1262         ;PHA
00C04A  2               mne_phb         = $1a62         ;PHB
00C04A  2               mne_phd         = $2a62         ;PHD
00C04A  2               mne_phk         = $6262         ;PHK
00C04A  2               mne_php         = $8a62         ;PHP
00C04A  2               mne_phx         = $ca62         ;PHX
00C04A  2               mne_phy         = $d262         ;PHY
00C04A  2               mne_pla         = $1362         ;PLA
00C04A  2               mne_plb         = $1b62         ;PLB
00C04A  2               mne_pld         = $2b62         ;PLD
00C04A  2               mne_plp         = $8b62         ;PLP
00C04A  2               mne_plx         = $cb62         ;PLX
00C04A  2               mne_ply         = $d362         ;PLY
00C04A  2               mne_rep         = $89a6         ;REP
00C04A  2               mne_rol         = $6c26         ;ROL
00C04A  2               mne_ror         = $9c26         ;ROR
00C04A  2               mne_rti         = $5566         ;RTI
00C04A  2               mne_rtl         = $6d66         ;RTL
00C04A  2               mne_rts         = $a566         ;RTS
00C04A  2               mne_sbc         = $20e8         ;SBC
00C04A  2               mne_sec         = $21a8         ;SEC
00C04A  2               mne_sed         = $29a8         ;SED
00C04A  2               mne_sei         = $51a8         ;SEI
00C04A  2               mne_sep         = $89a8         ;SEP
00C04A  2               mne_sta         = $1568         ;STA
00C04A  2               mne_stp         = $8d68         ;STP
00C04A  2               mne_stx         = $cd68         ;STX
00C04A  2               mne_sty         = $d568         ;STY
00C04A  2               mne_stz         = $dd68         ;STZ
00C04A  2               mne_tax         = $c8aa         ;TAX
00C04A  2               mne_tay         = $d0aa         ;TAY
00C04A  2               mne_tcd         = $292a         ;TCD
00C04A  2               mne_tcs         = $a12a         ;TCS
00C04A  2               mne_tdc         = $216a         ;TDC
00C04A  2               mne_trb         = $1cea         ;TRB
00C04A  2               mne_tsb         = $1d2a         ;TSB
00C04A  2               mne_tsc         = $252a         ;TSC
00C04A  2               mne_tsx         = $cd2a         ;TSX
00C04A  2               mne_txa         = $166a         ;TXA
00C04A  2               mne_txs         = $a66a         ;TXS
00C04A  2               mne_txy         = $d66a         ;TXY
00C04A  2               mne_tya         = $16aa         ;TYA
00C04A  2               mne_tyx         = $ceaa         ;TYX
00C04A  2               mne_wai         = $50b0         ;WAI
00C04A  2               mne_wdm         = $7170         ;WDM
00C04A  2               mne_xba         = $10f2         ;XBA
00C04A  2               mne_xce         = $3132         ;XCE
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	encoded instruction mnemonic indices...
00C04A  2               ;
00C04A  2               mne_adcx        = 16            ;ADC
00C04A  2               mne_andx        = 29            ;AND
00C04A  2               mne_aslx        = 44            ;ASL
00C04A  2               mne_bccx        = 15            ;BCC
00C04A  2               mne_bcsx        = 65            ;BCS
00C04A  2               mne_beqx        = 59            ;BEQ
00C04A  2               mne_bitx        = 70            ;BIT
00C04A  2               mne_bmix        = 36            ;BMI
00C04A  2               mne_bnex        = 31            ;BNE
00C04A  2               mne_bplx        = 42            ;BPL
00C04A  2               mne_brax        = 5             ;BRA
00C04A  2               mne_brkx        = 39            ;BRK
00C04A  2               mne_brlx        = 43            ;BRL
00C04A  2               mne_bvcx        = 23            ;BVC
00C04A  2               mne_bvsx        = 68            ;BVS
00C04A  2               mne_clcx        = 20            ;CLC
00C04A  2               mne_cldx        = 27            ;CLD
00C04A  2               mne_clix        = 35            ;CLI
00C04A  2               mne_clvx        = 71            ;CLV
00C04A  2               mne_cmpx        = 53            ;CMP
00C04A  2               mne_copx        = 55            ;COP
00C04A  2               mne_cpxx        = 78            ;CPX
00C04A  2               mne_cpyx        = 88            ;CPY
00C04A  2               mne_decx        = 18            ;DEC
00C04A  2               mne_dexx        = 74            ;DEX
00C04A  2               mne_deyx        = 84            ;DEY
00C04A  2               mne_eorx        = 61            ;EOR
00C04A  2               mne_incx        = 21            ;INC
00C04A  2               mne_inxx        = 77            ;INX
00C04A  2               mne_inyx        = 87            ;INY
00C04A  2               mne_jmlx        = 40            ;JML
00C04A  2               mne_jmpx        = 54            ;JMP
00C04A  2               mne_jslx        = 45            ;JSL
00C04A  2               mne_jsrx        = 63            ;JSR
00C04A  2               mne_ldax        = 1             ;LDA
00C04A  2               mne_ldxx        = 73            ;LDX
00C04A  2               mne_ldyx        = 83            ;LDY
00C04A  2               mne_lsrx        = 64            ;LSR
00C04A  2               mne_mvnx        = 48            ;MVN
00C04A  2               mne_mvpx        = 58            ;MVP
00C04A  2               mne_nopx        = 56            ;NOP
00C04A  2               mne_orax        = 6             ;ORA
00C04A  2               mne_peax        = 2             ;PEA
00C04A  2               mne_peix        = 33            ;PEI
00C04A  2               mne_perx        = 60            ;PER
00C04A  2               mne_phax        = 3             ;PHA
00C04A  2               mne_phbx        = 10            ;PHB
00C04A  2               mne_phdx        = 26            ;PHD
00C04A  2               mne_phkx        = 38            ;PHK
00C04A  2               mne_phpx        = 51            ;PHP
00C04A  2               mne_phxx        = 75            ;PHX
00C04A  2               mne_phyx        = 85            ;PHY
00C04A  2               mne_plax        = 4             ;PLA
00C04A  2               mne_plbx        = 11            ;PLB
00C04A  2               mne_pldx        = 28            ;PLD
00C04A  2               mne_plpx        = 52            ;PLP
00C04A  2               mne_plxx        = 76            ;PLX
00C04A  2               mne_plyx        = 86            ;PLY
00C04A  2               mne_repx        = 49            ;REP
00C04A  2               mne_rolx        = 41            ;ROL
00C04A  2               mne_rorx        = 62            ;ROR
00C04A  2               mne_rtix        = 37            ;RTI
00C04A  2               mne_rtlx        = 46            ;RTL
00C04A  2               mne_rtsx        = 67            ;RTS
00C04A  2               mne_sbcx        = 14            ;SBC
00C04A  2               mne_secx        = 19            ;SEC
00C04A  2               mne_sedx        = 25            ;SED
00C04A  2               mne_seix        = 34            ;SEI
00C04A  2               mne_sepx        = 50            ;SEP
00C04A  2               mne_stax        = 7             ;STA
00C04A  2               mne_stpx        = 57            ;STP
00C04A  2               mne_stxx        = 80            ;STX
00C04A  2               mne_styx        = 89            ;STY
00C04A  2               mne_stzx        = 91            ;STZ
00C04A  2               mne_taxx        = 72            ;TAX
00C04A  2               mne_tayx        = 82            ;TAY
00C04A  2               mne_tcdx        = 24            ;TCD
00C04A  2               mne_tcsx        = 66            ;TCS
00C04A  2               mne_tdcx        = 17            ;TDC
00C04A  2               mne_trbx        = 12            ;TRB
00C04A  2               mne_tsbx        = 13            ;TSB
00C04A  2               mne_tscx        = 22            ;TSC
00C04A  2               mne_tsxx        = 79            ;TSX
00C04A  2               mne_txax        = 8             ;TXA
00C04A  2               mne_txsx        = 69            ;TXS
00C04A  2               mne_txyx        = 90            ;TXY
00C04A  2               mne_tyax        = 9             ;TYA
00C04A  2               mne_tyxx        = 81            ;TYX
00C04A  2               mne_waix        = 32            ;WAI
00C04A  2               mne_wdmx        = 47            ;WDM
00C04A  2               mne_xbax        = 0             ;XBA
00C04A  2               mne_xcex        = 30            ;XCE
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;MISCELLANEOUS CONSTANTS
00C04A  2               ;
00C04A  2               halftab         = 4             ;1/2 tabulation spacing
00C04A  2               memprfx         = '>'           ;memory dump prefix
00C04A  2               memsepch        = ':'           ;memory dump separator
00C04A  2               memsubch        = '.'           ;memory dump non-print char
00C04A  2               srinit          = %00110000     ;SR initialization value
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;DIRECT PAGE STORAGE
00C04A  2               ;
00C04A  2               reg_pbx         = zeropage      ;PB
00C04A  2               reg_pcx         = reg_pbx+s_mpupbx;PC
00C04A  2               reg_srx         = reg_pcx+s_mpupcx;SR
00C04A  2               reg_ax          = reg_srx+s_mpusrx;.C
00C04A  2               reg_xx          = reg_ax+s_word ;.X
00C04A  2               reg_yx          = reg_xx+s_word ;.Y
00C04A  2               reg_spx         = reg_yx+s_word ;SP
00C04A  2               reg_dpx         = reg_spx+s_mpuspx;DP
00C04A  2               reg_dbx         = reg_dpx+s_mpudpx;DB
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	general workspace...
00C04A  2               ;
00C04A  2               addra           = reg_dbx+s_mpudbx;address #1
00C04A  2               addrb           = addra+s_addr  ;address #2
00C04A  2               faca            = addrb+s_addr  ;primary accumulator
00C04A  2               facax           = faca+s_pfac   ;extended primary accumulator
00C04A  2               facb            = facax+s_pfac  ;secondary accumulator
00C04A  2               facc            = facb+s_sfac   ;tertiary accumulator
00C04A  2               operand         = facc+s_sfac   ;instruction operand
00C04A  2               auxbufix        = operand+s_oper;auxiliary buffer index
00C04A  2               ibufidx         = auxbufix+s_byte;input buffer index
00C04A  2               bitsdig         = ibufidx+s_byte;bits per numeral
00C04A  2               numeral         = bitsdig+s_byte;numeral buffer
00C04A  2               radix           = numeral+s_byte;radix index
00C04A  2               admodidx        = radix+s_byte  ;addressing mode index
00C04A  2               charcnt         = admodidx+s_byte;character counter
00C04A  2               instsize        = charcnt+s_word;instruction size
00C04A  2               mnepck          = instsize+s_word;encoded mnemonic
00C04A  2               opcode          = mnepck+s_mnepck;current opcode
00C04A  2               status          = opcode+s_byte ;I/O status flag
00C04A  2               xrtemp          = status+s_byte ;temp .X storage
00C04A  2               eopsize         = xrtemp+s_byte ;entered operand size
00C04A  2               flimflag        = eopsize+s_byte;forced long immediate...
00C04A  2               vecbrkia        = flimflag+s_byte;system indirect BRK vector
00C04A  2               ;
00C04A  2               ;	xx000000
00C04A  2               ;	||
00C04A  2               ;	|+---------> 0: .X/.Y =  8 bits
00C04A  2               ;	|            1: .X/.Y =  18 bits
00C04A  2               ;	+----------> 0: .A =  8 bits
00C04A  2               ;	             1: .A =  16 bits
00C04A  2               ;
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;	During assembly, FLIMFLAG indicates the operand size used with an immed-
00C04A  2               ;	iate mode instruction, thus causing the following disassembly to display
00C04A  2               ;	the assembled  operand size.   During disassembly,  FLIMFLAG will mirror
00C04A  2               ;	the effect of the most recent REP or SEP instruction.
00C04A  2               ;	------------------------------------------------------------------------
00C04A  2               ;
00C04A  2               iopsize         = flimflag+s_byte;operand size
00C04A  2               range           = iopsize+s_byte;allowable radix range
00C04A  2               vopsflag        = range+s_byte  ;VOPS & ROPS mode bits
00C04A  2               ;
00C04A  2               ;
00C04A  2               ;	copy/fill workspace (overlaps some of the above)...
00C04A  2               ;
00C04A  2               mcftwork        = faca          ;start of copy/fill code
00C04A  2               mcftopc         = mcftwork+s_byte;instruction opcode
00C04A  2               mcftbnk         = mcftopc+s_byte;banks
00C04A  2               ;
00C04A  2               ;================================================================================
00C04A  2               ;
00C04A  2               ;SUPERMON 816 JUMP TABLE
00C04A  2               ;
00C04A  2               ;
00C04A  2               JMON:
00C04A  2  80 02                BRA     mon             ;cold start entry
00C04C  2               JMONBRK:
00C04C  2  80 4C                BRA     monbrk          ;software interrupt intercept
00C04E  2               ;
00C04E  2               ;
00C04E  2               ;================================================================================
00C04E  2               ;
00C04E  2               ;mon: SUPERMON 816 COLD START
00C04E  2               ;
00C04E  2               mon:
00C04E  2  C2 10                INDEX16
00C050  2  E2 20                ACCUMULATOR8
00C052  2  A0 00 00             LDY     #$0000          ; LOAD $00 INTO Y
00C055  2               OUTSTRLP:
00C055  2  B9 E7 D0             LDA     ALIVEM,Y        ; LOAD NEXT CHAR FROM STRING INTO ACC
00C058  2  C9 00                CMP     #$00            ; IS NULL?
00C05A  2  F0 07                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00C05C  2  20 71 FF             JSR     putcha          ; PRINT CHAR IN ACC
00C05F  2  C8                   INY                     ; Y=Y+1 (BUMP INDEX)
00C060  2  4C 55 C0             JMP     OUTSTRLP        ; DO NEXT CHAR
00C063  2               ENDOUTSTR:
00C063  2  E2 10                INDEX8
00C065  2               
00C065  2               
00C065  2  C2 20                SLONGA
00C067  2  AD 02 03             LDA     vecbrki         ;BRK vector
00C06A  2               ;        CMPW    monbrk          ;pointing at monitor?
00C06A  2               ;        BNE     moncontinue
00C06A  2               ;        JMP     monreg          ;yes, ignore cold start
00C06A  2               ;
00C06A  2               moncontinue:
00C06A  2  85 4D                STA     vecbrkia        ;save vector for exit
00C06C  2  A9 9A C0             LDAW    monbrk          ;Supermon 816 intercepts...
00C06F  2  8D 02 03             STA     vecbrki         ;BRK handler
00C072  2  E2 30                SHORTR                  ;8 bit registers
00C074  2  A2 3F                LDX     #vopsflag-reg_pbx
00C076  2               ;
00C076  2               _0000010:
00C076  2  74 10                STZ     reg_pbx,x       ;clear DP storage
00C078  2  CA                   DEX
00C079  2  10 FB                BPL     _0000010
00C07B  2               ;
00C07B  2               ;
00C07B  2               ;	initialize register shadows...
00C07B  2               ;
00C07B  2  A9 30                LDA     #srinit
00C07D  2  85 13                STA     reg_srx         ;status register
00C07F  2  C2 20                SLONGA                  ;16 bit .A
00C081  2  A9 FF 7F             LDAW    hwstack         ;top of hardware stack
00C084  2  1B                   TCS                     ;set SP
00C085  2  7B                   TDC                     ;get & save...
00C086  2  85 1C                STA     reg_dpx         ;DP register
00C088  2  A9 00 00             LDAW    0
00C08B  2  E2 20                SHORTA
00C08D  2  4B                   PHK
00C08E  2  68                   PLA                     ;capture PB &...
00C08F  2  85 10                STA     reg_pbx         ;set
00C091  2  8B                   PHB
00C092  2  68                   PLA                     ;capture DB &...
00C093  2  85 1E                STA     reg_dbx         ;set
00C095  2               ;
00C095  2               ;
00C095  2               ;	print startup banner...
00C095  2               ;
00C095  2  F4 5D D0             PEA     mm_entry        ;"...ready..."
00C098  2  80 36                BRA     moncom
00C09A  2               ;
00C09A  2               ;================================================================================
00C09A  2               ;
00C09A  2               ;monbrk: SOFTWARE INTERRUPT INTERCEPT
00C09A  2               ;
00C09A  2               ;	------------------------------------------------------------------------
00C09A  2               ;	This is the entry point taken when a BRK instruction is executed.  It is
00C09A  2               ;	assumed that the BRK  handler has pushed the registers to the stack that
00C09A  2               ;	are not automatically pushed by the MPU in response to BRK.
00C09A  2               ;	------------------------------------------------------------------------
00C09A  2               ;
00C09A  2               monbrk:
00C09A  2  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
00C09B  2  18                   CLC                     ;
00C09C  2  FB                   XCE                     ; SET NATIVE MODE
00C09D  2  8B                   PHB                     ;save DB
00C09E  2  0B                   PHD                     ;save DP
00C09F  2  C2 20                SLONGA                  ;16 bit .A
00C0A1  2  48                   PHA
00C0A2  2  A9 00 00             LDAW    $0000           ;set DPR
00C0A5  2  5B                   TCD                     ;
00C0A6  2  68                   PLA
00C0A7  2  C2 30                LONGR                   ;store 16 bit registers
00C0A9  2  85 14                STA     <reg_ax         ;.A
00C0AB  2  86 16                STX     <reg_xx         ;.X
00C0AD  2  84 18                STY     <reg_yx         ;.Y
00C0AF  2  68                   PLA                     ;get DP &...
00C0B0  2  85 1C                STA     <reg_dpx        ;store
00C0B2  2  E2 10                SHORTX
00C0B4  2  FA                   PLX                     ;get DB &...
00C0B5  2  86 1E                STX     <reg_dbx        ;store
00C0B7  2  FA                   PLX                     ;get SR &...
00C0B8  2  86 13                STX     <reg_srx        ;store
00C0BA  2  68                   PLA                     ;get PC &...
00C0BB  2  85 11                STA     <reg_pcx        ;store
00C0BD  2  FA                   PLX                     ;get PB &...
00C0BE  2  86 10                STX     <reg_pbx        ;store
00C0C0  2  C2 20                SLONGA
00C0C2  2  A9 FF 7F             LDAW    hwstack         ;top of hardware stack
00C0C5  2  1B                   TCS                     ;set SPR
00C0C6  2               ;        CLI                     ;reenable IRQs
00C0C6  2  78                   SEI                     ;Disable Interrupts
00C0C7  2  E2 20                SHORTA
00C0C9  2  A9 00                LDA     #$00            ;set DBR
00C0CB  2  48                   PHA
00C0CC  2  AB                   PLB
00C0CD  2  F4 53 D0             PEA     mm_brk          ;"*BRK"
00C0D0  2               ;
00C0D0  2               ;================================================================================
00C0D0  2               ;
00C0D0  2               ;moncom: COMMON ENTRY POINT
00C0D0  2               ;
00C0D0  2               ;	--------------------------------------
00C0D0  2               ;	DO NOT directly call this entry point!
00C0D0  2               ;	--------------------------------------
00C0D0  2               ;
00C0D0  2               moncom:
00C0D0  2  20 DC C7             JSR     sprint          ;print heading
00C0D3  2  C2 20                SLONGA
00C0D5  2  3B                   TSC                     ;get SP &...
00C0D6  2  85 1A                STA     <reg_spx        ;store
00C0D8  2  C2 FF                REP     #%11111111      ;clear SR &...
00C0DA  2  E2 30                SEP     #srinit         ;set default state
00C0DC  2  38                   SEC                     ;see next
00C0DD  2               ;
00C0DD  2               ;================================================================================
00C0DD  2               ;
00C0DD  2               ;monreg: DISPLAY MPU REGISTERS
00C0DD  2               ;
00C0DD  2               ;	---------
00C0DD  2               ;	syntax: R
00C0DD  2               ;	---------
00C0DD  2               ;
00C0DD  2               monreg:
00C0DD  2  B0 03                BCS     _0010010        ;okay to proceed
00C0DF  2               ;
00C0DF  2  4C 7A C1             JMP     monerr          ;error if called with a parm
00C0E2  2               ;
00C0E2  2               _0010010:
00C0E2  2  F4 80 D0             PEA     mm_regs
00C0E5  2  20 DC C7             JSR     sprint          ;display heading
00C0E8  2               ;
00C0E8  2               ;
00C0E8  2               ;	display program bank & counter...
00C0E8  2               ;
00C0E8  2  E2 20                SHORTA
00C0EA  2  A5 10                LDA     <reg_pbx        ;PB
00C0EC  2  20 B2 C7             JSR     dpyhex          ;display as hex ASCII
00C0EF  2  20 D7 C7             JSR     printspc        ;inter-field space
00C0F2  2               
00C0F2  2  C2 20                SLONGA
00C0F4  2  A5 11                LDA     <reg_pcx
00C0F6  2  E2 20                SHORTA
00C0F8  2  20 A2 C7             JSR     dpyhexw         ;display PC
00C0FB  2  A2 02                LDX     #2
00C0FD  2  20 BC C7             JSR     multspc         ;inter-field spacing
00C100  2               ;
00C100  2               ;
00C100  2               ;	display SR in bitwise fashion...
00C100  2               ;
00C100  2  A6 13                LDX     <reg_srx        ;SR
00C102  2  A0 08                LDY     #s_bibyte       ;bits in a byte
00C104  2               ;
00C104  2               _0010020:
00C104  2  8A                   TXA                     ;remaining SR bits
00C105  2  0A                   ASL                     ;grab one of them
00C106  2  AA                   TAX                     ;save remainder
00C107  2  A9 30                LDA     #'0'            ;a clear bit but...
00C109  2  69 00                ADC     #0              ;adjust if set &...
00C10B  2  20 71 FF             JSR     putcha          ;print
00C10E  2  88                   DEY                     ;bit processed
00C10F  2  D0 F3                BNE     _0010020        ;do another
00C111  2               ;
00C111  2               ;
00C111  2               ;	display .C, .X, .Y, SP & DP...
00C111  2               ;
00C111  2               _0010030:
00C111  2  20 D7 C7             JSR     printspc        ;spacing
00C114  2  C2 20                SLONGA
00C116  2  B9 14 00             LDA     reg_ax,y        ;get register value
00C119  2  E2 20                SHORTA
00C11B  2  20 A2 C7             JSR     dpyhexw         ;convert & display
00C11E  2               
00C11E  2               ;         .rept s_word
00C11E  2  C8                   INY
00C11F  2  C8                   INY
00C120  2               ;         .endr
00C120  2               
00C120  2  C0 08                CPY     #reg_dbx-reg_ax-2
00C122  2  90 ED                BCC     _0010030        ;next
00C124  2               
00C124  2  F4 A9 D0             PEA     mm_regs1
00C127  2  20 DC C7             JSR     sprint          ;display heading
00C12A  2  C2 20                SLONGA
00C12C  2  A5 1C                LDA     <reg_dpx        ;get register value
00C12E  2  E2 20                SHORTA
00C130  2  20 A2 C7             JSR     dpyhexw         ;convert & display
00C133  2               ;
00C133  2               ;
00C133  2               ;	display DB...
00C133  2               ;
00C133  2  20 D7 C7             JSR     printspc        ;more spacing
00C136  2  A5 1E                LDA     <reg_dbx        ;get DB &...
00C138  2  20 B2 C7             JSR     dpyhex          ;display it
00C13B  2               ;
00C13B  2               ;================================================================================
00C13B  2               ;
00C13B  2               ;monce: COMMAND EXECUTIVE
00C13B  2               ;
00C13B  2               monce:
00C13B  2  E2 20                SHORTA
00C13D  2  A9 00                LDA     #0              ;default buffer index
00C13F  2               ;
00C13F  2               moncea:
00C13F  2  E2 30                SHORTR                  ;alternate entry point
00C141  2  85 3D                STA     ibufidx         ;(re)set buffer index
00C143  2  F4 7C D0             PEA     mm_prmpt
00C146  2  20 DC C7             JSR     sprint          ;display input prompt
00C149  2  20 E9 CB             JSR     input           ;await some input
00C14C  2               ;
00C14C  2               _0020010:
00C14C  2  20 3F CC             JSR     getcharc        ;read from buffer
00C14F  2  F0 EA                BEQ     monce           ;terminator, just loop
00C151  2               ;
00C151  2  C9 20                CMP     #a_blank
00C153  2  F0 F7                BEQ     _0020010        ;strip leading blanks
00C155  2               ;
00C155  2  A2 0C                LDX     #n_mpctab-1     ;number of primary commands
00C157  2               ;
00C157  2               _0020020:
00C157  2  DD F7 CC             CMP     mpctab,x        ;search primary command list
00C15A  2  D0 0E                BNE     _0020030
00C15C  2               ;
00C15C  2  8A                   TXA                     ;get index
00C15D  2  0A                   ASL                     ;double for offset
00C15E  2  AA                   TAX
00C15F  2  C2 20                SLONGA
00C161  2  BD 04 CD             LDA     mpcextab,x      ;command address -1
00C164  2  48                   PHA                     ;prime the stack
00C165  2  E2 20                SHORTA
00C167  2  4C 8B CA             JMP     getparm         ;evaluate parm & execute command
00C16A  2               ;
00C16A  2               _0020030:
00C16A  2  CA                   DEX
00C16B  2  10 EA                BPL     _0020020        ;continue searching primary commands
00C16D  2               ;
00C16D  2  A2 03                LDX     #n_radix-1      ;number of radices
00C16F  2               ;
00C16F  2               _0020040:
00C16F  2  DD 32 CD             CMP     radxtab,x       ;search conversion command list
00C172  2  D0 03                BNE     _0020050
00C174  2               ;
00C174  2  4C C2 C5             JMP     monenv          ;convert & display parameter
00C177  2               ;
00C177  2               _0020050:
00C177  2  CA                   DEX
00C178  2  10 F5                BPL     _0020040
00C17A  2               ;
00C17A  2               ;================================================================================
00C17A  2               ;
00C17A  2               ;monerr: COMMON ERROR HANDLER
00C17A  2               ;
00C17A  2               monerr:
00C17A  2  E2 30                SHORTR                  ;8 bit registers
00C17C  2               ;
00C17C  2               monerraa:
00C17C  2  20 89 C7             JSR     dpyerr          ;indicate an error &...
00C17F  2  80 BA                BRA     monce           ;return to input loop
00C181  2               
00C181  2               ;
00C181  2               ;================================================================================
00C181  2               ;
00C181  2               ;monasc: ASSEMBLE CODE
00C181  2               ;
00C181  2               ;	-----------------------------------------------------------------------
00C181  2               ;	syntax: A <addr> <mnemonic> [<argument>]
00C181  2               ;
00C181  2               ;	After a line of code has been successfully assembled it will be disass-
00C181  2               ;	embled & displayed,  & the monitor will prompt with the next address to
00C181  2               ;	which code may be assembled.
00C181  2               ;	-----------------------------------------------------------------------
00C181  2               ;
00C181  2               monasc:
00C181  2  90 03                BCC     _0030020        ;assembly address entered
00C183  2               ;
00C183  2               _0030010:
00C183  2  4C 7A C1             JMP     monerr          ;terminate w/error
00C186  2               ;
00C186  2               ;
00C186  2               ;	evaluate assembly address...
00C186  2               ;
00C186  2               _0030020:
00C186  2  20 7B CA             JSR     facasize        ;check address...
00C189  2  C9 04                CMP     #s_dword        ;range
00C18B  2  B0 F6                BCS     _0030010        ;out of range - error
00C18D  2               ;
00C18D  2  20 5D CA             JSR     facaddra        ;store assembly address
00C190  2               ;
00C190  2               ;
00C190  2               ;	initialize workspace...
00C190  2               ;
00C190  2  A2 1F                LDX     #s_auxbuf-s_byte
00C192  2               ;
00C192  2               _0030030:
00C192  2  9E 46 02             STZ     auxbuf,x        ;clear addressing mode buffer
00C195  2  CA                   DEX
00C196  2  D0 FA                BNE     _0030030
00C198  2               ;
00C198  2  A9 20                LDA     #a_blank
00C19A  2  8D 46 02             STA     auxbuf          ;preamble placeholder
00C19D  2  20 E1 C9             JSR     clroper         ;clear operand
00C1A0  2  64 3C                STZ     auxbufix        ;reset addressing mode index
00C1A2  2  64 4C                STZ     flimflag        ;clear forced long immediate
00C1A4  2  64 46                STZ     mnepck          ;clear encoded...
00C1A6  2  64 47                STZ     mnepck+s_byte   ;mnemonic workspace
00C1A8  2  64 4F                STZ     vopsflag        ;clear 8/16 or relative flag
00C1AA  2               ;
00C1AA  2               ;
00C1AA  2               ;	encode mnemonic...
00C1AA  2               ;
00C1AA  2  A0 03                LDY     #s_mnemon       ;expected mnemonic size
00C1AC  2               ;
00C1AC  2               _0030040:
00C1AC  2  20 DA CB             JSR     getcharw        ;get from buffer wo/whitespace
00C1AF  2  D0 0A                BNE     _0030060        ;gotten
00C1B1  2               ;
00C1B1  2  C0 03                CPY     #s_mnemon       ;any input at all?
00C1B3  2  90 03                BCC     _0030050        ;yes
00C1B5  2               ;
00C1B5  2  4C 3B C1             JMP     monce           ;no, abort further assembly
00C1B8  2               ;
00C1B8  2               _0030050:
00C1B8  2  4C 58 C3             JMP     monasc10        ;incomplete mnemonic - error
00C1BB  2               ;
00C1BB  2               _0030060:
00C1BB  2  38                   SEC
00C1BC  2  E9 3F                SBC     #a_mnecvt       ;ASCII to binary factor
00C1BE  2  A2 05                LDX     #n_shfenc       ;shifts required to encode
00C1C0  2               ;
00C1C0  2               _0030070:
00C1C0  2  4A                   LSR                     ;shift out a bit...
00C1C1  2  66 47                ROR     mnepck+s_byte   ;into...
00C1C3  2  66 46                ROR     mnepck          ;encoded mnemonic
00C1C5  2  CA                   DEX
00C1C6  2  D0 F8                BNE     _0030070        ;next bit
00C1C8  2               ;
00C1C8  2  88                   DEY
00C1C9  2  D0 E1                BNE     _0030040        ;get next char
00C1CB  2               ;
00C1CB  2               ;
00C1CB  2               ;	test for copy instruction...
00C1CB  2               ;	------------------------------------------------------------------------
00C1CB  2               ;	The MVN & MVP instructions accept two operands & hence have an irregular
00C1CB  2               ;	syntax.  Therefore, special handling is necessary to assemble either of
00C1CB  2               ;	these instructions.
00C1CB  2               ;
00C1CB  2               ;	The official WDC syntax has the programmer entering a pair of 24 bit ad-
00C1CB  2               ;	dresses as operands, with the assembler isolating bits 16-23 to	use as
00C1CB  2               ;	operands.  This formality has been dispensed with in this monitor & the
00C1CB  2               ;	operands are expected to be 8 bit bank values.
00C1CB  2               ;	------------------------------------------------------------------------
00C1CB  2               ;
00C1CB  2  C2 20                SLONGA                  ;16 bit load
00C1CD  2  A5 46                LDA     mnepck          ;packed menmonic
00C1CF  2  A2 54                LDX     #opc_mvn        ;MVN opcode
00C1D1  2  C9 DC 7D             CMPW    mne_mvn         ;is it MVN?
00C1D4  2  F0 07                BEQ     monasc01        ;yes
00C1D6  2               ;
00C1D6  2  A2 44                LDX     #opc_mvp        ;MVP opcode
00C1D8  2  C9 DC 8D             CMPW    mne_mvp         ;is it MVP?
00C1DB  2  D0 30                BNE     monasc02        ;no
00C1DD  2               ;
00C1DD  2               ;
00C1DD  2               ;	assemble copy instruction...
00C1DD  2               ;
00C1DD  2               monasc01:
00C1DD  2  86 48                STX     opcode          ;store relevant opcode
00C1DF  2  E2 20                SHORTA
00C1E1  2  20 E9 CA             JSR     instdata        ;get instruction data
00C1E4  2  86 4B                STX     eopsize         ;effective operand size
00C1E6  2  E8                   INX
00C1E7  2  86 44                STX     instsize        ;instruction size
00C1E9  2  A2 01                LDX     #s_oper-s_word  ;operand index
00C1EB  2  86 4A                STX     xrtemp          ;set it
00C1ED  2               ;
00C1ED  2               _0040010:
00C1ED  2  20 F5 C7             JSR     ascbin          ;evaluate bank number
00C1F0  2  B0 50                BCS     monasc04        ;conversion error
00C1F2  2               ;
00C1F2  2  F0 4E                BEQ     monasc04        ;nothing returned - error
00C1F4  2               ;
00C1F4  2  20 7B CA             JSR     facasize        ;bank must be...
00C1F7  2  C9 02                CMP     #s_word         ;8 bits
00C1F9  2  B0 47                BCS     monasc04        ;it isn't - error
00C1FB  2               ;
00C1FB  2  A5 25                LDA     faca            ;bank
00C1FD  2  A6 4A                LDX     xrtemp          ;operand index
00C1FF  2  95 39                STA     operand,x       ;store
00C201  2  C6 4A                DEC     xrtemp          ;index=index-1
00C203  2  10 E8                BPL     _0040010        ;get destination bank
00C205  2               ;
00C205  2  20 7A CB             JSR     getcharr        ;should be no more input
00C208  2  D0 38                BNE     monasc04        ;there is - error
00C20A  2               ;
00C20A  2  4C 08 C3             JMP     monasc08        ;finish MVN/MVP assembly
00C20D  2               ;
00C20D  2               ;
00C20D  2               ;	continue with normal assembly...
00C20D  2               ;
00C20D  2               monasc02:
00C20D  2  E2 20                SHORTA                  ;back to 8 bits
00C20F  2               ;
00C20F  2               monasc03:
00C20F  2  20 DA CB             JSR     getcharw        ;get next char
00C212  2  F0 3D                BEQ     monasc06        ;EOI, no argument
00C214  2               ;
00C214  2  C9 21                CMP     #amp_flim
00C216  2  D0 0A                BNE     _0050010        ;no forced long immediate
00C218  2               ;
00C218  2  A5 4C                LDA     flimflag        ;FLIM already set?
00C21A  2  D0 26                BNE     monasc04        ;yes - error
00C21C  2               ;
00C21C  2  A9 C0                LDA     #flimmask
00C21E  2  85 4C                STA     flimflag        ;set flag &...
00C220  2  80 ED                BRA     monasc03        ;get next char
00C222  2               ;
00C222  2               _0050010:
00C222  2  C9 23                CMP     #amp_imm        ;immediate mode?
00C224  2  F0 08                BEQ     _0050020        ;yes
00C226  2               ;
00C226  2  C9 28                CMP     #amp_ind        ;indirect mode?
00C228  2  F0 04                BEQ     _0050020        ;yes
00C22A  2               ;
00C22A  2  C9 5B                CMP     #amp_indl       ;indirect long mode?
00C22C  2  D0 07                BNE     _0050030        ;no
00C22E  2               ;
00C22E  2               _0050020:
00C22E  2  8D 46 02             STA     auxbuf          ;set addressing mode preamble
00C231  2  E6 3C                INC     auxbufix        ;bump aux buffer index &...
00C233  2  80 02                BRA     _0050040        ;evaluate operand
00C235  2               ;
00C235  2               _0050030:
00C235  2  C6 3D                DEC     ibufidx         ;position back to char
00C237  2               ;
00C237  2               _0050040:
00C237  2  20 F5 C7             JSR     ascbin          ;evaluate operand
00C23A  2  D0 09                BNE     monasc05        ;evaluated
00C23C  2               ;
00C23C  2  B0 04                BCS     monasc04        ;conversion error
00C23E  2               ;
00C23E  2  A5 3C                LDA     auxbufix        ;no operand...any preamble?
00C240  2  F0 0F                BEQ     monasc06        ;no, syntax is okay so far
00C242  2               ;
00C242  2               monasc04:
00C242  2  4C 58 C3             JMP     monasc10        ;abort w/error
00C245  2               ;
00C245  2               monasc05:
00C245  2  20 7B CA             JSR     facasize        ;size operand
00C248  2  C9 04                CMP     #s_dword        ;max is 24 bits
00C24A  2  B0 F6                BCS     monasc04        ;too big
00C24C  2               ;
00C24C  2  85 4B                STA     eopsize         ;save operand size
00C24E  2  20 71 CA             JSR     facaoper        ;store operand
00C251  2               ;
00C251  2               monasc06:
00C251  2  C6 3D                DEC     ibufidx         ;back to last char
00C253  2  A6 3C                LDX     auxbufix        ;mode buffer index
00C255  2  D0 01                BNE     _0060010        ;preamble in buffer
00C257  2               ;
00C257  2  E8                   INX                     ;step past preamble position
00C258  2               ;
00C258  2               _0060010:
00C258  2  20 3F CC             JSR     getcharc        ;get a char w/forced UC
00C25B  2  F0 0A                BEQ     _0060030        ;EOI
00C25D  2               ;
00C25D  2  E0 20                CPX     #s_auxbuf       ;mode buffer full?
00C25F  2  B0 E1                BCS     monasc04        ;yes, too much input
00C261  2               ;
00C261  2               _0060020:
00C261  2  9D 46 02             STA     auxbuf,x        ;store for comparison
00C264  2  E8                   INX
00C265  2  D0 F1                BNE     _0060010
00C267  2               ;
00C267  2               ;
00C267  2               ;	evaluate mnemonic...
00C267  2               ;
00C267  2               _0060030:
00C267  2  A2 5B                LDX     #n_mnemon-1     ;starting mnemonic index
00C269  2               ;
00C269  2               monasc07:
00C269  2  8A                   TXA                     ;convert index...
00C26A  2  0A                   ASL                     ;to offset
00C26B  2  A8                   TAY                     ;now mnemonic table index
00C26C  2  C2 20                SLONGA                  ;16 bit compare
00C26E  2  B9 3F CD             LDA     mnetab,y        ;get mnemonic from table
00C271  2  C5 46                CMP     mnepck          ;compare to entered mnemonic
00C273  2  E2 20                SHORTA                  ;back to 8 bits
00C275  2  F0 05                BEQ     _0070020        ;match
00C277  2               ;
00C277  2               _0070010:
00C277  2  CA                   DEX                     ;try next mnemonic
00C278  2  30 C8                BMI     monasc04        ;unknown mnemonic - error
00C27A  2               ;
00C27A  2  80 ED                BRA     monasc07        ;keep going
00C27C  2               ;
00C27C  2               _0070020:
00C27C  2  86 46                STX     mnepck          ;save mnemonic index
00C27E  2  8A                   TXA
00C27F  2  A2 00                LDX     #0              ;trial opcode
00C281  2               ;
00C281  2               _0070030:
00C281  2  DD F7 CD             CMP     mnetabix,x      ;search index table...
00C284  2  F0 05                BEQ     _0070050        ;for a match
00C286  2               ;
00C286  2               _0070040:
00C286  2  E8                   INX                     ;keep going until we...
00C287  2  D0 F8                BNE     _0070030        ;search entire table
00C289  2               ;
00C289  2  80 B7                BRA     monasc04        ;this shouldn't happen!
00C28B  2               ;
00C28B  2               ;	---------------------------------------------------------------------
00C28B  2               ;	If the mnemonic index table search fails then there is a coding error
00C28B  2               ;	somewhere, as every entry in the mnemonic table is supposed to have a
00C28B  2               ;	matching cardinal index.
00C28B  2               ;	---------------------------------------------------------------------
00C28B  2               ;
00C28B  2               ;
00C28B  2               ;	evaluate addressing mode...
00C28B  2               ;
00C28B  2               _0070050:
00C28B  2  86 48                STX     opcode          ;save trial opcode
00C28D  2  20 E9 CA             JSR     instdata        ;get related instruction data
00C290  2  85 4F                STA     vopsflag        ;save 8/16 or relative flag
00C292  2  86 4D                STX     iopsize         ;operand size
00C294  2  E8                   INX
00C295  2  86 44                STX     instsize        ;instruction size
00C297  2  A6 48                LDX     opcode          ;recover trial opcode
00C299  2  98                   TYA                     ;addressing mode
00C29A  2  0A                   ASL                     ;create table index
00C29B  2  A8                   TAY
00C29C  2  C2 20                SLONGA
00C29E  2  B9 FB CF             LDA     ms_lutab,y      ;mode lookup table
00C2A1  2  85 22                STA     addrb           ;set pointer
00C2A3  2  E2 20                SHORTA
00C2A5  2  A0 00                LDY     #0
00C2A7  2               ;
00C2A7  2               _0070060:
00C2A7  2  B1 22                LDA     (addrb),y       ;table addressing mode
00C2A9  2  D9 46 02             CMP     auxbuf,y        ;entered addressing mode
00C2AC  2  F0 04                BEQ     _0070080        ;okay so far
00C2AE  2               ;
00C2AE  2               _0070070:
00C2AE  2  A5 46                LDA     mnepck          ;reload mnemonic index
00C2B0  2  80 D4                BRA     _0070040        ;wrong opcode for addresing mode
00C2B2  2               ;
00C2B2  2               _0070080:
00C2B2  2  09 00                ORA     #0              ;last char the terminator?
00C2B4  2  F0 03                BEQ     _0070090        ;yes, evaluate operand
00C2B6  2               ;
00C2B6  2  C8                   INY
00C2B7  2  80 EE                BRA     _0070060        ;keep testing
00C2B9  2               ;
00C2B9  2               ;
00C2B9  2               ;	evaluate operand...
00C2B9  2               ;
00C2B9  2               _0070090:
00C2B9  2  A5 4B                LDA     eopsize         ;entered operand size
00C2BB  2  D0 06                BNE     _0070100        ;non-zero
00C2BD  2               ;
00C2BD  2  05 4D                ORA     iopsize         ;instruction operand size
00C2BF  2  D0 ED                BNE     _0070070        ;wrong opcode - keep trying
00C2C1  2               ;
00C2C1  2  80 45                BRA     monasc08        ;assemble instruction
00C2C3  2               ;
00C2C3  2               _0070100:
00C2C3  2  24 4F                BIT     vopsflag        ;is this a branch?
00C2C5  2  70 3A                BVS     _0070160        ;yes, evaluate
00C2C7  2               ;
00C2C7  2  A5 4D                LDA     iopsize         ;instruction operand size
00C2C9  2  24 4F                BIT     vopsflag        ;variable size operand allowed?
00C2CB  2  30 15                BMI     _0070130        ;yes
00C2CD  2               ;
00C2CD  2  24 4C                BIT     flimflag        ;was forced immediate set?
00C2CF  2  10 03                BPL     _0070110        ;no
00C2D1  2               ;
00C2D1  2  4C 58 C3             JMP     monasc10        ;yes - error
00C2D4  2               ;
00C2D4  2               _0070110:
00C2D4  2  C5 4B                CMP     eopsize         ;entered operand size
00C2D6  2  90 D6                BCC     _0070070        ;operand too big
00C2D8  2               ;
00C2D8  2  85 4B                STA     eopsize         ;new operand size
00C2DA  2  80 2C                BRA     monasc08        ;assemble, otherwise...
00C2DC  2               ;
00C2DC  2               _0070120:
00C2DC  2  C5 4B                CMP     eopsize         ;exact size match required
00C2DE  2  D0 CE                BNE     _0070070        ;mismatch - wrong opcode
00C2E0  2               ;
00C2E0  2  80 26                BRA     monasc08        ;assemble
00C2E2  2               ;
00C2E2  2               ;
00C2E2  2               ;	process variable size immediate mode operand...
00C2E2  2               ;
00C2E2  2               _0070130:
00C2E2  2  A6 4B                LDX     eopsize         ;entered operand size
00C2E4  2  E0 03                CPX     #s_xword        ;check size
00C2E6  2  B0 70                BCS     monasc10        ;too big - error
00C2E8  2               ;
00C2E8  2  24 4C                BIT     flimflag        ;forced long immediate?
00C2EA  2  10 06                BPL     _0070140        ;no
00C2EC  2               ;
00C2EC  2  A2 02                LDX     #s_word         ;promote operand size to...
00C2EE  2  86 4B                STX     eopsize         ;16 bits
00C2F0  2  80 08                BRA     _0070150
00C2F2  2               ;
00C2F2  2               _0070140:
00C2F2  2  E0 02                CPX     #s_word         ;16 bits?
00C2F4  2  D0 04                BNE     _0070150        ;no
00C2F6  2               ;
00C2F6  2  A0 C0                LDY     #flimmask       ;yes so force long...
00C2F8  2  84 4C                STY     flimflag        ;immediate disassembly
00C2FA  2               ;
00C2FA  2               _0070150:
00C2FA  2  1A                   INA                     ;new instruction operand size
00C2FB  2  C5 4B                CMP     eopsize         ;compare against operand size
00C2FD  2  90 AF                BCC     _0070070        ;mismatch - can't assemble
00C2FF  2               ;
00C2FF  2  80 07                BRA     monasc08        ;okay, assemble
00C301  2               ;
00C301  2               ;
00C301  2               ;	process relative branch...
00C301  2               ;
00C301  2               _0070160:
00C301  2  20 35 CB             JSR     targoff         ;compute branch offset
00C304  2  B0 52                BCS     monasc10        ;branch out of range
00C306  2               ;
00C306  2  85 4B                STA     eopsize         ;effective operand size
00C308  2               ;
00C308  2               ;
00C308  2               ;	assemble instruction...
00C308  2               ;
00C308  2               monasc08:
00C308  2  A5 48                LDA     opcode          ;opcode
00C30A  2  87 1F                STAIL   addra           ;store at assembly address
00C30C  2  A6 4B                LDX     eopsize         ;any operand to process?
00C30E  2  F0 09                BEQ     _0080020        ;no
00C310  2               ;
00C310  2  9B                   TXY                     ;also storage offset
00C311  2               ;
00C311  2               _0080010:
00C311  2  CA                   DEX
00C312  2  B5 39                LDA     operand,x       ;get operand byte &...
00C314  2  97 1F                STAILY  addra           ;poke into memory
00C316  2  88                   DEY
00C317  2  D0 F8                BNE     _0080010        ;next
00C319  2               ;
00C319  2               _0080020:
00C319  2  A9 0D                LDA     #a_cr
00C31B  2  20 71 FF             JSR     putcha          ;return to left margin
00C31E  2  A9 41                LDA     #asmprfx        ;assembly prefix
00C320  2  20 45 C6             JSR     dpycodaa        ;disassemble & display
00C323  2               ;
00C323  2               ;
00C323  2               ;	prompt for next instruction...
00C323  2               ;
00C323  2               monasc09:
00C323  2  A9 20                LDA     #a_blank
00C325  2  A2 08                LDX     #ascprmct-1
00C327  2               ;
00C327  2               _0090010:
00C327  2  9D 00 02             STA     ibuffer,x       ;prepare buffer for...
00C32A  2  CA                   DEX                     ;next instruction
00C32B  2  10 FA                BPL     _0090010
00C32D  2               ;
00C32D  2  A9 41                LDA     #asmprfx        ;assemble code...
00C32F  2  8D 00 02             STA     ibuffer         ;prompt prefix
00C332  2  A5 21                LDA     addra+s_word    ;next instruction address bank
00C334  2  20 4D C9             JSR     binhex          ;convert to ASCII
00C337  2  8D 02 02             STA     ibuffer+apadrbkh;store MSN in buffer
00C33A  2  8E 03 02             STX     ibuffer+apadrbkl;store LSN in buffer
00C33D  2  A5 20                LDA     addra+s_byte    ;next instruction address MSB
00C33F  2  20 4D C9             JSR     binhex
00C342  2  8D 04 02             STA     ibuffer+apadrmbh
00C345  2  8E 05 02             STX     ibuffer+apadrmbl
00C348  2  A5 1F                LDA     addra           ;next instruction address LSB
00C34A  2  20 4D C9             JSR     binhex
00C34D  2  8D 06 02             STA     ibuffer+apadrlbh
00C350  2  8E 07 02             STX     ibuffer+apadrlbl
00C353  2  A9 09                LDA     #ascprmct       ;effective input count
00C355  2  4C 3F C1             JMP     moncea          ;reenter input loop
00C358  2               ;
00C358  2               ;
00C358  2               ;	process assembly error...
00C358  2               ;
00C358  2               monasc10:
00C358  2  20 89 C7             JSR     dpyerr          ;indicate error &...
00C35B  2  80 C6                BRA     monasc09        ;prompt w/same assembly address
00C35D  2               ;
00C35D  2               ;================================================================================
00C35D  2               ;
00C35D  2               ;mondsc: DISASSEMBLE CODE
00C35D  2               ;
00C35D  2               ;	-----------------------------
00C35D  2               ;	syntax: D [<addr1> [<addr2>]]
00C35D  2               ;	-----------------------------
00C35D  2               ;
00C35D  2               mondsc:
00C35D  2  B0 11                BCS     _0100010        ;no parameters
00C35F  2               ;
00C35F  2  64 4C                STZ     flimflag        ;reset to 8 bit mode
00C361  2  20 7B CA             JSR     facasize        ;check starting...
00C364  2  C9 04                CMP     #s_dword        ;address
00C366  2  B0 46                BCS     _0100050        ;out of range - error
00C368  2               ;
00C368  2  20 5D CA             JSR     facaddra        ;copy starting address
00C36B  2  20 8B CA             JSR     getparm         ;get ending address
00C36E  2  90 17                BCC     _0100020        ;gotten
00C370  2               ;
00C370  2               _0100010:
00C370  2  20 60 C9             JSR     clrfaca         ;clear accumulator
00C373  2  C2 20                SLONGA
00C375  2  18                   CLC
00C376  2  A5 1F                LDA     addra           ;starting address
00C378  2  69 15 00             ADCW    n_dbytes        ;default bytes
00C37B  2  85 25                STA     faca            ;effective ending address
00C37D  2  E2 20                SHORTA
00C37F  2  A5 21                LDA     addra+s_word    ;starting bank
00C381  2  69 00                ADC     #0
00C383  2  85 27                STA     faca+s_word     ;effective ending bank
00C385  2  B0 27                BCS     _0100050        ;end address > $FFFFFF
00C387  2               ;
00C387  2               _0100020:
00C387  2  20 7B CA             JSR     facasize        ;check ending...
00C38A  2  C9 04                CMP     #s_dword        ;address
00C38C  2  B0 20                BCS     _0100050        ;out of range - error
00C38E  2               ;
00C38E  2  20 67 CA             JSR     facaddrb        ;set ending address
00C391  2  20 8B CA             JSR     getparm         ;check for excess input
00C394  2  90 18                BCC     _0100050        ;present - error
00C396  2               ;
00C396  2  20 CC C9             JSR     calccnt         ;calculate bytes
00C399  2  90 13                BCC     _0100050        ;end < start
00C39B  2               ;
00C39B  2               _0100030:
00C39B  2  20 4F CC             JSR     teststop        ;test for display stop
00C39E  2  B0 0B                BCS     _0100040        ;stopped
00C3A0  2               ;
00C3A0  2  20 C7 C7             JSR     newline         ;next line
00C3A3  2  20 43 C6             JSR     dpycod          ;disassemble & display
00C3A6  2  20 13 CA             JSR     decdcnt         ;decrement byte count
00C3A9  2  90 F0                BCC     _0100030        ;not done
00C3AB  2               ;
00C3AB  2               _0100040:
00C3AB  2  4C 3B C1             JMP     monce           ;back to main loop
00C3AE  2               ;
00C3AE  2               _0100050:
00C3AE  2  4C 7A C1             JMP     monerr          ;address range error
00C3B1  2               ;
00C3B1  2               ;================================================================================
00C3B1  2               ;
00C3B1  2               ;monjmp: EXECUTE CODE
00C3B1  2               ;
00C3B1  2               ;	-------------------------------------------------------------
00C3B1  2               ;	syntax: G [<dp>]
00C3B1  2               ;
00C3B1  2               ;	If no address is specified, the current values in the PB & PC
00C3B1  2               ;	shadow registers are used.
00C3B1  2               ;	-------------------------------------------------------------
00C3B1  2               ;
00C3B1  2               monjmp:
00C3B1  2  20 1E CB             JSR     setxaddr        ;set execution address
00C3B4  2  B0 29                BCS     monjmpab        ;out of range - error
00C3B6  2               ;
00C3B6  2  20 8B CA             JSR     getparm         ;check for excess input
00C3B9  2  90 24                BCC     monjmpab        ;too much input - error
00C3BB  2               ;
00C3BB  2  C2 20                SLONGA                  ;16 bit .A
00C3BD  2  A5 1A                LDA     reg_spx
00C3BF  2  1B                   TCS                     ;restore SP
00C3C0  2               ;
00C3C0  2               monjmpaa:
00C3C0  2  E2 20                SHORTA
00C3C2  2  A5 10                LDA     reg_pbx
00C3C4  2  48                   PHA                     ;restore PB
00C3C5  2  C2 20                SLONGA
00C3C7  2  A5 11                LDA     reg_pcx
00C3C9  2  48                   PHA                     ;restore PC
00C3CA  2  E2 20                SHORTA
00C3CC  2  A5 13                LDA     reg_srx
00C3CE  2  48                   PHA                     ;restore SR
00C3CF  2  A5 1E                LDA     reg_dbx
00C3D1  2  48                   PHA
00C3D2  2  AB                   PLB                     ;restore DB
00C3D3  2  C2 30                LONGR
00C3D5  2  A5 1C                LDA     reg_dpx
00C3D7  2  5B                   TCD                     ;restore DP
00C3D8  2  A5 14                LDA     reg_ax          ;restore .C
00C3DA  2  A6 16                LDX     reg_xx          ;restore .X
00C3DC  2  A4 18                LDY     reg_yx          ;restore .Y
00C3DE  2  40                   RTI                     ;execute code
00C3DF  2               ;
00C3DF  2               monjmpab:
00C3DF  2  4C 7A C1             JMP     monerr          ;error
00C3E2  2               ;
00C3E2  2               ;================================================================================
00C3E2  2               ;
00C3E2  2               ;monjsr: EXECUTE CODE AS SUBROUTINE
00C3E2  2               ;
00C3E2  2               ;	------------------------------------------------------------
00C3E2  2               ;	syntax: J [<dp>]
00C3E2  2               ;
00C3E2  2               ;	If no address is specified the current values in the PB & PC
00C3E2  2               ;	shadow registers are used.   An RTS at the end of the called
00C3E2  2               ;	subroutine will return control to the monitor  provided  the
00C3E2  2               ;	stack remains in balance.
00C3E2  2               ;	------------------------------------------------------------
00C3E2  2               ;
00C3E2  2               monjsr:
00C3E2  2  20 1E CB             JSR     setxaddr        ;set execution address
00C3E5  2  B0 F8                BCS     monjmpab        ;out of range - error
00C3E7  2               ;
00C3E7  2  20 8B CA             JSR     getparm         ;check for excess input
00C3EA  2  90 F3                BCC     monjmpab        ;too much input - error
00C3EC  2               ;
00C3EC  2  C2 20                SLONGA
00C3EE  2  A5 1A                LDA     reg_spx
00C3F0  2  1B                   TCS                     ;restore SP &...
00C3F1  2  20 C0 C3             JSR     monjmpaa        ;call subroutine
00C3F4  2  08                   PHP                     ;push SR
00C3F5  2  C2 30                LONGR
00C3F7  2  85 14                STA     reg_ax          ;save...
00C3F9  2  86 16                STX     reg_xx          ;register...
00C3FB  2  84 18                STY     reg_yx          ;returns
00C3FD  2  E2 10                SHORTX                  ;8 bit .X & .Y
00C3FF  2  FA                   PLX                     ;get & save...
00C400  2  86 13                STX     reg_srx         ;return SR
00C402  2  3B                   TSC                     ;get & save...
00C403  2  85 1A                STA     reg_spx         ;return SP
00C405  2  7B                   TDC                     ;get & save...
00C406  2  85 1C                STA     reg_dpx         ;DP pointer
00C408  2  E2 20                SHORTA                  ;8 bit .A
00C40A  2  4B                   PHK                     ;get &...
00C40B  2  68                   PLA                     ;save...
00C40C  2  85 10                STA     reg_pbx         ;return PB
00C40E  2  8B                   PHB                     ;get &...
00C40F  2  68                   PLA                     ;save...
00C410  2  85 1E                STA     reg_dbx         ;return DB
00C412  2  F4 B5 D0             PEA     mm_rts          ;"*RET"
00C415  2  4C D0 C0             JMP     moncom          ;return to monitor
00C418  2               ;
00C418  2               ;================================================================================
00C418  2               ;
00C418  2               ;monchm: CHANGE and/or DUMP MEMORY
00C418  2               ;
00C418  2               ;	--------------------------------------------
00C418  2               ;	syntax: > [<addr> <operand> [<operand>]...]
00C418  2               ;
00C418  2               ;	> <addr> without operands will dump 16 bytes
00C418  2               ;	of memory, starting at <addr>.
00C418  2               ;	--------------------------------------------
00C418  2               ;
00C418  2               monchm:
00C418  2  B0 23                BCS     _0110030        ;no address given - quit
00C41A  2               ;
00C41A  2  20 7B CA             JSR     facasize        ;size address
00C41D  2  C9 04                CMP     #s_dword
00C41F  2  B0 1F                BCS     _0110040        ;address out of range - error
00C421  2               ;
00C421  2  20 5D CA             JSR     facaddra        ;set starting address
00C424  2  20 8E CB             JSR     getpat          ;evaluate change pattern
00C427  2  90 04                BCC     _0110010        ;entered
00C429  2               ;
00C429  2  10 0C                BPL     _0110020        ;not entered
00C42B  2               ;
00C42B  2  80 13                BRA     _0110040        ;evaluation error
00C42D  2               ;
00C42D  2               _0110010:
00C42D  2  88                   DEY                     ;next byte
00C42E  2  30 07                BMI     _0110020        ;done
00C430  2               ;
00C430  2  B9 46 02             LDA     auxbuf,y        ;write pattern...
00C433  2  97 1F                STAILY  addra           ;to memory
00C435  2  80 F6                BRA     _0110010        ;next
00C437  2               ;
00C437  2               _0110020:
00C437  2  20 C7 C7             JSR     newline         ;next line
00C43A  2  20 55 C7             JSR     dpymem          ;regurgitate changes
00C43D  2               ;
00C43D  2               _0110030:
00C43D  2  4C 3B C1             JMP     monce           ;back to command loop
00C440  2               ;
00C440  2               _0110040:
00C440  2  4C 7A C1             JMP     monerr          ;goto error handler
00C443  2               ;
00C443  2               ;================================================================================
00C443  2               ;
00C443  2               ;moncmp: COMPARE MEMORY
00C443  2               ;
00C443  2               ;	-----------------------------
00C443  2               ;	syntax: C <start> <end> <ref>
00C443  2               ;	-----------------------------
00C443  2               ;
00C443  2               moncmp:
00C443  2  B0 26                BCS     _0120030        ;start not given - quit
00C445  2               ;
00C445  2  20 37 CA             JSR     enddest         ;get end & reference addresses
00C448  2  B0 24                BCS     _0120040        ;range or other error
00C44A  2               ;
00C44A  2  64 4A                STZ     xrtemp          ;column counter
00C44C  2               ;
00C44C  2               _0120010:
00C44C  2  20 4F CC             JSR     teststop        ;check for stop
00C44F  2  B0 1A                BCS     _0120030        ;abort
00C451  2               ;
00C451  2  A7 1F                LDAIL   addra           ;get from reference location
00C453  2  C7 39                CMPIL   operand         ;test against compare location
00C455  2  F0 03                BEQ     _0120020        ;match, don't display address
00C457  2               ;
00C457  2  20 2B C6             JSR     dpycaddr        ;display current location
00C45A  2               ;
00C45A  2               _0120020:
00C45A  2  20 B3 CA             JSR     nxtaddra        ;next reference location
00C45D  2  B0 0C                BCS     _0120030        ;done
00C45F  2               ;
00C45F  2  C2 20                SLONGA
00C461  2  E6 39                INC     operand         ;bump bits 0-15
00C463  2  E2 20                SHORTA
00C465  2  D0 E5                BNE     _0120010
00C467  2               ;
00C467  2  E6 3B                INC     operand+s_word  ;bump bits 16-23
00C469  2  80 E1                BRA     _0120010
00C46B  2               ;
00C46B  2               _0120030:
00C46B  2  4C 3B C1             JMP     monce           ;return to command exec
00C46E  2               ;
00C46E  2               _0120040:
00C46E  2  4C 7A C1             JMP     monerr          ;goto error handler
00C471  2               ;
00C471  2               ;================================================================================
00C471  2               ;
00C471  2               ;moncpy: COPY (transfer) MEMORY
00C471  2               ;
00C471  2               ;	--------------------------------
00C471  2               ;	syntax: T <start> <end> <target>
00C471  2               ;	--------------------------------
00C471  2               ;
00C471  2               moncpy:
00C471  2  B0 49                BCS     _0130040        ;start not given - quit
00C473  2               ;
00C473  2  20 37 CA             JSR     enddest         ;get end & target addresses
00C476  2  B0 47                BCS     _0130050        ;range or other error
00C478  2               ;
00C478  2  C2 20                SLONGA
00C47A  2  38                   SEC
00C47B  2  A5 22                LDA     addrb           ;ending address
00C47D  2  E5 1F                SBC     addra           ;starting address
00C47F  2  90 3E                BCC     _0130050        ;start > end - error
00C481  2               ;
00C481  2  85 2D                STA     facb            ;bytes to copy
00C483  2  E2 20                SHORTA
00C485  2  C2 10                LONGX
00C487  2  A5 3B                LDA     operand+s_word  ;target bank
00C489  2  A4 39                LDY     operand         ;target address
00C48B  2  C5 21                CMP     addra+s_word    ;source bank
00C48D  2  C2 20                SLONGA
00C48F  2  D0 1C                BNE     _0130020        ;can use forward copy
00C491  2               ;
00C491  2  C4 1F                CPY     addra           ;source address
00C493  2  90 18                BCC     _0130020        ;can use forward copy
00C495  2               ;
00C495  2  D0 02                BNE     _0130010        ;must use reverse copy
00C497  2               ;
00C497  2  80 26                BRA     _0130050        ;copy in place - error
00C499  2               ;
00C499  2               _0130010:
00C499  2  A5 2D                LDA     facb            ;get bytes to copy
00C49B  2  48                   PHA                     ;protect
00C49C  2  20 37 CC             JSR     lodbnk          ;load banks
00C49F  2  20 F4 C9             JSR     cprvsup         ;do reverse copy setup
00C4A2  2  68                   PLA                     ;get bytes to copy
00C4A3  2  AA                   TAX                     ;save a copy
00C4A4  2  18                   CLC
00C4A5  2  65 39                ADC     operand         ;change target to...
00C4A7  2  A8                   TAY                     ;target end
00C4A8  2  8A                   TXA                     ;recover bytes to copy
00C4A9  2  A6 22                LDX     addrb           ;source end
00C4AB  2  80 0C                BRA     _0130030
00C4AD  2               ;
00C4AD  2               _0130020:
00C4AD  2  A5 2D                LDA     facb            ;get bytes to copy
00C4AF  2  48                   PHA                     ;protect
00C4B0  2  20 37 CC             JSR     lodbnk          ;load banks
00C4B3  2  20 ED C9             JSR     cpfwsup         ;do forward copy setup
00C4B6  2  68                   PLA                     ;get bytes to copy
00C4B7  2  A6 1F                LDX     addra           ;source start
00C4B9  2               ;
00C4B9  2               _0130030:
00C4B9  2  4C 25 00             JMP     mcftwork        ;copy memory
00C4BC  2               ;
00C4BC  2               _0130040:
00C4BC  2  4C 3B C1             JMP     monce           ;back to executive
00C4BF  2               ;
00C4BF  2               _0130050:
00C4BF  2  4C 7A C1             JMP     monerr          ;error
00C4C2  2               ;
00C4C2  2               ;================================================================================
00C4C2  2               ;
00C4C2  2               ;mondmp: DISPLAY MEMORY RANGE
00C4C2  2               ;
00C4C2  2               ;	-----------------------------
00C4C2  2               ;	syntax: M [<addr1> [<addr2>]]
00C4C2  2               ;	-----------------------------
00C4C2  2               ;
00C4C2  2               mondmp:
00C4C2  2  B0 0F                BCS     _0140010        ;no parameters
00C4C4  2               ;
00C4C4  2  20 7B CA             JSR     facasize        ;check address...
00C4C7  2  C9 04                CMP     #s_dword        ;range
00C4C9  2  B0 46                BCS     _0140050        ;address out of range
00C4CB  2               ;
00C4CB  2  20 5D CA             JSR     facaddra        ;copy starting address
00C4CE  2  20 8B CA             JSR     getparm         ;get ending address
00C4D1  2  90 17                BCC     _0140020        ;gotten
00C4D3  2               ;
00C4D3  2               _0140010:
00C4D3  2  20 60 C9             JSR     clrfaca         ;clear accumulator
00C4D6  2  C2 20                SLONGA
00C4D8  2  18                   CLC
00C4D9  2  A5 1F                LDA     addra           ;starting address
00C4DB  2  69 FF 00             ADCW    n_mbytes        ;default bytes
00C4DE  2  85 25                STA     faca            ;effective ending address
00C4E0  2  E2 20                SHORTA
00C4E2  2  A5 21                LDA     addra+s_word    ;starting bank
00C4E4  2  69 00                ADC     #0
00C4E6  2  85 27                STA     faca+s_word     ;effective ending bank
00C4E8  2  B0 27                BCS     _0140050        ;end address > $FFFFFF
00C4EA  2               ;
00C4EA  2               _0140020:
00C4EA  2  20 7B CA             JSR     facasize        ;check ending address...
00C4ED  2  C9 04                CMP     #s_dword        ;range
00C4EF  2  B0 20                BCS     _0140050        ;out of range - error
00C4F1  2               ;
00C4F1  2  20 67 CA             JSR     facaddrb        ;copy ending address
00C4F4  2  20 8B CA             JSR     getparm         ;check for excess input
00C4F7  2  90 18                BCC     _0140050        ;error
00C4F9  2               ;
00C4F9  2  20 CC C9             JSR     calccnt         ;calculate bytes to dump
00C4FC  2  90 13                BCC     _0140050        ;end < start
00C4FE  2               ;
00C4FE  2               _0140030:
00C4FE  2  20 4F CC             JSR     teststop        ;test for display stop
00C501  2  B0 0B                BCS     _0140040        ;stopped
00C503  2               ;
00C503  2  20 C7 C7             JSR     newline         ;next line
00C506  2  20 55 C7             JSR     dpymem          ;display
00C509  2  20 13 CA             JSR     decdcnt         ;decrement byte count
00C50C  2  90 F0                BCC     _0140030        ;not done
00C50E  2               ;
00C50E  2               _0140040:
00C50E  2  4C 3B C1             JMP     monce           ;back to main loop
00C511  2               ;
00C511  2               _0140050:
00C511  2  4C 7A C1             JMP     monerr          ;address range error
00C514  2               ;
00C514  2               ;================================================================================
00C514  2               ;
00C514  2               ;monfil: FILL MEMORY
00C514  2               ;
00C514  2               ;	-----------------------------------------
00C514  2               ;	syntax: F <start> <end> <fill>
00C514  2               ;
00C514  2               ;	<start> & <end> must be in the same bank.
00C514  2               ;	-----------------------------------------
00C514  2               ;
00C514  2               monfil:
00C514  2  B0 5E                BCS     _0150010        ;start not given - quit
00C516  2               ;
00C516  2  20 7B CA             JSR     facasize        ;check size
00C519  2  C9 04                CMP     #s_dword
00C51B  2  B0 5A                BCS     _0150020        ;out of range - error...
00C51D  2               ;
00C51D  2  20 5D CA             JSR     facaddra        ;store start
00C520  2  20 8B CA             JSR     getparm         ;evaluate end
00C523  2  B0 52                BCS     _0150020        ;not entered - error
00C525  2               ;
00C525  2  20 7B CA             JSR     facasize        ;check size
00C528  2  C9 04                CMP     #s_dword
00C52A  2  B0 4B                BCS     _0150020        ;out of range - error
00C52C  2               ;
00C52C  2  A5 27                LDA     faca+s_word     ;end bank
00C52E  2  C5 21                CMP     addra+s_word    ;start bank
00C530  2  D0 45                BNE     _0150020        ;not same - error
00C532  2               ;
00C532  2  20 67 CA             JSR     facaddrb        ;store <end>
00C535  2  C2 20                SLONGA
00C537  2  38                   SEC
00C538  2  A5 22                LDA     addrb           ;ending address
00C53A  2  E5 1F                SBC     addra           ;starting address
00C53C  2  90 39                BCC     _0150020        ;start > end - error
00C53E  2               ;
00C53E  2  85 2D                STA     facb            ;bytes to copy
00C540  2  E2 20                SHORTA
00C542  2  20 8B CA             JSR     getparm         ;evaluate <fill>
00C545  2  B0 30                BCS     _0150020        ;not entered - error
00C547  2               ;
00C547  2  20 7B CA             JSR     facasize        ;<fill> should be...
00C54A  2  C9 02                CMP     #s_word         ;8 bits
00C54C  2  B0 29                BCS     _0150020        ;it isn't - error
00C54E  2               ;
00C54E  2  20 71 CA             JSR     facaoper        ;store <fill>
00C551  2  20 8B CA             JSR     getparm         ;should be no more parameters
00C554  2  90 21                BCC     _0150020        ;there are - error
00C556  2               ;
00C556  2  A5 39                LDA     operand         ;<fill>
00C558  2  87 1F                STAIL   addra           ;fill 1st location
00C55A  2  C2 30                LONGR                   ;16 bit operations
00C55C  2  A5 2D                LDA     facb            ;get byte count
00C55E  2  F0 14                BEQ     _0150010        ;only 1 location - finished
00C560  2               ;
00C560  2  3A                   DEA                     ;zero align &...
00C561  2  48                   PHA                     ;protect
00C562  2  E2 20                SHORTA
00C564  2  A5 21                LDA     addra+s_word    ;start bank
00C566  2  EB                   XBA
00C567  2  A5 24                LDA     addrb+s_word    ;end bank
00C569  2  20 ED C9             JSR     cpfwsup         ;do forward copy setup
00C56C  2  68                   PLA                     ;recover fill count
00C56D  2  A6 1F                LDX     addra           ;fill-from starting location
00C56F  2  9B                   TXY
00C570  2  C8                   INY                     ;fill-to starting location
00C571  2  4C 25 00             JMP     mcftwork        ;fill memory
00C574  2               ;
00C574  2               _0150010:
00C574  2  4C 3B C1             JMP     monce           ;goto command executive
00C577  2               ;
00C577  2               _0150020:
00C577  2  4C 7A C1             JMP     monerr          ;goto error handler
00C57A  2               ;
00C57A  2               ;================================================================================
00C57A  2               ;
00C57A  2               ;monhnt: SEARCH (hunt) MEMORY
00C57A  2               ;
00C57A  2               ;	-----------------------------------
00C57A  2               ;	syntax: H <addr1> <addr2> <pattern>
00C57A  2               ;	-----------------------------------
00C57A  2               ;
00C57A  2               monhnt:
00C57A  2  B0 40                BCS     _0160050        ;no start address
00C57C  2               ;
00C57C  2  20 7B CA             JSR     facasize        ;size starting address
00C57F  2  C9 04                CMP     #s_dword
00C581  2  B0 3C                BCS     _0160060        ;address out of range - error
00C583  2               ;
00C583  2  20 5D CA             JSR     facaddra        ;store starting address
00C586  2  20 8B CA             JSR     getparm         ;evaluate ending address
00C589  2  B0 34                BCS     _0160060        ;no address - error
00C58B  2               ;
00C58B  2  20 7B CA             JSR     facasize        ;size ending address
00C58E  2  C9 04                CMP     #s_dword
00C590  2  B0 2D                BCS     _0160060        ;address out of range - error
00C592  2               ;
00C592  2  20 67 CA             JSR     facaddrb        ;store ending address
00C595  2  20 CC C9             JSR     calccnt         ;calculate byte range
00C598  2  90 25                BCC     _0160060        ;end < start
00C59A  2               ;
00C59A  2  20 8E CB             JSR     getpat          ;evaluate search pattern
00C59D  2  B0 20                BCS     _0160060        ;error
00C59F  2               ;
00C59F  2  64 4A                STZ     xrtemp          ;clear column counter
00C5A1  2               ;
00C5A1  2               _0160010:
00C5A1  2  20 4F CC             JSR     teststop        ;check for stop
00C5A4  2  B0 16                BCS     _0160050        ;abort
00C5A6  2               ;
00C5A6  2  A4 3C                LDY     auxbufix        ;pattern index
00C5A8  2               ;
00C5A8  2               _0160020:
00C5A8  2  88                   DEY
00C5A9  2  30 09                BMI     _0160030        ;pattern match
00C5AB  2               ;
00C5AB  2  B7 1F                LDAILY  addra           ;get from memory
00C5AD  2  D9 46 02             CMP     auxbuf,y        ;test against pattern
00C5B0  2  D0 05                BNE     _0160040        ;mismatch, next location
00C5B2  2               ;
00C5B2  2  F0 F4                BEQ     _0160020        ;match, keep testing
00C5B4  2               ;
00C5B4  2               _0160030:
00C5B4  2  20 2B C6             JSR     dpycaddr        ;display current location
00C5B7  2               ;
00C5B7  2               _0160040:
00C5B7  2  20 B3 CA             JSR     nxtaddra        ;next location
00C5BA  2  90 E5                BCC     _0160010        ;not done
00C5BC  2               ;
00C5BC  2               _0160050:
00C5BC  2  4C 3B C1             JMP     monce           ;back to executive
00C5BF  2               ;
00C5BF  2               _0160060:
00C5BF  2  4C 7A C1             JMP     monerr          ;goto error handler
00C5C2  2               ;
00C5C2  2               ;================================================================================
00C5C2  2               ;
00C5C2  2               ;monenv: CONVERT NUMERIC VALUE
00C5C2  2               ;
00C5C2  2               ;	----------------------
00C5C2  2               ;	syntax: <radix><value>
00C5C2  2               ;	----------------------
00C5C2  2               ;
00C5C2  2               monenv:
00C5C2  2  20 89 CA             JSR     getparmr        ;reread & evaluate parameter
00C5C5  2  B0 26                BCS     _0170020        ;none entered
00C5C7  2               ;
00C5C7  2  A2 00                LDX     #0              ;radix index
00C5C9  2  A0 04                LDY     #n_radix        ;number of radices
00C5CB  2               ;
00C5CB  2               _0170010:
00C5CB  2  5A                   PHY                     ;save counter
00C5CC  2  DA                   PHX                     ;save radix index
00C5CD  2  20 C7 C7             JSR     newline         ;next line &...
00C5D0  2  20 4F C7             JSR     clearlin        ;clear it
00C5D3  2  A9 20                LDA     #a_blank
00C5D5  2  A2 04                LDX     #halftab
00C5D7  2  20 BC C7             JSR     multspc         ;indent 1/2 tab
00C5DA  2  FA                   PLX                     ;get radix index but...
00C5DB  2  DA                   PHX                     ;put it back
00C5DC  2  BD 32 CD             LDA     radxtab,x       ;get radix
00C5DF  2  20 B9 C8             JSR     binasc          ;convert to ASCII
00C5E2  2  5A                   PHY                     ;string address MSB
00C5E3  2  DA                   PHX                     ;string address LSB
00C5E4  2  20 DC C7             JSR     sprint          ;print
00C5E7  2  FA                   PLX                     ;get index again
00C5E8  2  7A                   PLY                     ;get counter
00C5E9  2  E8                   INX
00C5EA  2  88                   DEY                     ;all radices handled?
00C5EB  2  D0 DE                BNE     _0170010        ;no
00C5ED  2               
00C5ED  2               _0170020:
00C5ED  2  4C 3B C1             JMP     monce           ;back to command exec
00C5F0  2               ;
00C5F0  2               ;================================================================================
00C5F0  2               ;
00C5F0  2               ;monchr: CHANGE REGISTERS
00C5F0  2               ;
00C5F0  2               ;	------------------------------------------------------
00C5F0  2               ;	syntax: ; [PB [PC [.S [.C [.X [.Y [SP [DP [DB]]]]]]]]]
00C5F0  2               ;
00C5F0  2               ;	; with no parameters is the same as the R command.
00C5F0  2               ;	------------------------------------------------------
00C5F0  2               ;
00C5F0  2               monchr:
00C5F0  2  B0 33                BCS     _0570040        ;dump registers & quit
00C5F2  2               ;
00C5F2  2  A0 00                LDY     #0              ;register counter
00C5F4  2  84 33                STY     facc            ;initialize register index
00C5F6  2               ;
00C5F6  2               _0570010:
00C5F6  2  20 7B CA             JSR     facasize        ;get parameter size
00C5F9  2  D9 36 CD             CMP     rcvltab,y       ;check against size table
00C5FC  2  B0 2A                BCS     _0570050        ;out of range
00C5FE  2               ;
00C5FE  2  B9 36 CD             LDA     rcvltab,y       ;determine number of bytes...
00C601  2  C9 03                CMP     #s_word+1       ;to store
00C603  2  66 34                ROR     facc+s_byte     ;condition flag
00C605  2  10 02                BPL     _0570020        ;8 bit register size
00C607  2               ;
00C607  2  C2 20                SLONGA                  ;16 bit register size
00C609  2               ;
00C609  2               _0570020:
00C609  2  A6 33                LDX     facc            ;get register index
00C60B  2  A5 25                LDA     faca            ;get parm
00C60D  2  95 10                STA     reg_pbx,x       ;put in shadow storage
00C60F  2  E2 20                SHORTA
00C611  2  06 34                ASL     facc+s_byte     ;mode flag to carry
00C613  2  8A                   TXA                     ;register index
00C614  2  69 01                ADC     #s_byte         ;at least 1 byte stored
00C616  2  85 33                STA     facc            ;save new index
00C618  2  20 8B CA             JSR     getparm         ;get a parameter
00C61B  2  B0 08                BCS     _0570040        ;EOI
00C61D  2               ;
00C61D  2  C8                   INY                     ;bump register count
00C61E  2  C0 09                CPY     #n_regchv       ;all registers processed?
00C620  2  D0 D4                BNE     _0570010        ;no, keep going
00C622  2               ;
00C622  2               _0570030:
00C622  2  20 D3 C7             JSR     alert           ;excessive input
00C625  2               ;
00C625  2               _0570040:
00C625  2  4C DD C0             JMP     monreg          ;display changes
00C628  2               ;
00C628  2               _0570050:
00C628  2  4C 7A C1             JMP     monerr          ;goto error handler
00C62B  2               ;
00C62B  2               ;================================================================================
00C62B  2               ;
00C62B  2               ;monxit: EXIT TO OPERATING ENVIRONMENT
00C62B  2               ;
00C62B  2               ;	---------
00C62B  2               ;	syntax: X
00C62B  2               ;	---------
00C62B  2               ;
00C62B  2               ;monxit   bcc _0180020          ;no parameters allowed
00C62B  2               ;
00C62B  2               ;         slonga
00C62B  2               ;        lda vecbrki           ;BRK indirect vector
00C62B  2               ;         cmpw monbrk           ;we intercept it?
00C62B  2               ;         bne _0180010          ;no, don't change it
00C62B  2               ;
00C62B  2               ;         lda vecbrkia          ;old vector
00C62B  2               ;         sta vecbrki           ;restore it
00C62B  2               ;         stz vecbrkia          ;invalidate old vector
00C62B  2               ;
00C62B  2               ;_0180010 shortr
00C62B  2               ;         jml vecexit           ;long jump to exit
00C62B  2               ;
00C62B  2               ;_0180020 jmp monerr            ;goto error handler
00C62B  2               ;
00C62B  2               ; * * * * * * * * * * * * * * * * * * * * * * * *
00C62B  2               ; * * * * * * * * * * * * * * * * * * * * * * * *
00C62B  2               ; * *                                         * *
00C62B  2               ; * * S T A R T   o f   S U B R O U T I N E S * *
00C62B  2               ; * *                                         * *
00C62B  2               ; * * * * * * * * * * * * * * * * * * * * * * * *
00C62B  2               ; * * * * * * * * * * * * * * * * * * * * * * * *
00C62B  2               ;
00C62B  2               ;dpycaddr: DISPLAY CURRENT ADDRESS IN COLUMNS
00C62B  2               ;
00C62B  2               dpycaddr:
00C62B  2  A6 4A                LDX     xrtemp          ;column count
00C62D  2  D0 05                BNE     _0190010        ;not at right side
00C62F  2               ;
00C62F  2  20 C7 C7             JSR     newline         ;next row
00C632  2  A2 0A                LDX     #n_hccols       ;max columns
00C634  2               ;
00C634  2               _0190010:
00C634  2  E0 0A                CPX     #n_hccols       ;max columns
00C636  2  F0 05                BEQ     _0190020        ;at left margin
00C638  2               ;
00C638  2  A9 09                LDA     #a_ht
00C63A  2  20 71 FF             JSR     putcha          ;tab a column
00C63D  2               ;
00C63D  2               _0190020:
00C63D  2  CA                   DEX                     ;one less column
00C63E  2  86 4A                STX     xrtemp          ;save column counter
00C640  2  4C 95 C7             JMP     prntladr        ;print reference address
00C643  2               ;
00C643  2               ;================================================================================
00C643  2               ;
00C643  2               ;dpycod: DISASSEMBLE & DISPLAY CODE
00C643  2               ;
00C643  2               ;	------------------------------------------------------------------------
00C643  2               ;	This function disassembles & displays the machine code at  the  location
00C643  2               ;	pointed to by ADDRA.  Upon return, ADDRA will point to the opcode of the
00C643  2               ;	next instruction.   The entry point at DPYCODAA  should be called with a
00C643  2               ;	disassembly prefix character loaded in .A.   If entered  at  DPYCOD, the
00C643  2               ;	default character will be display at the beginning of each  disassembled
00C643  2               ;	instruction.
00C643  2               ;
00C643  2               ;	The disassembly of immediate mode instructions that can take an 8 or  16
00C643  2               ;	bit operand is affected by the bit pattern that is  stored  in  FLIMFLAG
00C643  2               ;	upon entry to this function:
00C643  2               ;
00C643  2               ;	    FLIMFLAG: xx000000
00C643  2               ;	              ||
00C643  2               ;	              |+---------> 0:  8 bit .X or .Y operand
00C643  2               ;	              |            1: 16 bit .X or .Y operand
00C643  2               ;	              +----------> 0:  8 bit .A or BIT # operand
00C643  2               ;	                           1: 16 bit .A or BIT # operand
00C643  2               ;
00C643  2               ;	FLIMFLAG is conditioned according to the operand of  the  most  recently
00C643  2               ;	disassembled REP or SEP instruction.   Hence repetitive  calls  to  this
00C643  2               ;	subroutine will usually result in the correct disassembly of 16 bit imm-
00C643  2               ;	ediate mode instructions.
00C643  2               ;	------------------------------------------------------------------------
00C643  2               ;
00C643  2               dpycod:
00C643  2  A9 2E                LDA     #disprfx        ;default prefix
00C645  2               ;
00C645  2               ;
00C645  2               ;	alternate prefix display entry point...
00C645  2               ;
00C645  2               dpycodaa:
00C645  2  20 71 FF             JSR     putcha          ;print prefix
00C648  2  20 D7 C7             JSR     printspc        ;space
00C64B  2  20 95 C7             JSR     prntladr        ;print long address
00C64E  2  20 D7 C7             JSR     printspc        ;space to opcode field
00C651  2  20 C8 CA             JSR     getbyte         ;get opcode
00C654  2  85 48                STA     opcode          ;save &...
00C656  2  20 CC C7             JSR     printbyt        ;display as hex
00C659  2               ;
00C659  2               ;
00C659  2               ;	decode menmonic & addressing info...
00C659  2               ;
00C659  2  A6 48                LDX     opcode          ;current mnemonic
00C65B  2  BD F7 CD             LDA     mnetabix,x      ;get mnemonic index
00C65E  2  0A                   ASL                     ;double for...
00C65F  2  A8                   TAY                     ;mnemonic table offset
00C660  2  C2 20                SLONGA                  ;16 bit load
00C662  2  B9 3F CD             LDA     mnetab,y        ;copy encoded mnemonic to...
00C665  2  85 46                STA     mnepck          ;working storage
00C667  2  E2 20                SHORTA                  ;back to 8 bits
00C669  2  20 E9 CA             JSR     instdata        ;extract mode & size data
00C66C  2  85 4F                STA     vopsflag        ;save mode flags
00C66E  2  84 41                STY     admodidx        ;save mode index
00C670  2  0A                   ASL                     ;variable immediate instruction?
00C671  2  90 1F                BCC     dpycod01        ;no, effective operand size in .X
00C673  2               ;
00C673  2               ;
00C673  2               ;	determine immediate mode operand size...
00C673  2               ;
00C673  2  A5 48                LDA     opcode          ;current opcode
00C675  2  24 4C                BIT     flimflag        ;operand display mode
00C677  2  10 08                BPL     _0200010        ;8 bit .A & BIT immediate mode
00C679  2               ;
00C679  2  29 1F                AND     #aimmaska       ;determine if...
00C67B  2  C9 09                CMP     #aimmaskb       ;.A or BIT immediate
00C67D  2  F0 10                BEQ     _0200030        ;display 16 bit operand
00C67F  2               ;
00C67F  2  A5 48                LDA     opcode          ;not .A or BIT immediate
00C681  2               ;
00C681  2               _0200010:
00C681  2  50 0F                BVC     dpycod01        ;8 bit .X/.Y immediate mode
00C683  2               ;
00C683  2  A0 03                LDY     #n_vopidx-1     ;opcodes to test
00C685  2               ;
00C685  2               _0200020:
00C685  2  D9 F7 CF             CMP     vopidx,y        ;looking for LDX #, CPY #, etc.
00C688  2  F0 07                BEQ     _0200040        ;disassemble a 16 bit operand
00C68A  2               ;
00C68A  2  88                   DEY
00C68B  2  10 F8                BPL     _0200020        ;keep trying
00C68D  2               ;
00C68D  2  80 03                BRA     dpycod01        ;not .X or .Y immediate
00C68F  2               ;
00C68F  2               _0200030:
00C68F  2  A5 48                LDA     opcode          ;reload
00C691  2               ;
00C691  2               _0200040:
00C691  2  E8                   INX                     ;16 bit operand
00C692  2               ;
00C692  2               ;
00C692  2               ;	get & display operand bytes...
00C692  2               ;
00C692  2               dpycod01:
00C692  2  86 4D                STX     iopsize         ;operand size...
00C694  2  E8                   INX                     ;plus opcode becomes...
00C695  2  86 44                STX     instsize        ;instruction size
00C697  2  86 42                STX     charcnt         ;total bytes to process
00C699  2  A9 0B                LDA     #n_opcols+2     ;total operand columns plus WS
00C69B  2  85 4A                STA     xrtemp          ;initialize counter
00C69D  2  20 E1 C9             JSR     clroper         ;clear operand
00C6A0  2  A4 4D                LDY     iopsize         ;operand size
00C6A2  2  F0 16                BEQ     _0210020        ;no operand
00C6A4  2               ;
00C6A4  2  A2 00                LDX     #0              ;operand index
00C6A6  2               ;
00C6A6  2               _0210010:
00C6A6  2  20 C8 CA             JSR     getbyte         ;get operand byte
00C6A9  2  95 39                STA     operand,x       ;save
00C6AB  2  DA                   PHX                     ;protect operand index
00C6AC  2  20 CC C7             JSR     printbyt        ;print operand byte
00C6AF  2  C6 4A                DEC     xrtemp          ;3 columns used, 2 for...
00C6B1  2  C6 4A                DEC     xrtemp          ;operand nybbles &...
00C6B3  2  C6 4A                DEC     xrtemp          ;1 for whitespace
00C6B5  2  FA                   PLX                     ;get operand index
00C6B6  2  E8                   INX                     ;bump it
00C6B7  2  88                   DEY
00C6B8  2  D0 EC                BNE     _0210010        ;next
00C6BA  2               ;
00C6BA  2               _0210020:
00C6BA  2  A6 4A                LDX     xrtemp          ;operand columns remaining
00C6BC  2  20 BC C7             JSR     multspc         ;space to mnemonic field
00C6BF  2               ;
00C6BF  2               ;
00C6BF  2               ;	display mnemonic...
00C6BF  2               ;
00C6BF  2  A0 03                LDY     #s_mnemon       ;size of ASCII mnemonic
00C6C1  2               ;
00C6C1  2               _0210030:
00C6C1  2  A9 00                LDA     #0              ;initialize char
00C6C3  2  A2 05                LDX     #n_shfenc       ;shifts to execute
00C6C5  2               ;
00C6C5  2               _0210040:
00C6C5  2  06 46                ASL     mnepck          ;shift encoded mnemonic
00C6C7  2  26 47                ROL     mnepck+s_byte
00C6C9  2  2A                   ROL
00C6CA  2  CA                   DEX
00C6CB  2  D0 F8                BNE     _0210040
00C6CD  2               ;
00C6CD  2  69 3F                ADC     #a_mnecvt       ;convert to ASCII &...
00C6CF  2  48                   PHA                     ;stash
00C6D0  2  88                   DEY
00C6D1  2  D0 EE                BNE     _0210030        ;continue with mnemonic
00C6D3  2               ;
00C6D3  2  A0 03                LDY     #s_mnemon
00C6D5  2               ;
00C6D5  2               _0210050:
00C6D5  2  68                   PLA                     ;get mnenmonic byte
00C6D6  2  20 71 FF             JSR     putcha          ;print it
00C6D9  2  88                   DEY
00C6DA  2  D0 F9                BNE     _0210050
00C6DC  2               ;
00C6DC  2               ;
00C6DC  2               ;	display operand...
00C6DC  2               ;
00C6DC  2  A5 4D                LDA     iopsize         ;operand size
00C6DE  2  F0 6F                BEQ     clearlin        ;zero, disassembly finished
00C6E0  2               ;
00C6E0  2  20 D7 C7             JSR     printspc        ;space to operand field
00C6E3  2  24 4F                BIT     vopsflag        ;check mode flags
00C6E5  2  50 08                BVC     dpycod02        ;not a branch
00C6E7  2               ;
00C6E7  2  20 FF CA             JSR     offtarg         ;compute branch target
00C6EA  2  A6 44                LDX     instsize        ;effective instruction size
00C6EC  2  CA                   DEX
00C6ED  2  86 4D                STX     iopsize         ;effective operand size
00C6EF  2               ;
00C6EF  2               dpycod02:
00C6EF  2  64 4F                STZ     vopsflag        ;clear
00C6F1  2  A5 41                LDA     admodidx        ;instruction addressing mode
00C6F3  2  C9 0B                CMP     #am_move        ;block move instruction?
00C6F5  2  D0 02                BNE     _0220010        ;no
00C6F7  2               ;
00C6F7  2  66 4F                ROR     vopsflag        ;yes
00C6F9  2               ;
00C6F9  2               _0220010:
00C6F9  2  0A                   ASL                     ;convert addressing mode to...
00C6FA  2  AA                   TAX                     ;symbology table index
00C6FB  2  C2 20                SLONGA                  ;do a 16 bit load
00C6FD  2  BD FB CF             LDA     ms_lutab,x      ;addressing symbol pointer
00C700  2  48                   PHA
00C701  2  E2 20                SHORTA                  ;back to 8 bit loads
00C703  2  A0 00                LDY     #0
00C705  2  B3 01                LDASI   1               ;get 1st char
00C707  2  C9 20                CMP     #a_blank
00C709  2  F0 03                BEQ     _0220020        ;no addresing mode preamble
00C70B  2               ;
00C70B  2  20 71 FF             JSR     putcha          ;print preamble
00C70E  2               ;
00C70E  2               _0220020:
00C70E  2  A9 24                LDA     #c_hex
00C710  2  20 71 FF             JSR     putcha          ;operand displayed as hex
00C713  2  A4 4D                LDY     iopsize         ;operand size = index
00C715  2               ;
00C715  2               _0220030:
00C715  2  88                   DEY
00C716  2  30 16                BMI     _0220040        ;done with operand
00C718  2               ;
00C718  2  B9 39 00             LDA     operand,y       ;get operand byte
00C71B  2  20 B2 C7             JSR     dpyhex          ;print operand byte
00C71E  2  24 4F                BIT     vopsflag        ;block move?
00C720  2  10 F3                BPL     _0220030        ;no
00C722  2               ;
00C722  2  64 4F                STZ     vopsflag        ;reset
00C724  2  5A                   PHY                     ;protect operand index
00C725  2  F4 34 D0             PEA     ms_move
00C728  2  20 DC C7             JSR     sprint          ;display MVN/MVP operand separator
00C72B  2  7A                   PLY                     ;recover operand index again
00C72C  2  80 E7                BRA     _0220030        ;continue
00C72E  2               ;
00C72E  2               _0220040:
00C72E  2  FA                   PLX                     ;symbology LSB
00C72F  2  7A                   PLY                     ;symbology MSB
00C730  2  E8                   INX                     ;move past preamble
00C731  2  D0 01                BNE     _0220050
00C733  2               ;
00C733  2  C8                   INY
00C734  2               ;
00C734  2               _0220050:
00C734  2  5A                   PHY
00C735  2  DA                   PHX
00C736  2  20 DC C7             JSR     sprint          ;print postamble, if any
00C739  2               ;
00C739  2               ;
00C739  2               ;	condition immediate mode display format...
00C739  2               ;
00C739  2               dpycod03:
00C739  2  A5 39                LDA     operand         ;operand LSB
00C73B  2  29 30                AND     #pfmxmask       ;isolate M & X bits
00C73D  2  0A                   ASL                     ;shift to match...
00C73E  2  0A                   ASL                     ;FLIMFLAG alignment
00C73F  2  A6 48                LDX     opcode          ;current instruction
00C741  2  E0 C2                CPX     #opc_rep        ;was it REP?
00C743  2  D0 04                BNE     _0230010        ;no
00C745  2               ;
00C745  2  04 4C                TSB     flimflag        ;set flag bits as required
00C747  2  80 06                BRA     clearlin
00C749  2               ;
00C749  2               _0230010:
00C749  2  E0 E2                CPX     #opc_sep        ;was it SEP?
00C74B  2  D0 02                BNE     clearlin        ;no, just exit
00C74D  2               ;
00C74D  2  14 4C                TRB     flimflag        ;clear flag bits as required
00C74F  2               ;
00C74F  2               ;================================================================================
00C74F  2               ;
00C74F  2               ;clearlin: CLEAR DISPLAY LINE
00C74F  2               ;
00C74F  2               clearlin:
00C74F  2  60                   RTS
00C750  2               ;
00C750  2               ;================================================================================
00C750  2               ;
00C750  2               ;dpyibuf: DISPLAY MONITOR INPUT BUFFER CONTENTS
00C750  2               ;
00C750  2               dpyibuf:
00C750  2  F4 00 02             PEA     ibuffer
00C753  2  80 37                BRA     dpyerraa
00C755  2               ;
00C755  2               ;================================================================================
00C755  2               ;
00C755  2               ;dpymem: DISPLAY MEMORY
00C755  2               ;
00C755  2               ;	------------------------------------------------------------
00C755  2               ;	This function displays 16 bytes of memory as hex values & as
00C755  2               ;	ASCII equivalents.  The starting address for the display is
00C755  2               ;	in ADDRA & is expected to be a 24 bit address.  Upon return,
00C755  2               ;	ADDRA will point to the start of the next 16 bytes.
00C755  2               ;	------------------------------------------------------------
00C755  2               ;
00C755  2               dpymem:
00C755  2  E2 30                SHORTR
00C757  2  64 42                STZ     charcnt         ;reset
00C759  2               ;         lda #memprfx
00C759  2               ;         jsr putcha            ;display prefix
00C759  2  20 95 C7             JSR     prntladr        ;print 24 bit address
00C75C  2  A2 00                LDX     #0              ;string buffer index
00C75E  2  A0 08                LDY     #n_dump         ;bytes per line
00C760  2               ;
00C760  2               _0240010:
00C760  2  20 C8 CA             JSR     getbyte         ;get from RAM, also...
00C763  2  48                   PHA                     ;save for decoding
00C764  2  DA                   PHX                     ;save string index
00C765  2  20 CC C7             JSR     printbyt        ;display as hex ASCII
00C768  2  E6 42                INC     charcnt         ;bytes displayed +1
00C76A  2  FA                   PLX                     ;recover string index &...
00C76B  2  68                   PLA                     ;byte
00C76C  2  C9 20                CMP     #a_blank        ;printable?
00C76E  2  90 04                BCC     _0240020        ;no
00C770  2               ;
00C770  2  C9 7F                CMP     #a_del
00C772  2  90 02                BCC     _0240030        ;is printable
00C774  2               ;
00C774  2               _0240020:
00C774  2  A9 2E                LDA     #memsubch       ;substitute character
00C776  2               ;
00C776  2               _0240030:
00C776  2  9D 00 02             STA     ibuffer,x       ;save char
00C779  2  E8                   INX                     ;bump index
00C77A  2  88                   DEY                     ;byte count -= 1
00C77B  2  D0 E3                BNE     _0240010        ;not done
00C77D  2               ;
00C77D  2  9E 00 02             STZ     ibuffer,x       ;terminate ASCII string
00C780  2  A9 3A                LDA     #memsepch
00C782  2  20 71 FF             JSR     putcha          ;separate ASCII from bytes
00C785  2  20 50 C7             JSR     dpyibuf         ;display ASCII equivalents
00C788  2  60                   RTS
00C789  2               ;
00C789  2               ;================================================================================
00C789  2               ;
00C789  2               ;dpyerr: DISPLAY ERROR SIGNAL
00C789  2               ;
00C789  2               dpyerr:
00C789  2  F4 75 D0             PEA     mm_err          ;"*ERR"
00C78C  2               ;
00C78C  2               dpyerraa:
00C78C  2  20 DC C7             JSR     sprint
00C78F  2  60                   RTS
00C790  2               ;
00C790  2               ;================================================================================
00C790  2               ;
00C790  2               ;gendbs: GENERATE DESTRUCTIVE BACKSPACE
00C790  2               ;
00C790  2               gendbs:
00C790  2  F4 45 D0             PEA     dc_bs           ;destructive backspace
00C793  2  80 F7                BRA     dpyerraa
00C795  2               ;
00C795  2               ;================================================================================
00C795  2               ;
00C795  2               ;prntladr: PRINT 24 BIT CURRENT ADDRESS
00C795  2               ;
00C795  2               prntladr:
00C795  2  08                   PHP                     ;protect register sizes
00C796  2  E2 20                SHORTA
00C798  2  A5 21                LDA     addra+s_word    ;get bank byte &...
00C79A  2  20 B2 C7             JSR     dpyhex          ;display it
00C79D  2  C2 20                SLONGA
00C79F  2  A5 1F                LDA     addra           ;get 16 bit address
00C7A1  2  28                   PLP                     ;restore register sizes
00C7A2  2               ;
00C7A2  2               ;================================================================================
00C7A2  2               ;
00C7A2  2               ;dpyhexw: DISPLAY BINARY WORD AS HEX ASCII
00C7A2  2               ;
00C7A2  2               ;	------------------------------------
00C7A2  2               ;	Preparatory Ops: .C: word to display
00C7A2  2               ;
00C7A2  2               ;	Returned Values: .C: used
00C7A2  2               ;	                 .X: used
00C7A2  2               ;	                 .Y: entry value
00C7A2  2               ;	------------------------------------
00C7A2  2               ;
00C7A2  2               dpyhexw:
00C7A2  2  08                   PHP                     ;save register sizes
00C7A3  2  C2 20                SLONGA
00C7A5  2  48                   PHA                     ;protect value
00C7A6  2  E2 20                SHORTA
00C7A8  2  EB                   XBA                     ;get MSB &...
00C7A9  2  20 B2 C7             JSR     dpyhex          ;display
00C7AC  2  C2 20                SLONGA
00C7AE  2  68                   PLA                     ;recover value
00C7AF  2  E2 20                SHORTA                  ;only LSB visible
00C7B1  2  28                   PLP                     ;reset register sizes
00C7B2  2               ;
00C7B2  2               ;================================================================================
00C7B2  2               ;
00C7B2  2               ;dpyhex: DISPLAY BINARY BYTE AS HEX ASCII
00C7B2  2               ;
00C7B2  2               ;	------------------------------------
00C7B2  2               ;	Preparatory Ops: .A: byte to display
00C7B2  2               ;
00C7B2  2               ;	Returned Values: .A: used
00C7B2  2               ;	                 .X: used
00C7B2  2               ;	                 .Y: entry value
00C7B2  2               ;	------------------------------------
00C7B2  2               ;
00C7B2  2               dpyhex:
00C7B2  2  20 4D C9             JSR     binhex          ;convert to hex ASCII
00C7B5  2  20 71 FF             JSR     putcha          ;print MSN
00C7B8  2  8A                   TXA
00C7B9  2  4C 71 FF             JMP     putcha          ;print LSN
00C7BC  2               ;
00C7BC  2               ;================================================================================
00C7BC  2               ;
00C7BC  2               ;multspc: PRINT MULTIPLE BLANKS
00C7BC  2               ;
00C7BC  2               ;	------------------------------------------------
00C7BC  2               ;	Preparatory Ops : .X: number of blanks to print
00C7BC  2               ;
00C7BC  2               ;	Register Returns: none
00C7BC  2               ;
00C7BC  2               ;	Calling Example : ldx #3
00C7BC  2               ;	                  jsr multspc    ;print 3 spaces
00C7BC  2               ;
00C7BC  2               ;	Notes: This sub will print 1 blank if .X=0.
00C7BC  2               ;	------------------------------------------------
00C7BC  2               ;
00C7BC  2               
00C7BC  2               multspc:
00C7BC  2  8A                   TXA
00C7BD  2  D0 01                BNE     _0250010        ;blank count specified
00C7BF  2               ;
00C7BF  2  E8                   INX                     ;default to 1 blank
00C7C0  2               ;
00C7C0  2               _0250010:
00C7C0  2  20 D7 C7             JSR     printspc
00C7C3  2  CA                   DEX
00C7C4  2  D0 FA                BNE     _0250010
00C7C6  2               ;
00C7C6  2  60                   RTS
00C7C7  2               
00C7C7  2               ;
00C7C7  2               ;================================================================================
00C7C7  2               ;
00C7C7  2               ;newline: PRINT NEWLINE (CRLF)
00C7C7  2               ;
00C7C7  2               newline:
00C7C7  2  F4 42 D0             PEA     dc_lf
00C7CA  2  80 C0                BRA     dpyerraa
00C7CC  2               ;
00C7CC  2               ;================================================================================
00C7CC  2               ;
00C7CC  2               ;printbyt: PRINT A BYTE WITH LEADING SPACE
00C7CC  2               ;
00C7CC  2               printbyt:
00C7CC  2  48                   PHA                     ;protect byte
00C7CD  2  20 D7 C7             JSR     printspc        ;print leading space
00C7D0  2  68                   PLA                     ;restore &...
00C7D1  2  80 DF                BRA     dpyhex          ;print byte
00C7D3  2               ;
00C7D3  2               ;================================================================================
00C7D3  2               ;
00C7D3  2               ;alert: ALERT USER w/TERMINAL BELL
00C7D3  2               ;
00C7D3  2               alert:
00C7D3  2  A9 07                LDA     #a_bel
00C7D5  2  80 02                BRA     printcmn
00C7D7  2               ;
00C7D7  2               ;================================================================================
00C7D7  2               ;
00C7D7  2               ;printspc: PRINT A SPACE
00C7D7  2               ;
00C7D7  2               printspc:
00C7D7  2  A9 20                LDA     #a_blank
00C7D9  2               ;
00C7D9  2               printcmn:
00C7D9  2  4C 71 FF             JMP     putcha
00C7DC  2               ;
00C7DC  2               ;================================================================================
00C7DC  2               ;
00C7DC  2               ;sprint: PRINT NULL-TERMINATED CHARACTER STRING
00C7DC  2               ;
00C7DC  2               ;	---------------------------------------------------------
00C7DC  2               ;	Preparatory Ops : SP+1: string address LSB
00C7DC  2               ;	                  SP+2: string address MSB
00C7DC  2               ;
00C7DC  2               ;	Register Returns: .A: used
00C7DC  2               ;	                  .B: entry value
00C7DC  2               ;	                  .X: used
00C7DC  2               ;	                  .Y: used
00C7DC  2               ;
00C7DC  2               ;	MPU Flags: NVmxDIZC
00C7DC  2               ;	           ||||||||
00C7DC  2               ;	           |||||||+---> 0: okay
00C7DC  2               ;	           |||||||      1: string too long (1)
00C7DC  2               ;	           ||||+++----> not defined
00C7DC  2               ;	           |||+-------> 1
00C7DC  2               ;	           ||+--------> 1
00C7DC  2               ;	           ++---------> not defined
00C7DC  2               ;
00C7DC  2               ;	Example: PER STRING
00C7DC  2               ;	         JSR SPRINT
00C7DC  2               ;	         BCS TOOLONG
00C7DC  2               ;
00C7DC  2               ;	Notes: 1) Maximum permissible string length including the
00C7DC  2               ;	          terminator is 32,767 bytes.
00C7DC  2               ;	       2) All registers are forced to 8 bits.
00C7DC  2               ;	       3) DO NOT JUMP OR BRANCH INTO THIS FUNCTION!
00C7DC  2               ;	---------------------------------------------------------
00C7DC  2               ;
00C7DC  2               sprint:
00C7DC  2  E2 20                SHORTA                  ;8 bit accumulator
00C7DE  2  C2 10                LONGX                   ;16 bit index
00C7E0  2               ;
00C7E0  2               ;---------------------------------------------------------
00C7E0  2               _retaddr        = 1             ;return address
00C7E0  2               _src            = _retaddr+s_word;string address stack offset
00C7E0  2               ;---------------------------------------------------------
00C7E0  2               ;
00C7E0  2  A0 00 00             LDYW    0
00C7E3  2  18                   CLC                     ;no initial error
00C7E4  2               ;
00C7E4  2               _0260010:
00C7E4  2  B3 03                LDASI   _src            ;get a byte
00C7E6  2  F0 07                BEQ     _0260020        ;done
00C7E8  2               ;
00C7E8  2  20 71 FF             JSR     putcha          ;write to console port
00C7EB  2  C8                   INY
00C7EC  2  10 F6                BPL     _0260010        ;next
00C7EE  2               ;
00C7EE  2  38                   SEC                     ;string too long
00C7EF  2               ;
00C7EF  2               _0260020:
00C7EF  2  FA                   PLX                     ;pull RTS address
00C7F0  2  7A                   PLY                     ;clear string pointer
00C7F1  2  DA                   PHX                     ;replace RTS
00C7F2  2  E2 10                SHORTX
00C7F4  2  60                   RTS
00C7F5  2               ;
00C7F5  2               ;================================================================================
00C7F5  2               ;
00C7F5  2               ;ascbin: CONVERT NULL-TERMINATED ASCII NUMBER STRING TO BINARY
00C7F5  2               ;
00C7F5  2               ;	---------------------------------------------------
00C7F5  2               ;	Preparatory Ops: ASCII number string in IBUFFER
00C7F5  2               ;
00C7F5  2               ;	Returned Values: FACA: converted parameter
00C7F5  2               ;	                   .A: used
00C7F5  2               ;	                   .X: used
00C7F5  2               ;	                   .Y: used
00C7F5  2               ;	                   .C: 1 = conversion error
00C7F5  2               ;	                   .Z: 1 = nothing to convert
00C7F5  2               ;
00C7F5  2               ;	Notes: 1) Conversion stops when a non-numeric char-
00C7F5  2               ;	          acter is encountered.
00C7F5  2               ;	       2) Radix symbols are as follows:
00C7F5  2               ;
00C7F5  2               ;	          % binary
00C7F5  2               ;	          % octal
00C7F5  2               ;	          + decimal
00C7F5  2               ;	          $ hexadecimal
00C7F5  2               ;
00C7F5  2               ;	          Hex is the default if no radix is speci-
00C7F5  2               ;	          fied in the 1st character of the string.
00C7F5  2               ;	---------------------------------------------------
00C7F5  2               ;
00C7F5  2               ascbin:
00C7F5  2  E2 30                SHORTR
00C7F7  2  20 60 C9             JSR     clrfaca         ;clear accumulator
00C7FA  2  64 42                STZ     charcnt         ;zero char count
00C7FC  2  64 40                STZ     radix           ;initialize
00C7FE  2               ;
00C7FE  2               ;
00C7FE  2               ;	process radix if present...
00C7FE  2               ;
00C7FE  2  20 DA CB             JSR     getcharw        ;get next non-WS char
00C801  2  D0 02                BNE     _0270010        ;got something
00C803  2               ;
00C803  2  18                   CLC                     ;no more input
00C804  2  60                   RTS
00C805  2               ;
00C805  2               _0270010:
00C805  2  A2 03                LDX     #n_radix-1      ;number of radices
00C807  2               ;
00C807  2               _0270020:
00C807  2  DD 32 CD             CMP     radxtab,x       ;recognized radix?
00C80A  2  F0 06                BEQ     _0270030        ;yes
00C80C  2               ;
00C80C  2  CA                   DEX
00C80D  2  10 F8                BPL     _0270020        ;try next
00C80F  2               ;
00C80F  2  C6 3D                DEC     ibufidx         ;reposition to previous char
00C811  2  E8                   INX                     ;not recognized, assume hex
00C812  2               ;
00C812  2               _0270030:
00C812  2  C9 2B                CMP     #c_dec          ;decimal radix?
00C814  2  D0 02                BNE     _0270040        ;not decimal
00C816  2               ;
00C816  2  66 40                ROR     radix           ;flag decimal conversion
00C818  2               ;
00C818  2               _0270040:
00C818  2  BD 1E CD             LDA     basetab,x       ;number bases table
00C81B  2  85 4E                STA     range           ;set valid numeral range
00C81D  2  BD 22 CD             LDA     bitsdtab,x      ;get bits per digit
00C820  2  85 3E                STA     bitsdig         ;store
00C822  2               ;
00C822  2               ;
00C822  2               ;	process numerals...
00C822  2               ;
00C822  2               ascbin01:
00C822  2  20 7C CB             JSR     getchar         ;get next char
00C825  2  D0 03                BNE     _TMP0001        ;not EOI
00C827  2  4C 9A C8             JMP     ascbin03        ;EOI
00C82A  2               ;
00C82A  2               _TMP0001:
00C82A  2  C9 20                CMP     #' '
00C82C  2  F0 6C                BEQ     ascbin03        ;blank - EOF
00C82E  2               ;
00C82E  2  C9 2C                CMP     #','
00C830  2  F0 68                BEQ     ascbin03        ;comma - EOF
00C832  2               ;
00C832  2  C9 09                CMP     #a_ht
00C834  2  F0 64                BEQ     ascbin03        ;tab - EOF
00C836  2               ;
00C836  2  20 BA C9             JSR     nybtobin        ;change to binary
00C839  2  B0 60                BCS     ascbin04        ;not a recognized numeral
00C83B  2               ;
00C83B  2  C5 4E                CMP     range           ;check range
00C83D  2  B0 5C                BCS     ascbin04        ;not valid for base
00C83F  2               ;
00C83F  2  85 3F                STA     numeral         ;save processed numeral
00C841  2  E6 42                INC     charcnt         ;bump numeral count
00C843  2  24 40                BIT     radix           ;working in base 10?
00C845  2  10 15                BPL     _1570030        ;no
00C847  2               ;
00C847  2               ;
00C847  2               ;	compute N*2 for decimal conversion...
00C847  2               ;
00C847  2  A2 00                LDX     #0              ;accumulator index
00C849  2  A0 02                LDY     #s_pfac/2       ;iterations
00C84B  2  C2 20                SLONGA
00C84D  2  18                   CLC
00C84E  2               ;
00C84E  2               _1570020:
00C84E  2  B5 25                LDA     faca,x          ;N
00C850  2  2A                   ROL                     ;N=N*2
00C851  2  95 2D                STA     facb,x
00C853  2  E8                   INX
00C854  2  E8                   INX
00C855  2  88                   DEY
00C856  2  D0 F6                BNE     _1570020
00C858  2               ;
00C858  2  B0 41                BCS     ascbin04        ;overflow - error
00C85A  2               ;
00C85A  2  E2 20                SHORTA
00C85C  2               ;
00C85C  2               ;
00C85C  2               ;	compute N*base for binary, octal or hex...
00C85C  2               ;	or N*8 for decimal...
00C85C  2               ;
00C85C  2               _1570030:
00C85C  2  A6 3E                LDX     bitsdig         ;bits per digit
00C85E  2  C2 20                SLONGA                  ;16 bit shifts
00C860  2               ;
00C860  2               _1570040:
00C860  2  06 25                ASL     faca
00C862  2  26 27                ROL     faca+s_word
00C864  2  B0 35                BCS     ascbin04        ;overflow - error
00C866  2               ;
00C866  2  CA                   DEX
00C867  2  D0 F7                BNE     _1570040        ;next shift
00C869  2               ;
00C869  2  E2 20                SHORTA                  ;back to 8 bits
00C86B  2  24 40                BIT     radix           ;check base
00C86D  2  10 13                BPL     ascbin02        ;not decimal
00C86F  2               ;
00C86F  2               ;
00C86F  2               ;	compute N*10 for decimal (N*8 + N*2)...
00C86F  2               ;
00C86F  2  A0 04                LDY     #s_pfac
00C871  2  C2 20                SLONGA
00C873  2               ;
00C873  2               _1570050:
00C873  2  B5 25                LDA     faca,x          ;N*8
00C875  2  75 2D                ADC     facb,x          ;N*2
00C877  2  95 25                STA     faca,x          ;now N*10
00C879  2  E8                   INX
00C87A  2  E8                   INX
00C87B  2  88                   DEY
00C87C  2  D0 F5                BNE     _1570050
00C87E  2               ;
00C87E  2  B0 1B                BCS     ascbin04        ;overflow - error
00C880  2               ;
00C880  2  E2 20                SHORTA
00C882  2               ;
00C882  2               ;
00C882  2               ;	add current numeral to partial result...
00C882  2               ;
00C882  2               ascbin02:
00C882  2  A5 25                LDA     faca            ;N
00C884  2  65 3F                ADC     numeral         ;N=N+D
00C886  2  85 25                STA     faca
00C888  2  A2 01                LDX     #1
00C88A  2  A0 03                LDY     #s_pfac-1
00C88C  2               ;
00C88C  2               _0280010:
00C88C  2  B5 25                LDA     faca,x
00C88E  2  69 00                ADC     #0              ;account for carry
00C890  2  95 25                STA     faca,x
00C892  2  E8                   INX
00C893  2  88                   DEY
00C894  2  D0 F6                BNE     _0280010
00C896  2               ;
00C896  2  90 08                BCC     _0280020        ;next if no overflow
00C898  2               ;
00C898  2  B0 01                BCS     ascbin04        ;overflow - error
00C89A  2               ;
00C89A  2               ;
00C89A  2               ;	finish up...
00C89A  2               ;
00C89A  2               ascbin03:
00C89A  2  18                   CLC                     ;no error
00C89B  2               ;
00C89B  2               ascbin04:
00C89B  2  E2 20                SHORTA                  ;reset if necessary
00C89D  2  A5 42                LDA     charcnt         ;load char count
00C89F  2  60                   RTS                     ;done
00C8A0  2               _0280020:
00C8A0  2  4C 22 C8             JMP     ascbin01        ;next if no overflow
00C8A3  2               ;
00C8A3  2               ;================================================================================
00C8A3  2               ;
00C8A3  2               ;bcdasc: CONVERT BCD DIGIT TO ASCII
00C8A3  2               ;
00C8A3  2               ;	---------------------------------------
00C8A3  2               ;	Preparatory Ops: .A: BCD digit, $00-$99
00C8A3  2               ;
00C8A3  2               ;	Returned Values: .A: ASCII MSD
00C8A3  2               ;	                 .X: ASCII LSD
00C8A3  2               ;	                 .Y: entry value
00C8A3  2               ;	---------------------------------------
00C8A3  2               ;
00C8A3  2               bcdasc:
00C8A3  2  20 AF C8             JSR     bintonyb        ;extract nybbles
00C8A6  2  48                   PHA                     ;save tens
00C8A7  2  8A                   TXA
00C8A8  2  09 30                ORA     #btoamask       ;change units to ASCII
00C8AA  2  AA                   TAX                     ;store
00C8AB  2  68                   PLA                     ;get tens
00C8AC  2  09 30                ORA     #btoamask       ;change to ASCII
00C8AE  2  60                   RTS
00C8AF  2               ;
00C8AF  2               ;================================================================================
00C8AF  2               ;
00C8AF  2               ;bintonyb: EXTRACT BINARY NYBBLES
00C8AF  2               ;
00C8AF  2               ;	---------------------------------
00C8AF  2               ;	Preparatory Ops: .A: binary value
00C8AF  2               ;
00C8AF  2               ;	Returned Values: .A: MSN
00C8AF  2               ;	                 .X: LSN
00C8AF  2               ;	                 .Y: entry value
00C8AF  2               ;	---------------------------------
00C8AF  2               ;
00C8AF  2               bintonyb:
00C8AF  2  48                   PHA                     ;save
00C8B0  2  29 0F                AND     #bcdumask       ;extract LSN
00C8B2  2  AA                   TAX                     ;save it
00C8B3  2  68                   PLA
00C8B4  2               ;         .rept s_bnybbl        ;extract MSN
00C8B4  2  4A                   LSR
00C8B5  2  4A                   LSR
00C8B6  2  4A                   LSR
00C8B7  2  4A                   LSR
00C8B8  2               ;         .endr
00C8B8  2  60                   RTS
00C8B9  2               ;
00C8B9  2               ;================================================================================
00C8B9  2               ;
00C8B9  2               ;binasc: CONVERT 32-BIT BINARY TO NULL-TERMINATED ASCII NUMBER STRING
00C8B9  2               ;
00C8B9  2               ;	------------------------------------------------------
00C8B9  2               ;	Preparatory Ops: FACA: 32-bit operand
00C8B9  2               ;	                   .A: radix character, w/bit 7 set to
00C8B9  2               ;	                       suppress radix symbol in the
00C8B9  2               ;	                       conversion string
00C8B9  2               ;
00C8B9  2               ;	Returned Values: ibuffer: conversion string
00C8B9  2               ;	                      .A: string length
00C8B9  2               ;	                      .X: string address LSB
00C8B9  2               ;	                      .Y: string address MSB
00C8B9  2               ;
00C8B9  2               ;	Execution Notes: ibufidx & instsize are overwritten.
00C8B9  2               ;	------------------------------------------------------
00C8B9  2               ;
00C8B9  2               binasc:
00C8B9  2  64 3D                STZ     ibufidx         ;initialize string index
00C8BB  2  64 44                STZ     instsize        ;clear format flag
00C8BD  2               ;
00C8BD  2               ;
00C8BD  2               ;	evaluate radix...
00C8BD  2               ;
00C8BD  2  0A                   ASL                     ;extract format flag &...
00C8BE  2  66 44                ROR     instsize        ;save it
00C8C0  2  4A                   LSR                     ;extract radix character
00C8C1  2  A2 03                LDX     #n_radix-1      ;total radices
00C8C3  2               ;
00C8C3  2               _0290010:
00C8C3  2  DD 32 CD             CMP     radxtab,x       ;recognized radix?
00C8C6  2  F0 04                BEQ     _0290020        ;yes
00C8C8  2               ;
00C8C8  2  CA                   DEX
00C8C9  2  10 F8                BPL     _0290010        ;try next
00C8CB  2               ;
00C8CB  2  E8                   INX                     ;assume hex
00C8CC  2               ;
00C8CC  2               _0290020:
00C8CC  2  86 40                STX     radix           ;save radix index for later
00C8CE  2  24 44                BIT     instsize
00C8D0  2  30 08                BMI     _0290030        ;no radix symbol wanted
00C8D2  2               ;
00C8D2  2  BD 32 CD             LDA     radxtab,x       ;radix table
00C8D5  2  8D 00 02             STA     ibuffer         ;prepend to string
00C8D8  2  E6 3D                INC     ibufidx         ;bump string index
00C8DA  2               ;
00C8DA  2               _0290030:
00C8DA  2  C9 2B                CMP     #c_dec          ;converting to decimal?
00C8DC  2  D0 07                BNE     _0290040        ;no
00C8DE  2               ;
00C8DE  2  20 72 C9             JSR     facabcd         ;convert operand to BCD
00C8E1  2  A9 00                LDA     #0
00C8E3  2  80 17                BRA     _0290070        ;skip binary stuff
00C8E5  2               ;
00C8E5  2               ;
00C8E5  2               ;	prepare for binary, octal or hex conversion...
00C8E5  2               ;
00C8E5  2               _0290040:
00C8E5  2  A2 00                LDX     #0              ;operand index
00C8E7  2  A0 05                LDY     #s_sfac-1       ;workspace index
00C8E9  2               ;
00C8E9  2               _0290050:
00C8E9  2  B5 25                LDA     faca,x          ;copy operand to...
00C8EB  2  99 2D 00             STA     facb,y          ;workspace in...
00C8EE  2  88                   DEY                     ;big-endian order
00C8EF  2  E8                   INX
00C8F0  2  E0 04                CPX     #s_pfac
00C8F2  2  D0 F5                BNE     _0290050
00C8F4  2               ;
00C8F4  2  A9 00                LDA     #0
00C8F6  2  BB                   TYX
00C8F7  2               ;
00C8F7  2               _0290060:
00C8F7  2  95 2D                STA     facb,x          ;pad workspace
00C8F9  2  CA                   DEX
00C8FA  2  10 FB                BPL     _0290060
00C8FC  2               ;
00C8FC  2               ;
00C8FC  2               ;	set up conversion parameters...
00C8FC  2               ;
00C8FC  2               _0290070:
00C8FC  2  85 33                STA     facc            ;initialize byte counter
00C8FE  2  A4 40                LDY     radix           ;radix index
00C900  2  B9 2E CD             LDA     numstab,y       ;numerals in string
00C903  2  85 34                STA     facc+s_byte     ;set remaining numeral count
00C905  2  B9 26 CD             LDA     bitsntab,y      ;bits per numeral
00C908  2  85 35                STA     facc+s_word     ;set
00C90A  2  B9 2A CD             LDA     lzsttab,y       ;leading zero threshold
00C90D  2  85 36                STA     facc+s_xword    ;set
00C90F  2               ;
00C90F  2               ;
00C90F  2               ;	generate conversion string...
00C90F  2               ;
00C90F  2               _0290080:
00C90F  2  A9 00                LDA     #0
00C911  2  A4 35                LDY     facc+s_word     ;bits per numeral
00C913  2               ;
00C913  2               _0290090:
00C913  2  A2 05                LDX     #s_sfac-1       ;workspace size
00C915  2  18                   CLC                     ;avoid starting carry
00C916  2               ;
00C916  2               _0290100:
00C916  2  36 2D                ROL     facb,x          ;shift out a bit...
00C918  2  CA                   DEX                     ;from the operand or...
00C919  2  10 FB                BPL     _0290100        ;BCD conversion result
00C91B  2               ;
00C91B  2  2A                   ROL                     ;bit to .A
00C91C  2  88                   DEY
00C91D  2  D0 F4                BNE     _0290090        ;more bits to grab
00C91F  2               ;
00C91F  2  A8                   TAY                     ;if numeral isn't zero...
00C920  2  D0 0A                BNE     _0290110        ;skip leading zero tests
00C922  2               ;
00C922  2  A6 34                LDX     facc+s_byte     ;remaining numerals
00C924  2  E4 36                CPX     facc+s_xword    ;leading zero threshold
00C926  2  90 04                BCC     _0290110        ;below it, must convert
00C928  2               ;
00C928  2  A6 33                LDX     facc            ;processed byte count
00C92A  2  F0 11                BEQ     _0290130        ;discard leading zero
00C92C  2               ;
00C92C  2               _0290110:
00C92C  2  C9 0A                CMP     #10             ;check range
00C92E  2  90 02                BCC     _0290120        ;is 0-9
00C930  2               ;
00C930  2  69 06                ADC     #a_hexdec       ;apply hex adjust
00C932  2               ;
00C932  2               _0290120:
00C932  2  69 30                ADC     #'0'            ;change to ASCII
00C934  2  A4 3D                LDY     ibufidx         ;string index
00C936  2  99 00 02             STA     ibuffer,y       ;save numeral in buffer
00C939  2  E6 3D                INC     ibufidx         ;next buffer position
00C93B  2  E6 33                INC     facc            ;bytes=bytes+1
00C93D  2               ;
00C93D  2               _0290130:
00C93D  2  C6 34                DEC     facc+s_byte     ;numerals=numerals-1
00C93F  2  D0 CE                BNE     _0290080        ;not done
00C941  2               ;
00C941  2               ;
00C941  2               ;	terminate string & exit...
00C941  2               ;
00C941  2  A6 3D                LDX     ibufidx         ;printable string length
00C943  2  9E 00 02             STZ     ibuffer,x       ;terminate string
00C946  2  8A                   TXA
00C947  2  A2 00                LDX     #<ibuffer       ;converted string
00C949  2  A0 02                LDY     #>ibuffer
00C94B  2  18                   CLC                     ;all okay
00C94C  2  60                   RTS
00C94D  2               ;
00C94D  2               ;================================================================================
00C94D  2               ;
00C94D  2               ;binhex: CONVERT BINARY BYTE TO HEX ASCII CHARS
00C94D  2               ;
00C94D  2               ;	--------------------------------------------
00C94D  2               ;	Preparatory Ops: .A: byte to convert
00C94D  2               ;
00C94D  2               ;	Returned Values: .A: MSN ASCII char
00C94D  2               ;	                 .X: LSN ASCII char
00C94D  2               ;	                 .Y: entry value
00C94D  2               ;	--------------------------------------------
00C94D  2               ;
00C94D  2               binhex:
00C94D  2  20 AF C8             JSR     bintonyb        ;generate binary values
00C950  2  48                   PHA                     ;save MSN
00C951  2  8A                   TXA
00C952  2  20 57 C9             JSR     _0300010        ;generate ASCII LSN
00C955  2  AA                   TAX                     ;save
00C956  2  68                   PLA                     ;get input
00C957  2               ;
00C957  2               ;
00C957  2               ;	convert nybble to hex ASCII equivalent...
00C957  2               ;
00C957  2               _0300010:
00C957  2  C9 0A                CMP     #10
00C959  2  90 02                BCC     _0300020        ;in decimal range
00C95B  2               ;
00C95B  2  69 66                ADC     #k_hex          ;hex compensate
00C95D  2               ;
00C95D  2               _0300020:
00C95D  2  49 30                EOR     #'0'            ;finalize nybble
00C95F  2  60                   RTS                     ;done
00C960  2               ;
00C960  2               ;================================================================================
00C960  2               ;
00C960  2               ;clrfaca: CLEAR FLOATING ACCUMULATOR A
00C960  2               ;
00C960  2               clrfaca:
00C960  2  08                   PHP
00C961  2  C2 20                SLONGA
00C963  2  64 25                STZ     faca
00C965  2  64 27                STZ     faca+s_word
00C967  2  28                   PLP
00C968  2  60                   RTS
00C969  2               ;
00C969  2               ;================================================================================
00C969  2               ;
00C969  2               ;clrfacb: CLEAR FLOATING ACCUMULATOR B
00C969  2               ;
00C969  2               clrfacb:
00C969  2  08                   PHP
00C96A  2  C2 20                SLONGA
00C96C  2  64 2D                STZ     facb
00C96E  2  64 2F                STZ     facb+s_word
00C970  2  28                   PLP
00C971  2  60                   RTS
00C972  2               ;
00C972  2               ;================================================================================
00C972  2               ;
00C972  2               ;facabcd: CONVERT FACA INTO BCD
00C972  2               ;
00C972  2               facabcd:
00C972  2  A2 03                LDX     #s_pfac-1       ;primary accumulator size -1
00C974  2               ;
00C974  2               _1300010:
00C974  2  B5 25                LDA     faca,x          ;value to be converted
00C976  2  48                   PHA                     ;preserve
00C977  2  CA                   DEX
00C978  2  10 FA                BPL     _1300010        ;next
00C97A  2               ;
00C97A  2  A2 05                LDX     #s_sfac-1       ;workspace size
00C97C  2               ;
00C97C  2               _1300020:
00C97C  2  74 2D                STZ     facb,x          ;clear final result
00C97E  2  74 33                STZ     facc,x          ;clear scratchpad
00C980  2  CA                   DEX
00C981  2  10 F9                BPL     _1300020
00C983  2               ;
00C983  2  E6 38                INC     facc+s_sfac-s_byte
00C985  2  F8                   SED                     ;select decimal mode
00C986  2  A0 1F                LDY     #m_bits-1       ;bits to convert -1
00C988  2               ;
00C988  2               _1300030:
00C988  2  A2 03                LDX     #s_pfac-1       ;operand size
00C98A  2  18                   CLC                     ;no carry at start
00C98B  2               ;
00C98B  2               _1300040:
00C98B  2  76 25                ROR     faca,x          ;grab LS bit in operand
00C98D  2  CA                   DEX
00C98E  2  10 FB                BPL     _1300040
00C990  2               ;
00C990  2  90 0D                BCC     _1300060        ;LS bit clear
00C992  2               ;
00C992  2  18                   CLC
00C993  2  A2 05                LDX     #s_sfac-1
00C995  2               ;
00C995  2               _1300050:
00C995  2  B5 2D                LDA     facb,x          ;partial result
00C997  2  75 33                ADC     facc,x          ;scratchpad
00C999  2  95 2D                STA     facb,x          ;new partial result
00C99B  2  CA                   DEX
00C99C  2  10 F7                BPL     _1300050
00C99E  2               ;
00C99E  2  18                   CLC
00C99F  2               ;
00C99F  2               _1300060:
00C99F  2  A2 05                LDX     #s_sfac-1
00C9A1  2               ;
00C9A1  2               _1300070:
00C9A1  2  B5 33                LDA     facc,x          ;scratchpad
00C9A3  2  75 33                ADC     facc,x          ;double &...
00C9A5  2  95 33                STA     facc,x          ;save
00C9A7  2  CA                   DEX
00C9A8  2  10 F7                BPL     _1300070
00C9AA  2               ;
00C9AA  2  88                   DEY
00C9AB  2  10 DB                BPL     _1300030        ;next operand bit
00C9AD  2               ;
00C9AD  2  D8                   CLD
00C9AE  2  A2 00                LDX     #0
00C9B0  2  A0 04                LDY     #s_pfac
00C9B2  2               ;
00C9B2  2               _1300080:
00C9B2  2  68                   PLA                     ;operand
00C9B3  2  95 25                STA     faca,x          ;restore
00C9B5  2  E8                   INX
00C9B6  2  88                   DEY
00C9B7  2  D0 F9                BNE     _1300080        ;next
00C9B9  2               ;
00C9B9  2  60                   RTS
00C9BA  2               ;
00C9BA  2               ;================================================================================
00C9BA  2               ;
00C9BA  2               ;nybtobin: CONVERT ASCII NYBBLE TO BINARY
00C9BA  2               ;
00C9BA  2               nybtobin:
00C9BA  2  20 42 CC             JSR     toupper         ;convert case if necessary
00C9BD  2  38                   SEC
00C9BE  2  E9 30                SBC     #'0'            ;change to binary
00C9C0  2  90 08                BCC     _0310020        ;not a numeral - error
00C9C2  2               ;
00C9C2  2  C9 0A                CMP     #10
00C9C4  2  90 03                BCC     _0310010        ;numeral is 0-9
00C9C6  2               ;
00C9C6  2  E9 07                SBC     #a_hexdec+1     ;10-15 --> A-F
00C9C8  2  18                   CLC                     ;no conversion error
00C9C9  2               ;
00C9C9  2               _0310010:
00C9C9  2  60                   RTS
00C9CA  2               ;
00C9CA  2               _0310020:
00C9CA  2  38                   SEC                     ;conversion error
00C9CB  2  60                   RTS
00C9CC  2               ;
00C9CC  2               ;================================================================================
00C9CC  2               ;
00C9CC  2               ;calccnt: COMPUTE BYTE COUNT FROM ADDRESS RANGE
00C9CC  2               ;
00C9CC  2               calccnt:
00C9CC  2  20 69 C9             JSR     clrfacb         ;clear accumulator
00C9CF  2  C2 20                SLONGA
00C9D1  2  38                   SEC
00C9D2  2  A5 22                LDA     addrb           ;ending address
00C9D4  2  E5 1F                SBC     addra           ;starting address
00C9D6  2  85 2D                STA     facb            ;byte count
00C9D8  2  E2 20                SHORTA
00C9DA  2  A5 24                LDA     addrb+s_word    ;handle banks
00C9DC  2  E5 21                SBC     addra+s_word
00C9DE  2  85 2F                STA     facb+s_word
00C9E0  2  60                   RTS
00C9E1  2               ;
00C9E1  2               ;================================================================================
00C9E1  2               ;
00C9E1  2               ;clroper: CLEAR OPERAND
00C9E1  2               ;
00C9E1  2               clroper:
00C9E1  2  DA                   PHX
00C9E2  2  A2 02                LDX     #s_oper-1
00C9E4  2               ;
00C9E4  2               _0320010:
00C9E4  2  74 39                STZ     operand,x
00C9E6  2  CA                   DEX
00C9E7  2  10 FB                BPL     _0320010
00C9E9  2               ;
00C9E9  2  64 4B                STZ     eopsize
00C9EB  2  FA                   PLX
00C9EC  2  60                   RTS
00C9ED  2               ;
00C9ED  2               ;================================================================================
00C9ED  2               ;
00C9ED  2               ;cpfwsup: FOWARD COPY MEMORY SETUP
00C9ED  2               ;
00C9ED  2               cpfwsup:
00C9ED  2  C2 30                LONGR
00C9EF  2  A2 54 00             LDXW    opc_mvn         ;"move next" opcode
00C9F2  2  80 05                BRA     cpsup
00C9F4  2               ;
00C9F4  2               ;================================================================================
00C9F4  2               ;
00C9F4  2               ;cprvsup: REVERSE COPY MEMORY SETUP
00C9F4  2               ;
00C9F4  2               cprvsup:
00C9F4  2  C2 30                LONGR
00C9F6  2  A2 44 00             LDXW    opc_mvp         ;"move previous" opcode
00C9F9  2               ;
00C9F9  2               ;================================================================================
00C9F9  2               ;
00C9F9  2               ;cpsup: COPY MEMORY SETUP
00C9F9  2               ;
00C9F9  2               cpsup:
00C9F9  2  48                   PHA                     ;save banks
00C9FA  2  8A                   TXA                     ;protect...
00C9FB  2  EB                   XBA                     ;opcode
00C9FC  2  E2 20                SHORTA
00C9FE  2  A2 08 00             LDXW    copylen
00CA01  2               ;
00CA01  2               _1320010:
00CA01  2  BF EE CC 00          LDALX   cpcode          ;transfer copy code to...
00CA05  2  95 25                STA     mcftwork,x      ;to workspace
00CA07  2  CA                   DEX
00CA08  2  10 F7                BPL     _1320010
00CA0A  2               ;
00CA0A  2  EB                   XBA                     ;recover opcode &...
00CA0B  2  85 26                STA     mcftopc         ;set it
00CA0D  2  C2 20                SLONGA
00CA0F  2  68                   PLA                     ;get banks &...
00CA10  2  85 27                STA     mcftbnk         ;set them
00CA12  2  60                   RTS
00CA13  2               ;
00CA13  2               ;================================================================================
00CA13  2               ;
00CA13  2               ;decdcnt: DECREMENT DUMP COUNT
00CA13  2               ;
00CA13  2               ;	-------------------------------------------
00CA13  2               ;	Preparatory Ops: bytes to process in FACB
00CA13  2               ;	                 bytes processed in CHARCNT
00CA13  2               ;
00CA13  2               ;	Returned Values: .A: used
00CA13  2               ;	                 .X: entry value
00CA13  2               ;	                 .Y: entry value
00CA13  2               ;	                 .C: 1 = count = zero
00CA13  2               ;	-------------------------------------------
00CA13  2               ;
00CA13  2               decdcnt:
00CA13  2  E2 20                SHORTA
00CA15  2  A9 00                LDA     #0
00CA17  2  EB                   XBA                     ;clear .B
00CA18  2  A5 2F                LDA     facb+s_word     ;count MSW
00CA1A  2  C2 20                SLONGA
00CA1C  2  38                   SEC
00CA1D  2  05 2D                ORA     facb            ;count LSW
00CA1F  2  F0 13                BEQ     _0330020        ;zero, just exit
00CA21  2               ;
00CA21  2  A5 2D                LDA     facb
00CA23  2  E5 42                SBC     charcnt         ;bytes processed
00CA25  2  85 2D                STA     facb
00CA27  2  E2 20                SHORTA
00CA29  2  A5 2F                LDA     facb+s_word
00CA2B  2  E9 00                SBC     #0              ;handle borrow
00CA2D  2  90 04                BCC     _0330010        ;underflow
00CA2F  2               ;
00CA2F  2  85 2F                STA     facb+s_word
00CA31  2  18                   CLC                     ;count > 0
00CA32  2  60                   RTS
00CA33  2               ;
00CA33  2               _0330010:
00CA33  2  38                   SEC
00CA34  2               ;
00CA34  2               _0330020:
00CA34  2  E2 20                SHORTA
00CA36  2  60                   RTS
00CA37  2               ;
00CA37  2               ;================================================================================
00CA37  2               ;
00CA37  2               ;enddest: GET 2ND & 3RD ADDRESSES FOR COMPARE & TRANSFER
00CA37  2               ;
00CA37  2               enddest:
00CA37  2  20 7B CA             JSR     facasize        ;check start...
00CA3A  2  C9 04                CMP     #s_dword        ;for range
00CA3C  2  B0 1E                BCS     _0340010        ;out of range - error
00CA3E  2               ;
00CA3E  2  20 5D CA             JSR     facaddra        ;store start
00CA41  2  20 8B CA             JSR     getparm         ;get end
00CA44  2  B0 16                BCS     _0340010        ;not entered - error
00CA46  2               ;
00CA46  2  20 7B CA             JSR     facasize        ;check end...
00CA49  2  C9 04                CMP     #s_dword        ;for range
00CA4B  2  B0 0F                BCS     _0340010        ;out of range - error
00CA4D  2               ;
00CA4D  2  20 67 CA             JSR     facaddrb        ;store end
00CA50  2  20 8B CA             JSR     getparm         ;get destination
00CA53  2  B0 07                BCS     _0340010        ;not entered - error
00CA55  2               ;
00CA55  2  20 7B CA             JSR     facasize        ;check destination...
00CA58  2  C9 04                CMP     #s_dword        ;for range
00CA5A  2  90 15                BCC     facaoper        ;store dest address
00CA5C  2               ;
00CA5C  2               _0340010:
00CA5C  2  60                   RTS                     ;exit w/error
00CA5D  2               ;
00CA5D  2               ;================================================================================
00CA5D  2               ;
00CA5D  2               ;facaddra: COPY FACA TO ADDRA
00CA5D  2               ;
00CA5D  2               facaddra:
00CA5D  2  A2 02                LDX     #s_xword-1
00CA5F  2               ;
00CA5F  2               _0350010:
00CA5F  2  B5 25                LDA     faca,x
00CA61  2  95 1F                STA     addra,x
00CA63  2  CA                   DEX
00CA64  2  10 F9                BPL     _0350010
00CA66  2               ;
00CA66  2  60                   RTS
00CA67  2               ;
00CA67  2               ;================================================================================
00CA67  2               ;
00CA67  2               ;facaddrb: COPY FACA TO ADDRB
00CA67  2               ;
00CA67  2               facaddrb:
00CA67  2  A2 02                LDX     #s_xword-1
00CA69  2               ;
00CA69  2               _1350010:
00CA69  2  B5 25                LDA     faca,x
00CA6B  2  95 22                STA     addrb,x
00CA6D  2  CA                   DEX
00CA6E  2  10 F9                BPL     _1350010
00CA70  2               ;
00CA70  2  60                   RTS
00CA71  2               ;
00CA71  2               ;================================================================================
00CA71  2               ;
00CA71  2               ;facaoper: COPY FACA TO OPERAND
00CA71  2               ;
00CA71  2               facaoper:
00CA71  2  A2 02                LDX     #s_oper-1
00CA73  2               ;
00CA73  2               _0360010:
00CA73  2  B5 25                LDA     faca,x
00CA75  2  95 39                STA     operand,x
00CA77  2  CA                   DEX
00CA78  2  10 F9                BPL     _0360010
00CA7A  2               ;
00CA7A  2  60                   RTS
00CA7B  2               ;
00CA7B  2               ;================================================================================
00CA7B  2               ;
00CA7B  2               ;facasize: REPORT OPERAND SIZE IN FACA
00CA7B  2               ;
00CA7B  2               ;	------------------------------------------
00CA7B  2               ;	Preparatory Ops: operand in FACA
00CA7B  2               ;
00CA7B  2               ;	Returned Values: .A: s_byte  (1)
00CA7B  2               ;	                     s_word  (2)
00CA7B  2               ;	                     s_xword (3)
00CA7B  2               ;	                     s_dword (4)
00CA7B  2               ;
00CA7B  2               ;	Notes: 1) This function will always report
00CA7B  2               ;	          a non-zero result.
00CA7B  2               ;	------------------------------------------
00CA7B  2               ;
00CA7B  2               facasize:
00CA7B  2  E2 30                SHORTR
00CA7D  2  A2 03                LDX     #s_dword-1
00CA7F  2               ;
00CA7F  2               _0370010:
00CA7F  2  B5 25                LDA     faca,x          ;get byte
00CA81  2  D0 03                BNE     _0370020        ;done
00CA83  2               ;
00CA83  2  CA                   DEX
00CA84  2  D0 F9                BNE     _0370010        ;next byte
00CA86  2               ;
00CA86  2               _0370020:
00CA86  2  E8                   INX                     ;count=index+1
00CA87  2  8A                   TXA
00CA88  2  60                   RTS
00CA89  2               ;
00CA89  2               ;================================================================================
00CA89  2               ;
00CA89  2               ;getparm: GET A PARAMETER
00CA89  2               ;
00CA89  2               ;	-------------------------------------------------
00CA89  2               ;	Preparatory Ops: null-terminated input in IBUFFER
00CA89  2               ;
00CA89  2               ;	Returned Values: .A: chars in converted parameter
00CA89  2               ;	                 .X: used
00CA89  2               ;	                 .Y: entry value
00CA89  2               ;	                 .C: 1 = no parameter entered
00CA89  2               ;	-------------------------------------------------
00CA89  2               ;
00CA89  2               getparmr:
00CA89  2  C6 3D                DEC     ibufidx         ;reread previous char
00CA8B  2               ;
00CA8B  2               getparm:
00CA8B  2  5A                   PHY                     ;preserve
00CA8C  2  20 F5 C7             JSR     ascbin          ;convert parameter to binary
00CA8F  2  B0 1C                BCS     _0380040        ;conversion error
00CA91  2               ;
00CA91  2  20 7A CB             JSR     getcharr        ;reread last char
00CA94  2  D0 08                BNE     _0380010        ;not end-of-input
00CA96  2               ;
00CA96  2  C6 3D                DEC     ibufidx         ;reindex to terminator
00CA98  2  A5 42                LDA     charcnt         ;get chars processed so far
00CA9A  2  F0 0C                BEQ     _0380030        ;none
00CA9C  2               ;
00CA9C  2  D0 08                BNE     _0380020        ;some
00CA9E  2               ;
00CA9E  2               _0380010:
00CA9E  2  C9 20                CMP     #a_blank        ;recognized delimiter
00CAA0  2  F0 04                BEQ     _0380020        ;end of parameter
00CAA2  2               ;
00CAA2  2  C9 2C                CMP     #','            ;recognized delimiter
00CAA4  2  D0 07                BNE     _0380040        ;unknown delimter
00CAA6  2               ;
00CAA6  2               _0380020:
00CAA6  2  18                   CLC
00CAA7  2  24                   .BYTE   bitzp           ;skip SEC below
00CAA8  2               ;
00CAA8  2               _0380030:
00CAA8  2  38                   SEC
00CAA9  2  7A                   PLY                     ;restore
00CAAA  2  A5 42                LDA     charcnt         ;get count
00CAAC  2  60                   RTS                     ;done
00CAAD  2               ;
00CAAD  2               _0380040:                       ;.rept 3               ;clean up stack
00CAAD  2  68                   PLA
00CAAE  2  68                   PLA
00CAAF  2  68                   PLA
00CAB0  2               ;.endr
00CAB0  2  4C 7A C1             JMP     monerr          ;abort w/error
00CAB3  2               ;
00CAB3  2               ;================================================================================
00CAB3  2               ;
00CAB3  2               ;nxtaddra: TEST & INCREMENT WORKING ADDRESS 'A'
00CAB3  2               ;
00CAB3  2               ;	--------------------------------------------------
00CAB3  2               ;	Calling syntax: JSR NXTADDRA
00CAB3  2               ;
00CAB3  2               ;	Exit registers: .A: used
00CAB3  2               ;	                .B: used
00CAB3  2               ;	                .X: entry value
00CAB3  2               ;	                .Y: entry value
00CAB3  2               ;	                DB: entry value
00CAB3  2               ;	                DP: entry value
00CAB3  2               ;	                PB: entry value
00CAB3  2               ;	                SR: NVmxDIZC
00CAB3  2               ;	                    ||||||||
00CAB3  2               ;	                    |||||||+---> 0: ADDRA < ADDRB
00CAB3  2               ;	                    |||||||      1: ADDRA >= ADDRB
00CAB3  2               ;	                    ||||||+----> undefined
00CAB3  2               ;	                    |||+++-----> entry value
00CAB3  2               ;	                    ||+--------> 1
00CAB3  2               ;	                    ++---------> undefined
00CAB3  2               ;	--------------------------------------------------
00CAB3  2               ;
00CAB3  2               nxtaddra:
00CAB3  2  E2 20                SHORTA
00CAB5  2  A5 21                LDA     addra+s_word    ;bits 16-23
00CAB7  2  C5 24                CMP     addrb+s_word
00CAB9  2  90 0F                BCC     incaddra        ;increment
00CABB  2               ;
00CABB  2  D0 0A                BNE     _0390010        ;don't increment
00CABD  2               ;
00CABD  2  C2 20                SLONGA
00CABF  2  A5 1F                LDA     addra           ;bits 0-15
00CAC1  2  C5 22                CMP     addrb           ;condition flags
00CAC3  2  E2 20                SHORTA
00CAC5  2  90 03                BCC     incaddra        ;increment
00CAC7  2               ;
00CAC7  2               _0390010:
00CAC7  2  60                   RTS
00CAC8  2               ;
00CAC8  2               ;================================================================================
00CAC8  2               ;
00CAC8  2               ;getbyte: GET A BYTE FROM MEMORY
00CAC8  2               ;
00CAC8  2               getbyte:
00CAC8  2  A7 1F                LDAIL   addra           ;get a byte
00CACA  2               ;
00CACA  2               ;================================================================================
00CACA  2               ;
00CACA  2               ;incaddra: INCREMENT WORKING ADDRESS 'A'
00CACA  2               ;
00CACA  2               ;	--------------------------------------------------
00CACA  2               ;	Calling syntax: JSR INCADDRA
00CACA  2               ;
00CACA  2               ;	Exit registers: .A: entry value
00CACA  2               ;	                .B: entry value
00CACA  2               ;	                .X: entry value
00CACA  2               ;	                .Y: entry value
00CACA  2               ;	                DB: entry value
00CACA  2               ;	                DP: entry value
00CACA  2               ;	                PB: entry value
00CACA  2               ;	                SR: NVmxDIZC
00CACA  2               ;	                    ||||||||
00CACA  2               ;	                    ++++++++---> entry value
00CACA  2               ;	--------------------------------------------------
00CACA  2               ;
00CACA  2               incaddra:
00CACA  2  08                   PHP
00CACB  2  C2 20                SLONGA
00CACD  2  E6 1F                INC     addra           ;bump bits 0-15
00CACF  2  D0 04                BNE     _0400010
00CAD1  2               ;
00CAD1  2  E2 20                SHORTA
00CAD3  2  E6 21                INC     addra+s_word    ;bump bits 16-23
00CAD5  2               ;
00CAD5  2               _0400010:
00CAD5  2  28                   PLP
00CAD6  2  60                   RTS
00CAD7  2               ;
00CAD7  2               ;================================================================================
00CAD7  2               ;
00CAD7  2               ;incoper: INCREMENT OPERAND ADDRESS
00CAD7  2               ;
00CAD7  2               incoper:
00CAD7  2  18                   CLC
00CAD8  2  08                   PHP
00CAD9  2  C2 30                LONGR
00CADB  2  48                   PHA
00CADC  2  E6 39                INC     operand         ;handle base address
00CADE  2  D0 06                BNE     _0410010
00CAE0  2               ;
00CAE0  2  E2 20                SHORTA
00CAE2  2  E6 3B                INC     operand+s_word  ;handle bank
00CAE4  2  C2 20                SLONGA
00CAE6  2               ;
00CAE6  2               _0410010:
00CAE6  2  68                   PLA
00CAE7  2  28                   PLP
00CAE8  2  60                   RTS
00CAE9  2               ;
00CAE9  2               ;================================================================================
00CAE9  2               ;
00CAE9  2               ;instdata: GET INSTRUCTION SIZE & ADDRESSING MODE DATA
00CAE9  2               ;
00CAE9  2               ;	----------------------------------
00CAE9  2               ;	Preparatory Ops: .X: 65C816 opcode
00CAE9  2               ;
00CAE9  2               ;	Returned Values: .A: mode flags
00CAE9  2               ;	                 .X: operand size
00CAE9  2               ;	                 .Y: mode index
00CAE9  2               ;	----------------------------------
00CAE9  2               ;
00CAE9  2               instdata:
00CAE9  2  E2 30                SHORTR
00CAEB  2  BD F7 CE             LDA     mnetabam,x      ;addressing mode data
00CAEE  2  48                   PHA                     ;save mode flag bits
00CAEF  2  48                   PHA                     ;save size data
00CAF0  2  29 0F                AND     #amodmask       ;extract mode index &...
00CAF2  2  A8                   TAY                     ;save
00CAF3  2  68                   PLA                     ;recover data
00CAF4  2  29 30                AND     #opsmask        ;mask mode fields &...
00CAF6  2               ;         .rept n_opslsr        ;extract operand size
00CAF6  2  4A                   LSR
00CAF7  2  4A                   LSR
00CAF8  2  4A                   LSR
00CAF9  2  4A                   LSR
00CAFA  2               ;         .endr
00CAFA  2  AA                   TAX                     ;operand size
00CAFB  2  68                   PLA                     ;recover mode flags
00CAFC  2  29 C0                AND     #vopsmask       ;discard mode & size fields
00CAFE  2  60                   RTS
00CAFF  2               ;
00CAFF  2               ;================================================================================
00CAFF  2               ;
00CAFF  2               ;offtarg: CONVERT BRANCH OFFSET TO TARGET ADDRESS
00CAFF  2               ;
00CAFF  2               ;	-----------------------------------------------
00CAFF  2               ;	Preparatory Ops:    ADDRA: base address
00CAFF  2               ;	                 INSTSIZE: instruction size
00CAFF  2               ;	                  OPERAND: offset
00CAFF  2               ;
00CAFF  2               ;	Returned Values:  OPERAND: target address (L/H)
00CAFF  2               ;	                       .A: used
00CAFF  2               ;	                       .X: entry value
00CAFF  2               ;                              .Y: entry value
00CAFF  2               ;	-----------------------------------------------
00CAFF  2               ;
00CAFF  2               offtarg:
00CAFF  2  C2 20                SLONGA
00CB01  2  A5 1F                LDA     addra           ;base address
00CB03  2  E2 20                SHORTA
00CB05  2  46 44                LSR     instsize        ;bit 0 will be set if...
00CB07  2  B0 07                BCS     _0420010        ;a long branch
00CB09  2               ;
00CB09  2  24 39                BIT     operand         ;short forward or backward?
00CB0B  2  10 03                BPL     _0420010        ;forward
00CB0D  2               ;
00CB0D  2  EB                   XBA                     ;expose address MSB
00CB0E  2  3A                   DEA                     ;back a page
00CB0F  2  EB                   XBA                     ;expose address LSB
00CB10  2               ;
00CB10  2               _0420010:
00CB10  2  C2 20                SLONGA
00CB12  2  18                   CLC
00CB13  2  65 39                ADC     operand         ;calculate target address
00CB15  2  85 39                STA     operand         ;new operand
00CB17  2  E2 20                SHORTA
00CB19  2  A9 03                LDA     #s_xword
00CB1B  2  85 44                STA     instsize        ;effective instruction size
00CB1D  2  60                   RTS
00CB1E  2               ;
00CB1E  2               ;================================================================================
00CB1E  2               ;
00CB1E  2               ;setxaddr: SET EXECUTION ADDRESS
00CB1E  2               ;
00CB1E  2               setxaddr:
00CB1E  2  B0 13                BCS     _0430010        ;no address given
00CB20  2               ;
00CB20  2  20 7B CA             JSR     facasize        ;check address...
00CB23  2  C9 04                CMP     #s_dword        ;range
00CB25  2  B0 0D                BCS     _0430020        ;out of range
00CB27  2               ;
00CB27  2  C2 20                SLONGA
00CB29  2  A5 25                LDA     faca            ;execution address
00CB2B  2  85 11                STA     reg_pcx         ;set new PC value
00CB2D  2  E2 20                SHORTA
00CB2F  2  A5 27                LDA     faca+s_word
00CB31  2  85 10                STA     reg_pbx         ;set new PB value
00CB33  2               ;
00CB33  2               _0430010:
00CB33  2  18                   CLC                     ;no error
00CB34  2               ;
00CB34  2               _0430020:
00CB34  2  60                   RTS
00CB35  2               ;
00CB35  2               ;================================================================================
00CB35  2               ;
00CB35  2               ;targoff: CONVERT BRANCH TARGET ADDRESS TO BRANCH OFFSET
00CB35  2               ;
00CB35  2               ;	-------------------------------------------------
00CB35  2               ;	Preparatory Ops:   ADDRA: instruction address
00CB35  2               ;	                 OPERAND: target address
00CB35  2               ;
00CB35  2               ;	Returned Values: OPERAND: computed offset
00CB35  2               ;	                      .A: effective operand size
00CB35  2               ;	                      .X: entry value
00CB35  2               ;                             .Y: entry value
00CB35  2               ;	                      .C: 1 = branch out of range
00CB35  2               ;
00CB35  2               ;	Execution notes: ADDRB is set to the branch base
00CB35  2               ;	                 address.
00CB35  2               ;	-------------------------------------------------
00CB35  2               ;
00CB35  2               targoff:
00CB35  2  64 45                STZ     instsize+s_byte ;always zero
00CB37  2  A5 44                LDA     instsize        ;instruction size will tell...
00CB39  2  4A                   LSR                     ;if long or short branch
00CB3A  2               ;
00CB3A  2               ;-------------------------------------------------
00CB3A  2               _btype          = facc+5        ;branch type flag
00CB3A  2               ;-------------------------------------------------
00CB3A  2               ;
00CB3A  2  66 38                ROR     _btype          ;set branch type...
00CB3C  2               ;
00CB3C  2               ;	x0000000
00CB3C  2               ;	|
00CB3C  2               ;	+----------> 0: short
00CB3C  2               ;	             1: long
00CB3C  2               ;
00CB3C  2  C2 20                SLONGA
00CB3E  2  18                   CLC
00CB3F  2  A5 1F                LDA     addra           ;instruction address
00CB41  2  65 44                ADC     instsize        ;instruction size
00CB43  2  85 22                STA     addrb           ;base address
00CB45  2  38                   SEC
00CB46  2  A5 39                LDA     operand         ;target address
00CB48  2  E5 22                SBC     addrb           ;base address
00CB4A  2  85 39                STA     operand         ;offset
00CB4C  2  E2 20                SHORTA
00CB4E  2  90 15                BCC     _0440040        ;backward branch
00CB50  2               ;
00CB50  2  24 38                BIT     _btype          ;check branch range
00CB52  2  30 0A                BMI     _0440020        ;long
00CB54  2               ;
00CB54  2               ;
00CB54  2               ;	process short forward branch...
00CB54  2               ;
00CB54  2  EB                   XBA                     ;offset MSB should be zero
00CB55  2  D0 21                BNE     _0440060        ;it isn't - out of range
00CB57  2               ;
00CB57  2  EB                   XBA                     ;offset LSB should be $00-$7F
00CB58  2  30 1E                BMI     _0440060        ;it isn't - out of range
00CB5A  2               ;
00CB5A  2               _0440010:
00CB5A  2  A9 01                LDA     #s_byte         ;final instruction size
00CB5C  2  18                   CLC                     ;branch in range
00CB5D  2  60                   RTS
00CB5E  2               ;
00CB5E  2               ;
00CB5E  2               ;	process long forward branch...
00CB5E  2               ;
00CB5E  2               _0440020:
00CB5E  2  EB                   XBA                     ;offset MSB should be positive
00CB5F  2  30 17                BMI     _0440060        ;it isn't - branch out of range
00CB61  2               ;
00CB61  2               _0440030:
00CB61  2  A9 02                LDA     #s_word
00CB63  2  18                   CLC
00CB64  2  60                   RTS
00CB65  2               ;
00CB65  2               ;
00CB65  2               ;	process backward branch...
00CB65  2               ;
00CB65  2               _0440040:
00CB65  2  24 38                BIT     _btype          ;long or short?
00CB67  2  30 0C                BMI     _0440050        ;long
00CB69  2               ;
00CB69  2               ;
00CB69  2               ;	process short backward branch...
00CB69  2               ;
00CB69  2  EB                   XBA                     ;offset MSB should be negative
00CB6A  2  10 0C                BPL     _0440060        ;it isn't - out of range
00CB6C  2               ;
00CB6C  2  49 FF                EOR     #%11111111      ;complement offset MSB 2s
00CB6E  2  D0 08                BNE     _0440060        ;out of range
00CB70  2               ;
00CB70  2  EB                   XBA                     ;offset LSB should be $80-$FF
00CB71  2  30 E7                BMI     _0440010        ;it is - branch in range
00CB73  2               ;
00CB73  2  80 03                BRA     _0440060        ;branch out of range
00CB75  2               ;
00CB75  2               ;
00CB75  2               ;	process long backward branch...
00CB75  2               ;
00CB75  2               _0440050:
00CB75  2  EB                   XBA                     ;offset MSB should be negative
00CB76  2  30 E9                BMI     _0440030        ;it is - branch in range
00CB78  2               ;
00CB78  2               _0440060:
00CB78  2  38                   SEC                     ;range error
00CB79  2  60                   RTS
00CB7A  2               ;
00CB7A  2               ;================================================================================
00CB7A  2               ;
00CB7A  2               ;getcharr: GET PREVIOUS INPUT BUFFER CHARACTER
00CB7A  2               ;
00CB7A  2               getcharr:
00CB7A  2  C6 3D                DEC     ibufidx         ;move back a char
00CB7C  2               ;
00CB7C  2               ;================================================================================
00CB7C  2               ;
00CB7C  2               ;getchar: GET A CHARACTER FROM INPUT BUFFER
00CB7C  2               ;
00CB7C  2               ;	----------------------------------------------
00CB7C  2               ;	Preparatory Ops : none
00CB7C  2               ;
00CB7C  2               ;	Register Returns: .A: character or <NUL>
00CB7C  2               ;	                  .B: entry value
00CB7C  2               ;	                  .X: entry value
00CB7C  2               ;	                  .Y: entry value
00CB7C  2               ;
00CB7C  2               ;	MPU Flags: NVmxDIZC
00CB7C  2               ;	           ||||||||
00CB7C  2               ;	           |||||||+---> entry value
00CB7C  2               ;	           ||||||+----> 1: <NUL> gotten
00CB7C  2               ;	           |||||+-----> entry value
00CB7C  2               ;	           ||||+------> entry value
00CB7C  2               ;	           |||+-------> entry value
00CB7C  2               ;	           ||+--------> entry value
00CB7C  2               ;	           |+---------> not defined
00CB7C  2               ;	           +----------> not defined
00CB7C  2               ;	----------------------------------------------
00CB7C  2               ;
00CB7C  2               getchar:
00CB7C  2  DA                   PHX
00CB7D  2  5A                   PHY
00CB7E  2  08                   PHP                     ;save register sizes
00CB7F  2  E2 30                SHORTR                  ;force 8 bits
00CB81  2  A6 3D                LDX     ibufidx         ;buffer index
00CB83  2  BD 00 02             LDA     ibuffer,x       ;get char
00CB86  2  E6 3D                INC     ibufidx         ;bump index
00CB88  2  28                   PLP                     ;restore register widths
00CB89  2  7A                   PLY
00CB8A  2  FA                   PLX
00CB8B  2  EB                   XBA                     ;condition...
00CB8C  2  EB                   XBA                     ;.Z
00CB8D  2  60                   RTS
00CB8E  2               ;
00CB8E  2               ;================================================================================
00CB8E  2               ;
00CB8E  2               ;getpat: GET PATTERN FOR MEMORY CHANGE or SEARCH
00CB8E  2               ;
00CB8E  2               ;	-----------------------------------------------------
00CB8E  2               ;	Preparatory Ops: Null-terminated pattern in IBUFFER.
00CB8E  2               ;
00CB8E  2               ;	Returned Values: .A: used
00CB8E  2               ;	                 .X: used
00CB8E  2               ;	                 .Y: pattern length if entered
00CB8E  2               ;	                 .C: 0 = pattern valid
00CB8E  2               ;	                     1 = exception:
00CB8E  2               ;	                 .N  0 = no pattern entered
00CB8E  2               ;	                     1 = evaluation error
00CB8E  2               ;
00CB8E  2               ;	Notes: 1) If pattern is preceded by "'" the following
00CB8E  2               ;	          characters are interpreted as ASCII.
00CB8E  2               ;	       2) A maximum of 32 bytes or characters is
00CB8E  2               ;	          accepted.  Excess input will be discarded.
00CB8E  2               ;	-----------------------------------------------------
00CB8E  2               ;
00CB8E  2               getpat:
00CB8E  2  64 49                STZ     status          ;clear pattern type indicator
00CB90  2  A0 00                LDY     #0              ;pattern index
00CB92  2  20 7A CB             JSR     getcharr        ;get last char
00CB95  2  F0 3C                BEQ     _0450070        ;EOS
00CB97  2               ;
00CB97  2  A6 3D                LDX     ibufidx         ;current buffer index
00CB99  2  20 DA CB             JSR     getcharw        ;get next
00CB9C  2  F0 35                BEQ     _0450070        ;EOS
00CB9E  2               ;
00CB9E  2  C9 27                CMP     #$27            ; single quote
00CBA0  2  D0 04                BNE     _0450010        ;not ASCII input
00CBA2  2               ;
00CBA2  2  66 49                ROR     status          ;condition flag
00CBA4  2  80 12                BRA     _0450030        ;balance of input is ASCII
00CBA6  2               ;
00CBA6  2               _0450010:
00CBA6  2  86 3D                STX     ibufidx         ;restore buffer index
00CBA8  2               ;
00CBA8  2               _0450020:
00CBA8  2  20 8B CA             JSR     getparm         ;evaluate numeric pattern
00CBAB  2  B0 21                BCS     _0450060        ;done w/pattern
00CBAD  2               ;
00CBAD  2  20 7B CA             JSR     facasize        ;size
00CBB0  2  C9 02                CMP     #s_word
00CBB2  2  B0 1F                BCS     _0450070        ;not a byte - error
00CBB4  2               ;
00CBB4  2  A5 25                LDA     faca            ;get byte &...
00CBB6  2  80 05                BRA     _0450040        ;store
00CBB8  2               ;
00CBB8  2               _0450030:
00CBB8  2  20 7C CB             JSR     getchar         ;get ASCII char
00CBBB  2  F0 11                BEQ     _0450060        ;done w/pattern
00CBBD  2               ;
00CBBD  2               _0450040:
00CBBD  2  C0 20                CPY     #s_auxbuf       ;pattern buffer full?
00CBBF  2  F0 0A                BEQ     _0450050        ;yes
00CBC1  2               ;
00CBC1  2  99 46 02             STA     auxbuf,y        ;store pattern
00CBC4  2  C8                   INY
00CBC5  2  24 49                BIT     status
00CBC7  2  10 DF                BPL     _0450020        ;get next numeric value
00CBC9  2               ;
00CBC9  2  80 ED                BRA     _0450030        ;get next ASCII char
00CBCB  2               ;
00CBCB  2               _0450050:
00CBCB  2  20 D3 C7             JSR     alert           ;excess input
00CBCE  2               ;
00CBCE  2               _0450060:
00CBCE  2  84 3C                STY     auxbufix        ;save pattern size
00CBD0  2  98                   TYA                     ;condition .Z
00CBD1  2  18                   CLC                     ;pattern valid
00CBD2  2  60                   RTS
00CBD3  2               ;
00CBD3  2               ;
00CBD3  2               ;	no pattern entered...
00CBD3  2               ;
00CBD3  2               _0450070:
00CBD3  2  C2 80                REP     #%10000000
00CBD5  2  38                   SEC
00CBD6  2  60                   RTS
00CBD7  2               ;
00CBD7  2               ;
00CBD7  2               ;	evaluation error...
00CBD7  2               ;
00CBD7  2               _0450080:
00CBD7  2  E2 81                SEP     #%10000001
00CBD9  2  60                   RTS
00CBDA  2               ;
00CBDA  2               ;================================================================================
00CBDA  2               ;
00CBDA  2               ;getcharw: GET FROM INPUT BUFFER, DISCARDING WHITESPACE
00CBDA  2               ;
00CBDA  2               ;	--------------------------------------------------
00CBDA  2               ;	Preparatory Ops: Null-terminated input in IBUFFER.
00CBDA  2               ;
00CBDA  2               ;	Returned Values: .A: char or null
00CBDA  2               ;	                 .X: entry value
00CBDA  2               ;	                 .Y: entry value
00CBDA  2               ;	                 .Z: 1 = null terminator detected
00CBDA  2               ;
00CBDA  2               ;	Notes: Whitespace is defined as a blank ($20) or a
00CBDA  2               ;	       horizontal tab ($09).
00CBDA  2               ;	--------------------------------------------------
00CBDA  2               ;
00CBDA  2               getcharw:
00CBDA  2  20 7C CB             JSR     getchar         ;get from buffer
00CBDD  2  F0 08                BEQ     _0460010        ;EOI
00CBDF  2               ;
00CBDF  2  C9 20                CMP     #a_blank
00CBE1  2  F0 F7                BEQ     getcharw        ;discard whitespace
00CBE3  2               ;
00CBE3  2  C9 09                CMP     #a_ht           ;also whitespace
00CBE5  2  F0 F3                BEQ     getcharw
00CBE7  2               ;
00CBE7  2               _0460010:
00CBE7  2  18                   CLC
00CBE8  2  60                   RTS
00CBE9  2               ;
00CBE9  2               ;================================================================================
00CBE9  2               ;
00CBE9  2               ;input: INTERACTIVE INPUT FROM CONSOLE CHANNEL
00CBE9  2               ;
00CBE9  2               ;	-----------------------------------------------------------
00CBE9  2               ;	Preparatory Ops: Zero IBUFIDX or load IBUFFER with default
00CBE9  2               ;	                 input & set IBUFIDX to the number of chars
00CBE9  2               ;	                 loaded into the buffer.
00CBE9  2               ;
00CBE9  2               ;	Returned Values: .A: used
00CBE9  2               ;	                 .X: characters entered
00CBE9  2               ;	                 .Y: used
00CBE9  2               ;
00CBE9  2               ;	Example: STZ IBUFIDX
00CBE9  2               ;	         JSR INPUT
00CBE9  2               ;
00CBE9  2               ;	Notes: Input is collected in IBUFFER & is null-terminated.
00CBE9  2               ;	       IBUFIDX is reset to zero upon exit.
00CBE9  2               ;	-----------------------------------------------------------
00CBE9  2               ;
00CBE9  2               input:
00CBE9  2  A6 3D                LDX     ibufidx
00CBEB  2  9E 00 02             STZ     ibuffer,x       ;be sure buffer is terminated
00CBEE  2  20 50 C7             JSR     dpyibuf         ;print default input if any
00CBF1  2               
00CBF1  2  A6 3D                LDX     ibufidx         ;starting buffer index
00CBF3  2               ;
00CBF3  2               ;
00CBF3  2               ;	main input loop...
00CBF3  2               ;
00CBF3  2               _0470010:
00CBF3  2  20 DF D2             JSR     CURSOR
00CBF6  2               _047001A:
00CBF6  2  20 74 FF             JSR     getcha          ;poll for input
00CBF9  2  90 02                BCC     _0470020        ;got something
00CBFB  2               ;
00CBFB  2               ;         wai                   ;wait 'til any IRQ &...
00CBFB  2  80 F9                BRA     _047001A        ;try again
00CBFD  2               ;
00CBFD  2               _0470020:
00CBFD  2  C9 7F                CMP     #a_del          ;above ASCII range?
00CBFF  2  B0 F5                BCS     _047001A        ;yes, ignore
00CC01  2               
00CC01  2  20 1F D3             JSR     UNCURSOR
00CC04  2               ;
00CC04  2  C9 09                CMP     #a_ht           ;horizontal tab?
00CC06  2  D0 02                BNE     _0470030        ;no
00CC08  2               ;
00CC08  2  A9 20                LDA     #a_blank        ;replace <HT> w/blank
00CC0A  2               ;
00CC0A  2               _0470030:
00CC0A  2  C9 20                CMP     #a_blank        ;control char?
00CC0C  2  90 10                BCC     _0470050        ;yes
00CC0E  2               ;
00CC0E  2               ;
00CC0E  2               ;	process QWERTY character...
00CC0E  2               ;
00CC0E  2  E0 45                CPX     #s_ibuf         ;room in buffer?
00CC10  2  B0 05                BCS     _0470040        ;no
00CC12  2               ;
00CC12  2  9D 00 02             STA     ibuffer,x       ;store char
00CC15  2  E8                   INX                     ;bump index
00CC16  2  2C                   .BYTE   bitabs          ;echo char
00CC17  2               ;
00CC17  2               _0470040:
00CC17  2  A9 07                LDA     #a_bel          ;alert user
00CC19  2  20 71 FF             JSR     putcha
00CC1C  2  80 D5                BRA     _0470010        ;get some more
00CC1E  2               ;
00CC1E  2               ;
00CC1E  2               ;	process carriage return...
00CC1E  2               ;
00CC1E  2               _0470050:
00CC1E  2  C9 0D                CMP     #a_cr           ;carriage return?
00CC20  2  D0 06                BNE     _0470060        ;no
00CC22  2               ;
00CC22  2               ;         phx                   ;protect input count
00CC22  2               ;         pea dc_co
00CC22  2               ;         jsr sprint            ;cursor off
00CC22  2               ;         plx                   ;recover input count
00CC22  2  9E 00 02             STZ     ibuffer,x       ;terminate input &...
00CC25  2  64 3D                STZ     ibufidx         ;reset buffer index
00CC27  2  60                   RTS                     ;done
00CC28  2               ;
00CC28  2               ;
00CC28  2               ;	process backspace...
00CC28  2               ;
00CC28  2               _0470060:
00CC28  2  C9 08                CMP     #a_bs           ;backspace?
00CC2A  2  D0 C7                BNE     _0470010        ;no
00CC2C  2               ;
00CC2C  2  8A                   TXA
00CC2D  2  F0 C4                BEQ     _0470010        ;no input, ignore <BS>
00CC2F  2               ;
00CC2F  2  CA                   DEX                     ;1 less char
00CC30  2  DA                   PHX                     ;preserve count
00CC31  2  20 90 C7             JSR     gendbs          ;destructive backspace
00CC34  2  FA                   PLX                     ;restore count
00CC35  2  80 BC                BRA     _0470010        ;get more input
00CC37  2               ;
00CC37  2               ;================================================================================
00CC37  2               ;
00CC37  2               ;lodbnk: LOAD SOURCE & DESTINATION BANKS
00CC37  2               ;
00CC37  2               lodbnk:
00CC37  2  E2 20                SHORTA
00CC39  2  A5 3B                LDA     operand+s_word  ;destination bank
00CC3B  2  EB                   XBA                     ;make it MSB
00CC3C  2  A5 21                LDA     addra+s_word    ;source bank is LSB
00CC3E  2  60                   RTS
00CC3F  2               ;
00CC3F  2               ;================================================================================
00CC3F  2               ;
00CC3F  2               ;getcharc: GET A CHARACTER FROM INPUT BUFFER & CONVERT CASE
00CC3F  2               ;
00CC3F  2               ;	--------------------------------------------------
00CC3F  2               ;	Preparatory Ops: Null-terminated input in IBUFFER.
00CC3F  2               ;
00CC3F  2               ;	Returned Values: .A: char or null
00CC3F  2               ;	                 .X: entry value
00CC3F  2               ;	                 .Y: entry value
00CC3F  2               ;	                 .Z: 1 = null terminator detected
00CC3F  2               ;	--------------------------------------------------
00CC3F  2               ;
00CC3F  2               getcharc:
00CC3F  2  20 7C CB             JSR     getchar         ;get from buffer
00CC42  2               ;
00CC42  2               ;================================================================================
00CC42  2               ;
00CC42  2               ;toupper: FORCE CHARACTER TO UPPER CASE
00CC42  2               ;
00CC42  2               ;	------------------------------------------------
00CC42  2               ;	Preparatory Ops : .A: 8 bit character to convert
00CC42  2               ;
00CC42  2               ;	Register Returns: .A: converted character
00CC42  2               ;	                  .B: entry value
00CC42  2               ;	                  .X: entry value
00CC42  2               ;	                  .Y: entry value
00CC42  2               ;
00CC42  2               ;	MPU Flags: no change
00CC42  2               ;
00CC42  2               ;	Notes: 1) This subroutine has no effect on char-
00CC42  2               ;	          acters that are not alpha.
00CC42  2               ;	------------------------------------------------
00CC42  2               ;
00CC42  2               toupper:
00CC42  2  08                   PHP                     ;protect flags
00CC43  2  C9 61                CMP     #a_asclcl       ;check char range
00CC45  2  90 06                BCC     _0480010        ;not LC alpha
00CC47  2               ;
00CC47  2  C9 7B                CMP     #a_asclch+s_byte
00CC49  2  B0 02                BCS     _0480010        ;not LC alpha
00CC4B  2               ;
00CC4B  2  29 5F                AND     #a_lctouc       ;force to UC
00CC4D  2               ;
00CC4D  2               _0480010:
00CC4D  2  28                   PLP                     ;restore flags
00CC4E  2               ;
00CC4E  2               touppera:
00CC4E  2  60                   RTS
00CC4F  2               ;
00CC4F  2               ;================================================================================
00CC4F  2               ;
00CC4F  2               ;teststop: TEST FOR STOP KEY
00CC4F  2               ;
00CC4F  2               ;	----------------------------------------------
00CC4F  2               ;	Preparatory Ops: none
00CC4F  2               ;
00CC4F  2               ;	Returned Values: .A: detected keypress, if any
00CC4F  2               ;	                 .X: entry value
00CC4F  2               ;	                 .Y: entry value
00CC4F  2               ;
00CC4F  2               ;	MPU Flags: NVmxDIZC
00CC4F  2               ;	           ||||||||
00CC4F  2               ;	           |||||||+---> 0: normal key detected
00CC4F  2               ;	           |||||||      1: <STOP> detected
00CC4F  2               ;	           +++++++----> not defined
00CC4F  2               ;
00CC4F  2               ;	Example: jsr teststop
00CC4F  2               ;	         bcs stopped
00CC4F  2               ;
00CC4F  2               ;	Notes: The symbol STOPKEY defines the ASCII
00CC4F  2               ;	       value of the "stop key."
00CC4F  2               ;	----------------------------------------------
00CC4F  2               ;
00CC4F  2               teststop:
00CC4F  2  20 74 FF             JSR     getcha          ;poll console
00CC52  2  B0 04                BCS     _0490010        ;no input
00CC54  2               ;
00CC54  2  C9 03                CMP     #stopkey        ;stop key pressed?
00CC56  2  F0 01                BEQ     _0490020        ;yes
00CC58  2               ;
00CC58  2               _0490010:
00CC58  2  18                   CLC
00CC59  2               ;
00CC59  2               _0490020:
00CC59  2  60                   RTS
00CC5A  2               
00CC5A  2               
00CC5A  2               ;__LOAD_________________________________________________________
00CC5A  2               ; LOAD A MOTOROLA FORMATTED HEX FILE (S28)
00CC5A  2               ;
00CC5A  2               ;_______________________________________________________________
00CC5A  2               LOADS19:
00CC5A  2  08                   PHP
00CC5B  2  E2 30                SHORTR
00CC5D  2  F4 BF D0             PEA     mm_S19_prmpt
00CC60  2  20 DC C7             JSR     sprint          ;display input prompt
00CC63  2               
00CC63  2               
00CC63  2               LOADS19_1:
00CC63  2  20 E1 CC             JSR     getc            ;
00CC66  2  C9 53                CMP     #'S'            ;
00CC68  2  D0 F9                BNE     LOADS19_1       ; FIRST CHAR NOT (S)
00CC6A  2  20 E1 CC             JSR     getc            ; READ CHAR
00CC6D  2  C9 38                CMP     #'8'            ;
00CC6F  2  F0 44                BEQ     LOAD21          ;
00CC71  2  C9 32                CMP     #'2'            ;
00CC73  2  D0 EE                BNE     LOADS19_1       ; SECOND CHAR NOT (2)
00CC75  2  A9 00                LDA     #$00            ;
00CC77  2  85 25                STA     faca            ; ZERO CHECKSUM
00CC79  2               
00CC79  2  20 B9 CC             JSR     GETBYTE         ; READ BYTE
00CC7C  2  E9 02                SBC     #$02            ;
00CC7E  2  85 2D                STA     facb            ; BYTE COUNT
00CC80  2               ; BUILD ADDRESS
00CC80  2  20 B9 CC             JSR     GETBYTE         ; READ 2 FRAMES
00CC83  2  85 21                STA     addra+2         ;
00CC85  2  20 B9 CC             JSR     GETBYTE         ; READ 2 FRAMES
00CC88  2  85 20                STA     addra+1         ;
00CC8A  2  20 B9 CC             JSR     GETBYTE         ;
00CC8D  2  85 1F                STA     addra           ;
00CC8F  2               
00CC8F  2  A0 00                LDY     #$00            ;
00CC91  2               LOAD11:
00CC91  2  20 B9 CC             JSR     GETBYTE         ;
00CC94  2  C6 2D                DEC     facb            ;
00CC96  2  F0 14                BEQ     LOAD15          ; ZERO BYTE COUNT
00CC98  2  97 1F                STA     [addra],Y       ; STORE DATA
00CC9A  2  C2 20                SLONGA
00CC9C  2  E6 1F                INC     addra           ;
00CC9E  2  C9 00 00             CMPW    $0000
00CCA1  2  D0 04                BNE     LOAD11A
00CCA3  2  E2 20                SHORTA
00CCA5  2  E6 21                INC     addra+2         ;
00CCA7  2               LOAD11A:
00CCA7  2  E2 20                SHORTA
00CCA9  2  4C 91 CC             JMP     LOAD11          ;
00CCAC  2               
00CCAC  2               LOAD15:
00CCAC  2  E6 25                INC     faca            ;
00CCAE  2  F0 B3                BEQ     LOADS19_1       ;
00CCB0  2               LOAD19:
00CCB0  2  A9 3F                LDA     #'?'            ;
00CCB2  2  20 71 FF             JSR     putcha          ;
00CCB5  2               LOAD21:
00CCB5  2  28                   PLP
00CCB6  2  4C 3B C1             JMP     monce           ;back to executive
00CCB9  2               GETBYTE:
00CCB9  2  20 D1 CC             JSR     INHEX           ; GET HEX CHAR
00CCBC  2  0A                   ASL     A               ;
00CCBD  2  0A                   ASL     A               ;
00CCBE  2  0A                   ASL     A               ;
00CCBF  2  0A                   ASL     A               ;
00CCC0  2  85 3F                STA     numeral         ;
00CCC2  2  20 D1 CC             JSR     INHEX           ;
00CCC5  2  29 0F                AND     #$0F            ; MASK TO 4 BITS
00CCC7  2  05 3F                ORA     numeral         ;
00CCC9  2  48                   PHA                     ;
00CCCA  2  18                   CLC                     ;
00CCCB  2  65 25                ADC     faca            ;
00CCCD  2  85 25                STA     faca            ;
00CCCF  2  68                   PLA                     ;
00CCD0  2  60                   RTS                     ;
00CCD1  2               ; INPUT HEX CHAR
00CCD1  2               INHEX:
00CCD1  2  20 E1 CC             JSR     getc            ;
00CCD4  2  C9 3A                CMP     #$3A            ; LESS THAN 9?
00CCD6  2  B0 02                BCS     INHEX_BIG       ; NO, SKIP NEXT
00CCD8  2  E9 2F                SBC     #$2F            ; CONVERT 0-9
00CCDA  2               INHEX_BIG:
00CCDA  2  C9 41                CMP     #$41            ; A OR MORE?
00CCDC  2  90 02                BCC     INHEX_SMALL     ; NO, SKIP NEXT
00CCDE  2  E9 37                SBC     #$37            ; CONVERT A-F
00CCE0  2               INHEX_SMALL:
00CCE0  2  60                   RTS                     ;
00CCE1  2               getc:
00CCE1  2  20 74 FF             JSR     getcha          ;poll for input
00CCE4  2  90 02                BCC     getcd           ;got something
00CCE6  2  80 F9                BRA     getc            ;try again
00CCE8  2               getcd:
00CCE8  2  48                   PHA                     ;
00CCE9  2  20 71 FF             JSR     putcha          ;
00CCEC  2  68                   PLA                     ;
00CCED  2  60                   RTS
00CCEE  2               
00CCEE  2               
00CCEE  2               
00CCEE  2               ;
00CCEE  2               ;cpcode: COPY MEMORY CODE
00CCEE  2               ;
00CCEE  2               ;	-------------------------------------------
00CCEE  2               ;	This code is transfered to workspace when a
00CCEE  2               ;	copy or fill operation is to be performed.
00CCEE  2               ;	-------------------------------------------
00CCEE  2               ;
00CCEE  2               cpcode:
00CCEE  2  8B                   PHB                     ;must preserve data bank
00CCEF  2               ;.rept s_mvinst
00CCEF  2  EA                   NOP                     ;placeholder
00CCF0  2  EA                   NOP                     ;placeholder
00CCF1  2  EA                   NOP                     ;placeholder
00CCF2  2               ;.endr
00CCF2  2  AB                   PLB                     ;restore data bank
00CCF3  2  5C 3B C1 00          JML     monce           ;return to command executive
00CCF7  2               cpcodeee:                       ;placeholder - do not delete
00CCF7  2               copylen         = cpcodeee-cpcode-1
00CCF7  2               ;
00CCF7  2               ;================================================================================
00CCF7  2               ;
00CCF7  2               ;COMMAND PROCESSING DATA TABLES
00CCF7  2               ;
00CCF7  2               ;
00CCF7  2               ;	monitor commands...
00CCF7  2               ;
00CCF7  2               mpctab:
00CCF7  2  41                   .BYTE   "A"             ;assemble code
00CCF8  2  43                   .BYTE   "C"             ;compare memory ranges
00CCF9  2  44                   .BYTE   "D"             ;disassemble code
00CCFA  2  46                   .BYTE   "F"             ;fill memory
00CCFB  2  47                   .BYTE   "G"             ;execute code
00CCFC  2  48                   .BYTE   "H"             ;search memory
00CCFD  2  4A                   .BYTE   "J"             ;execute code as subroutine
00CCFE  2  4C                   .BYTE   "L"             ;load S19 file
00CCFF  2  4D                   .BYTE   "M"             ;dump memory range
00CD00  2  52                   .BYTE   "R"             ;dump registers
00CD01  2  54                   .BYTE   "T"             ;copy memory range
00CD02  2               ;         .BYTE "X"             ;exit from monitor
00CD02  2  3E                   .BYTE   ">"             ;change memory
00CD03  2  3B                   .BYTE   ";"             ;change registers
00CD04  2               n_mpctab        = *-mpctab      ;entries in above table
00CD04  2               ;
00CD04  2               ;
00CD04  2               ;	monitor command jump table...
00CD04  2               ;
00CD04  2               mpcextab:
00CD04  2  80 C1                .WORD   monasc-s_byte   ; A  assemble code
00CD06  2  42 C4                .WORD   moncmp-s_byte   ; C  compare memory ranges
00CD08  2  5C C3                .WORD   mondsc-s_byte   ; D  disassemble code
00CD0A  2  13 C5                .WORD   monfil-s_byte   ; F  fill memory
00CD0C  2  B0 C3                .WORD   monjmp-s_byte   ; G  execute code
00CD0E  2  79 C5                .WORD   monhnt-s_byte   ; H  search memory
00CD10  2  E1 C3                .WORD   monjsr-s_byte   ; J  execute code as subroutine
00CD12  2  59 CC                .WORD   LOADS19-s_byte  ; L  Load S19 File
00CD14  2  C1 C4                .WORD   mondmp-s_byte   ; M  dump memory range
00CD16  2  DC C0                .WORD   monreg-s_byte   ; R  dump registers
00CD18  2  70 C4                .WORD   moncpy-s_byte   ; T  copy memory range
00CD1A  2               ;         .WORD monxit-s_byte   ; X  exit from monitor
00CD1A  2  17 C4                .WORD   monchm-s_byte   ; >  change memory
00CD1C  2  EF C5                .WORD   monchr-s_byte   ; ;  change registers
00CD1E  2               ;
00CD1E  2               ;
00CD1E  2               ;	number conversion...
00CD1E  2               ;
00CD1E  2               basetab:
00CD1E  2  10 0A 08 02          .BYTE   16,10,8,2       ;supported number bases
00CD22  2               bitsdtab:
00CD22  2  04 03 03 01          .BYTE   4,3,3,1         ;bits per binary digit
00CD26  2               bitsntab:
00CD26  2  04 04 03 01          .BYTE   4,4,3,1         ;bits per ASCII character
00CD2A  2               lzsttab:
00CD2A  2  03 02 09 02          .BYTE   3,2,9,2         ;leading zero suppression thresholds
00CD2E  2               numstab:
00CD2E  2  0C 0C 10 30          .BYTE   12,12,16,48     ;bin to ASCII conversion numerals
00CD32  2               radxtab:
00CD32  2  24                   .BYTE   c_hex           ;hexadecimal radix
00CD33  2  2B                   .BYTE   c_dec           ;decimal radix
00CD34  2  40                   .BYTE   c_oct           ;octal radix
00CD35  2  25                   .BYTE   c_bin           ;binary radix
00CD36  2               n_radix         = *-radxtab     ;number of recognized radices
00CD36  2               ;
00CD36  2               ;
00CD36  2               ;	shadow MPU register sizes...
00CD36  2               ;
00CD36  2               rcvltab:
00CD36  2  02                   .BYTE   s_mpupbx+s_byte ; PB
00CD37  2  03                   .BYTE   s_mpupcx+s_byte ; PC
00CD38  2  02                   .BYTE   s_mpusrx+s_byte ; SR
00CD39  2  03                   .BYTE   s_word+s_byte   ; .C
00CD3A  2  03                   .BYTE   s_word+s_byte   ; .X
00CD3B  2  03                   .BYTE   s_word+s_byte   ; .Y
00CD3C  2  03                   .BYTE   s_mpuspx+s_byte ; SP
00CD3D  2  03                   .BYTE   s_mpudpx+s_byte ; DP
00CD3E  2  02                   .BYTE   s_mpudbx+s_byte ; DB
00CD3F  2               n_regchv        = *-rcvltab     ;total shadow registers
00CD3F  2               ;
00CD3F  2               ;================================================================================
00CD3F  2               ;
00CD3F  2               ;ASSEMBLER/DISASSEMBLER DATA TABLES
00CD3F  2               ;
00CD3F  2               ;
00CD3F  2               ;	numerically sorted & encoded W65C816S mnemonics...
00CD3F  2               ;
00CD3F  2               mnetab:
00CD3F  2  F2 10                .WORD   mne_xba         ;  0 - XBA
00CD41  2  5A 11                .WORD   mne_lda         ;  1 - LDA
00CD43  2  A2 11                .WORD   mne_pea         ;  2 - PEA
00CD45  2  62 12                .WORD   mne_pha         ;  3 - PHA
00CD47  2  62 13                .WORD   mne_pla         ;  4 - PLA
00CD49  2  C6 14                .WORD   mne_bra         ;  5 - BRA
00CD4B  2  E0 14                .WORD   mne_ora         ;  6 - ORA
00CD4D  2  68 15                .WORD   mne_sta         ;  7 - STA
00CD4F  2  6A 16                .WORD   mne_txa         ;  8 - TXA
00CD51  2  AA 16                .WORD   mne_tya         ;  9 - TYA
00CD53  2  62 1A                .WORD   mne_phb         ; 10 - PHB
00CD55  2  62 1B                .WORD   mne_plb         ; 11 - PLB
00CD57  2  EA 1C                .WORD   mne_trb         ; 12 - TRB
00CD59  2  2A 1D                .WORD   mne_tsb         ; 13 - TSB
00CD5B  2  E8 20                .WORD   mne_sbc         ; 14 - SBC
00CD5D  2  06 21                .WORD   mne_bcc         ; 15 - BCC
00CD5F  2  44 21                .WORD   mne_adc         ; 16 - ADC
00CD61  2  6A 21                .WORD   mne_tdc         ; 17 - TDC
00CD63  2  8A 21                .WORD   mne_dec         ; 18 - DEC
00CD65  2  A8 21                .WORD   mne_sec         ; 19 - SEC
00CD67  2  48 23                .WORD   mne_clc         ; 20 - CLC
00CD69  2  D4 23                .WORD   mne_inc         ; 21 - INC
00CD6B  2  2A 25                .WORD   mne_tsc         ; 22 - TSC
00CD6D  2  C6 25                .WORD   mne_bvc         ; 23 - BVC
00CD6F  2  2A 29                .WORD   mne_tcd         ; 24 - TCD
00CD71  2  A8 29                .WORD   mne_sed         ; 25 - SED
00CD73  2  62 2A                .WORD   mne_phd         ; 26 - PHD
00CD75  2  48 2B                .WORD   mne_cld         ; 27 - CLD
00CD77  2  62 2B                .WORD   mne_pld         ; 28 - PLD
00CD79  2  C4 2B                .WORD   mne_and         ; 29 - AND
00CD7B  2  32 31                .WORD   mne_xce         ; 30 - XCE
00CD7D  2  C6 33                .WORD   mne_bne         ; 31 - BNE
00CD7F  2  B0 50                .WORD   mne_wai         ; 32 - WAI
00CD81  2  A2 51                .WORD   mne_pei         ; 33 - PEI
00CD83  2  A8 51                .WORD   mne_sei         ; 34 - SEI
00CD85  2  48 53                .WORD   mne_cli         ; 35 - CLI
00CD87  2  86 53                .WORD   mne_bmi         ; 36 - BMI
00CD89  2  66 55                .WORD   mne_rti         ; 37 - RTI
00CD8B  2  62 62                .WORD   mne_phk         ; 38 - PHK
00CD8D  2  C6 64                .WORD   mne_brk         ; 39 - BRK
00CD8F  2  96 6B                .WORD   mne_jml         ; 40 - JML
00CD91  2  26 6C                .WORD   mne_rol         ; 41 - ROL
00CD93  2  46 6C                .WORD   mne_bpl         ; 42 - BPL
00CD95  2  C6 6C                .WORD   mne_brl         ; 43 - BRL
00CD97  2  04 6D                .WORD   mne_asl         ; 44 - ASL
00CD99  2  16 6D                .WORD   mne_jsl         ; 45 - JSL
00CD9B  2  66 6D                .WORD   mne_rtl         ; 46 - RTL
00CD9D  2  70 71                .WORD   mne_wdm         ; 47 - WDM
00CD9F  2  DC 7D                .WORD   mne_mvn         ; 48 - MVN
00CDA1  2  A6 89                .WORD   mne_rep         ; 49 - REP
00CDA3  2  A8 89                .WORD   mne_sep         ; 50 - SEP
00CDA5  2  62 8A                .WORD   mne_php         ; 51 - PHP
00CDA7  2  62 8B                .WORD   mne_plp         ; 52 - PLP
00CDA9  2  88 8B                .WORD   mne_cmp         ; 53 - CMP
00CDAB  2  96 8B                .WORD   mne_jmp         ; 54 - JMP
00CDAD  2  08 8C                .WORD   mne_cop         ; 55 - COP
00CDAF  2  1E 8C                .WORD   mne_nop         ; 56 - NOP
00CDB1  2  68 8D                .WORD   mne_stp         ; 57 - STP
00CDB3  2  DC 8D                .WORD   mne_mvp         ; 58 - MVP
00CDB5  2  86 91                .WORD   mne_beq         ; 59 - BEQ
00CDB7  2  A2 99                .WORD   mne_per         ; 60 - PER
00CDB9  2  0C 9C                .WORD   mne_eor         ; 61 - EOR
00CDBB  2  26 9C                .WORD   mne_ror         ; 62 - ROR
00CDBD  2  16 9D                .WORD   mne_jsr         ; 63 - JSR
00CDBF  2  1A 9D                .WORD   mne_lsr         ; 64 - LSR
00CDC1  2  06 A1                .WORD   mne_bcs         ; 65 - BCS
00CDC3  2  2A A1                .WORD   mne_tcs         ; 66 - TCS
00CDC5  2  66 A5                .WORD   mne_rts         ; 67 - RTS
00CDC7  2  C6 A5                .WORD   mne_bvs         ; 68 - BVS
00CDC9  2  6A A6                .WORD   mne_txs         ; 69 - TXS
00CDCB  2  86 AA                .WORD   mne_bit         ; 70 - BIT
00CDCD  2  48 BB                .WORD   mne_clv         ; 71 - CLV
00CDCF  2  AA C8                .WORD   mne_tax         ; 72 - TAX
00CDD1  2  5A C9                .WORD   mne_ldx         ; 73 - LDX
00CDD3  2  8A C9                .WORD   mne_dex         ; 74 - DEX
00CDD5  2  62 CA                .WORD   mne_phx         ; 75 - PHX
00CDD7  2  62 CB                .WORD   mne_plx         ; 76 - PLX
00CDD9  2  D4 CB                .WORD   mne_inx         ; 77 - INX
00CDDB  2  48 CC                .WORD   mne_cpx         ; 78 - CPX
00CDDD  2  2A CD                .WORD   mne_tsx         ; 79 - TSX
00CDDF  2  68 CD                .WORD   mne_stx         ; 80 - STX
00CDE1  2  AA CE                .WORD   mne_tyx         ; 81 - TYX
00CDE3  2  AA D0                .WORD   mne_tay         ; 82 - TAY
00CDE5  2  5A D1                .WORD   mne_ldy         ; 83 - LDY
00CDE7  2  8A D1                .WORD   mne_dey         ; 84 - DEY
00CDE9  2  62 D2                .WORD   mne_phy         ; 85 - PHY
00CDEB  2  62 D3                .WORD   mne_ply         ; 86 - PLY
00CDED  2  D4 D3                .WORD   mne_iny         ; 87 - INY
00CDEF  2  48 D4                .WORD   mne_cpy         ; 88 - CPY
00CDF1  2  68 D5                .WORD   mne_sty         ; 89 - STY
00CDF3  2  6A D6                .WORD   mne_txy         ; 90 - TXY
00CDF5  2  68 DD                .WORD   mne_stz         ; 91 - STZ
00CDF7  2               ;
00CDF7  2               s_mnetab        = *-mnetab      ;mnemonic table size
00CDF7  2               n_mnemon        = s_mnetab/s_word;total mnemonics
00CDF7  2               ;
00CDF7  2               ;
00CDF7  2               ;	mnemonic lookup indices in opcode order...
00CDF7  2               ;
00CDF7  2               mnetabix:
00CDF7  2  27                   .BYTE   mne_brkx        ; $00  BRK
00CDF8  2  06                   .BYTE   mne_orax        ; $01  ORA (dp,X)
00CDF9  2  37                   .BYTE   mne_copx        ; $02  COP
00CDFA  2  06                   .BYTE   mne_orax        ; $03  ORA <offset>,S
00CDFB  2  0D                   .BYTE   mne_tsbx        ; $04  TSB dp
00CDFC  2  06                   .BYTE   mne_orax        ; $05  ORA dp
00CDFD  2  2C                   .BYTE   mne_aslx        ; $06  ASL dp
00CDFE  2  06                   .BYTE   mne_orax        ; $07  ORA [dp]
00CDFF  2  33                   .BYTE   mne_phpx        ; $08  PHP
00CE00  2  06                   .BYTE   mne_orax        ; $09  ORA #
00CE01  2  2C                   .BYTE   mne_aslx        ; $0A  ASL A
00CE02  2  1A                   .BYTE   mne_phdx        ; $0B  PHD
00CE03  2  0D                   .BYTE   mne_tsbx        ; $0C  TSB abs
00CE04  2  06                   .BYTE   mne_orax        ; $0D  ORA abs
00CE05  2  2C                   .BYTE   mne_aslx        ; $0E  ASL abs
00CE06  2  06                   .BYTE   mne_orax        ; $0F  ORA absl
00CE07  2               ;
00CE07  2  2A                   .BYTE   mne_bplx        ; $10  BPL abs
00CE08  2  06                   .BYTE   mne_orax        ; $11  ORA (<dp>),Y
00CE09  2  06                   .BYTE   mne_orax        ; $12  ORA (dp)
00CE0A  2  06                   .BYTE   mne_orax        ; $13  ORA (<offset>,S),Y
00CE0B  2  0C                   .BYTE   mne_trbx        ; $14  TRB dp
00CE0C  2  06                   .BYTE   mne_orax        ; $15  ORA dp,X
00CE0D  2  2C                   .BYTE   mne_aslx        ; $16  ASL dp,X
00CE0E  2  06                   .BYTE   mne_orax        ; $17  ORA [dp],Y
00CE0F  2  14                   .BYTE   mne_clcx        ; $18  CLC
00CE10  2  06                   .BYTE   mne_orax        ; $19  ORA abs
00CE11  2  15                   .BYTE   mne_incx        ; $1A  INC A
00CE12  2  42                   .BYTE   mne_tcsx        ; $1B  TCS
00CE13  2  0C                   .BYTE   mne_trbx        ; $1C  TRB abs
00CE14  2  06                   .BYTE   mne_orax        ; $1D  ORA abs,X
00CE15  2  2C                   .BYTE   mne_aslx        ; $1E  ASL abs,X
00CE16  2  06                   .BYTE   mne_orax        ; $1F  ORA absl,X
00CE17  2               ;
00CE17  2  3F                   .BYTE   mne_jsrx        ; $20  JSR abs
00CE18  2  1D                   .BYTE   mne_andx        ; $21  AND (dp,X)
00CE19  2  2D                   .BYTE   mne_jslx        ; $22  JSL absl
00CE1A  2  1D                   .BYTE   mne_andx        ; $23  AND <offset>,S
00CE1B  2  46                   .BYTE   mne_bitx        ; $24  BIT dp
00CE1C  2  1D                   .BYTE   mne_andx        ; $25  AND dp
00CE1D  2  29                   .BYTE   mne_rolx        ; $26  ROL dp
00CE1E  2  1D                   .BYTE   mne_andx        ; $27  AND [dp]
00CE1F  2  34                   .BYTE   mne_plpx        ; $28  PLP
00CE20  2  1D                   .BYTE   mne_andx        ; $29  AND #
00CE21  2  29                   .BYTE   mne_rolx        ; $2A  ROL A
00CE22  2  1C                   .BYTE   mne_pldx        ; $2B  PLD
00CE23  2  46                   .BYTE   mne_bitx        ; $2C  BIT abs
00CE24  2  1D                   .BYTE   mne_andx        ; $2D  AND abs
00CE25  2  29                   .BYTE   mne_rolx        ; $2E  ROL abs
00CE26  2  1D                   .BYTE   mne_andx        ; $2F  AND absl
00CE27  2               ;
00CE27  2  24                   .BYTE   mne_bmix        ; $30  BMI abs
00CE28  2  1D                   .BYTE   mne_andx        ; $31  AND (<dp>),Y
00CE29  2  1D                   .BYTE   mne_andx        ; $32  AND (dp)
00CE2A  2  1D                   .BYTE   mne_andx        ; $33  AND (<offset>,S),Y
00CE2B  2  46                   .BYTE   mne_bitx        ; $34  BIT dp,X
00CE2C  2  1D                   .BYTE   mne_andx        ; $35  AND dp,X
00CE2D  2  29                   .BYTE   mne_rolx        ; $36  ROL dp,X
00CE2E  2  1D                   .BYTE   mne_andx        ; $37  AND [dp],Y
00CE2F  2  13                   .BYTE   mne_secx        ; $38  SEC
00CE30  2  1D                   .BYTE   mne_andx        ; $39  AND abs,Y
00CE31  2  12                   .BYTE   mne_decx        ; $3A  DEC A
00CE32  2  16                   .BYTE   mne_tscx        ; $3B  TSC
00CE33  2  46                   .BYTE   mne_bitx        ; $3C  BIT abs,X
00CE34  2  1D                   .BYTE   mne_andx        ; $3D  AND abs,X
00CE35  2  29                   .BYTE   mne_rolx        ; $3E  ROL abs,X
00CE36  2  1D                   .BYTE   mne_andx        ; $3F  AND absl,X
00CE37  2               ;
00CE37  2  25                   .BYTE   mne_rtix        ; $40  RTI
00CE38  2  3D                   .BYTE   mne_eorx        ; $41  EOR (dp,X)
00CE39  2  2F                   .BYTE   mne_wdmx        ; $42  WDM
00CE3A  2  3D                   .BYTE   mne_eorx        ; $43  EOR <offset>,S
00CE3B  2  3A                   .BYTE   mne_mvpx        ; $44  MVP sb,db
00CE3C  2  3D                   .BYTE   mne_eorx        ; $45  EOR dp
00CE3D  2  40                   .BYTE   mne_lsrx        ; $46  LSR dp
00CE3E  2  3D                   .BYTE   mne_eorx        ; $47  EOR [dp]
00CE3F  2  03                   .BYTE   mne_phax        ; $48  PHA
00CE40  2  3D                   .BYTE   mne_eorx        ; $49  EOR #
00CE41  2  40                   .BYTE   mne_lsrx        ; $4A  LSR A
00CE42  2  26                   .BYTE   mne_phkx        ; $4B  PHK
00CE43  2  36                   .BYTE   mne_jmpx        ; $4C  JMP abs
00CE44  2  3D                   .BYTE   mne_eorx        ; $4D  EOR abs
00CE45  2  40                   .BYTE   mne_lsrx        ; $4E  LSR abs
00CE46  2  3D                   .BYTE   mne_eorx        ; $4F  EOR absl
00CE47  2               ;
00CE47  2  17                   .BYTE   mne_bvcx        ; $50  BVC abs
00CE48  2  3D                   .BYTE   mne_eorx        ; $51  EOR (<dp>),Y
00CE49  2  3D                   .BYTE   mne_eorx        ; $52  EOR (dp)
00CE4A  2  3D                   .BYTE   mne_eorx        ; $53  EOR (<offset>,S),Y
00CE4B  2  30                   .BYTE   mne_mvnx        ; $54  MVN sb,db
00CE4C  2  3D                   .BYTE   mne_eorx        ; $55  EOR dp,X
00CE4D  2  40                   .BYTE   mne_lsrx        ; $56  LSR dp,X
00CE4E  2  3D                   .BYTE   mne_eorx        ; $57  EOR [dp],Y
00CE4F  2  23                   .BYTE   mne_clix        ; $58  CLI
00CE50  2  3D                   .BYTE   mne_eorx        ; $59  EOR abs,Y
00CE51  2  55                   .BYTE   mne_phyx        ; $5A  PHY
00CE52  2  18                   .BYTE   mne_tcdx        ; $5B  TCD
00CE53  2  28                   .BYTE   mne_jmlx        ; $5C  JML absl
00CE54  2  3D                   .BYTE   mne_eorx        ; $5D  EOR abs,X
00CE55  2  40                   .BYTE   mne_lsrx        ; $5E  LSR abs,X
00CE56  2  3D                   .BYTE   mne_eorx        ; $5F  EOR absl,X
00CE57  2               ;
00CE57  2  43                   .BYTE   mne_rtsx        ; $60  RTS
00CE58  2  10                   .BYTE   mne_adcx        ; $61  ADC (dp,X)
00CE59  2  3C                   .BYTE   mne_perx        ; $62  PER
00CE5A  2  10                   .BYTE   mne_adcx        ; $63  ADC <offset>,S
00CE5B  2  5B                   .BYTE   mne_stzx        ; $64  STZ dp
00CE5C  2  10                   .BYTE   mne_adcx        ; $65  ADC dp
00CE5D  2  3E                   .BYTE   mne_rorx        ; $66  ROR dp
00CE5E  2  10                   .BYTE   mne_adcx        ; $67  ADC [dp]
00CE5F  2  04                   .BYTE   mne_plax        ; $68  PLA
00CE60  2  10                   .BYTE   mne_adcx        ; $69  ADC #
00CE61  2  3E                   .BYTE   mne_rorx        ; $6A  ROR A
00CE62  2  2E                   .BYTE   mne_rtlx        ; $6B  RTL
00CE63  2  36                   .BYTE   mne_jmpx        ; $6C  JMP (abs)
00CE64  2  10                   .BYTE   mne_adcx        ; $6D  ADC abs
00CE65  2  3E                   .BYTE   mne_rorx        ; $6E  ROR abs
00CE66  2  10                   .BYTE   mne_adcx        ; $6F  ADC absl
00CE67  2               ;
00CE67  2  44                   .BYTE   mne_bvsx        ; $70  BVS abs
00CE68  2  10                   .BYTE   mne_adcx        ; $71  ADC (<dp>),Y
00CE69  2  10                   .BYTE   mne_adcx        ; $72  ADC (dp)
00CE6A  2  10                   .BYTE   mne_adcx        ; $73  ADC (<offset>,S),Y
00CE6B  2  5B                   .BYTE   mne_stzx        ; $74  STZ dp,X
00CE6C  2  10                   .BYTE   mne_adcx        ; $75  ADC dp,X
00CE6D  2  3E                   .BYTE   mne_rorx        ; $76  ROR dp,X
00CE6E  2  10                   .BYTE   mne_adcx        ; $77  ADC [dp],Y
00CE6F  2  22                   .BYTE   mne_seix        ; $78  SEI
00CE70  2  10                   .BYTE   mne_adcx        ; $79  ADC abs,Y
00CE71  2  56                   .BYTE   mne_plyx        ; $7A  PLY
00CE72  2  11                   .BYTE   mne_tdcx        ; $7B  TDC
00CE73  2  36                   .BYTE   mne_jmpx        ; $7C  JMP (abs,X)
00CE74  2  10                   .BYTE   mne_adcx        ; $7D  ADC abs,X
00CE75  2  3E                   .BYTE   mne_rorx        ; $7E  ROR abs,X
00CE76  2  10                   .BYTE   mne_adcx        ; $7F  ADC absl,X
00CE77  2               ;
00CE77  2  05                   .BYTE   mne_brax        ; $80  BRA abs
00CE78  2  07                   .BYTE   mne_stax        ; $81  STA (dp,X)
00CE79  2  2B                   .BYTE   mne_brlx        ; $82  BRL abs
00CE7A  2  07                   .BYTE   mne_stax        ; $83  STA <offset>,S
00CE7B  2  59                   .BYTE   mne_styx        ; $84  STY dp
00CE7C  2  07                   .BYTE   mne_stax        ; $85  STA dp
00CE7D  2  50                   .BYTE   mne_stxx        ; $86  STX dp
00CE7E  2  07                   .BYTE   mne_stax        ; $87  STA [dp]
00CE7F  2  54                   .BYTE   mne_deyx        ; $88  DEY
00CE80  2  46                   .BYTE   mne_bitx        ; $89  BIT #
00CE81  2  08                   .BYTE   mne_txax        ; $8A  TXA
00CE82  2  0A                   .BYTE   mne_phbx        ; $8B  PHB
00CE83  2  59                   .BYTE   mne_styx        ; $8C  STY abs
00CE84  2  07                   .BYTE   mne_stax        ; $8D  STA abs
00CE85  2  50                   .BYTE   mne_stxx        ; $8E  STX abs
00CE86  2  07                   .BYTE   mne_stax        ; $8F  STA absl
00CE87  2               ;
00CE87  2  0F                   .BYTE   mne_bccx        ; $90  BCC abs
00CE88  2  07                   .BYTE   mne_stax        ; $91  STA (<dp>),Y
00CE89  2  07                   .BYTE   mne_stax        ; $92  STA (dp)
00CE8A  2  07                   .BYTE   mne_stax        ; $93  STA (<offset>,S),Y
00CE8B  2  59                   .BYTE   mne_styx        ; $94  STY dp,X
00CE8C  2  07                   .BYTE   mne_stax        ; $95  STA dp,X
00CE8D  2  50                   .BYTE   mne_stxx        ; $96  STX dp,Y
00CE8E  2  07                   .BYTE   mne_stax        ; $97  STA [dp],Y
00CE8F  2  09                   .BYTE   mne_tyax        ; $98  TYA
00CE90  2  07                   .BYTE   mne_stax        ; $99  STA abs,Y
00CE91  2  45                   .BYTE   mne_txsx        ; $9A  TXS
00CE92  2  5A                   .BYTE   mne_txyx        ; $9B  TXY
00CE93  2  5B                   .BYTE   mne_stzx        ; $9C  STZ abs
00CE94  2  07                   .BYTE   mne_stax        ; $9D  STA abs,X
00CE95  2  5B                   .BYTE   mne_stzx        ; $9E  STZ abs,X
00CE96  2  07                   .BYTE   mne_stax        ; $9F  STA absl,X
00CE97  2               ;
00CE97  2  53                   .BYTE   mne_ldyx        ; $A0  LDY #
00CE98  2  01                   .BYTE   mne_ldax        ; $A1  LDA (dp,X)
00CE99  2  49                   .BYTE   mne_ldxx        ; $A2  LDX #
00CE9A  2  01                   .BYTE   mne_ldax        ; $A3  LDA <offset>,S
00CE9B  2  53                   .BYTE   mne_ldyx        ; $A4  LDY dp
00CE9C  2  01                   .BYTE   mne_ldax        ; $A5  LDA dp
00CE9D  2  49                   .BYTE   mne_ldxx        ; $A6  LDX dp
00CE9E  2  01                   .BYTE   mne_ldax        ; $A7  LDA [dp]
00CE9F  2  52                   .BYTE   mne_tayx        ; $A8  TAY
00CEA0  2  01                   .BYTE   mne_ldax        ; $A9  LDA #
00CEA1  2  48                   .BYTE   mne_taxx        ; $AA  TAX
00CEA2  2  0B                   .BYTE   mne_plbx        ; $AB  PLB
00CEA3  2  53                   .BYTE   mne_ldyx        ; $AC  LDY abs
00CEA4  2  01                   .BYTE   mne_ldax        ; $AD  LDA abs
00CEA5  2  49                   .BYTE   mne_ldxx        ; $AE  LDX abs
00CEA6  2  01                   .BYTE   mne_ldax        ; $AF  LDA absl
00CEA7  2               ;
00CEA7  2  41                   .BYTE   mne_bcsx        ; $B0  BCS abs
00CEA8  2  01                   .BYTE   mne_ldax        ; $B1  LDA (<dp>),Y
00CEA9  2  01                   .BYTE   mne_ldax        ; $B2  LDA (dp)
00CEAA  2  01                   .BYTE   mne_ldax        ; $B3  LDA (<offset>,S),Y
00CEAB  2  53                   .BYTE   mne_ldyx        ; $B4  LDY dp,X
00CEAC  2  01                   .BYTE   mne_ldax        ; $B5  LDA dp,X
00CEAD  2  49                   .BYTE   mne_ldxx        ; $B6  LDX dp,Y
00CEAE  2  01                   .BYTE   mne_ldax        ; $B7  LDA [dp],Y
00CEAF  2  47                   .BYTE   mne_clvx        ; $B8  CLV
00CEB0  2  01                   .BYTE   mne_ldax        ; $B9  LDA abs,Y
00CEB1  2  4F                   .BYTE   mne_tsxx        ; $BA  TSX
00CEB2  2  51                   .BYTE   mne_tyxx        ; $BB  TYX
00CEB3  2  53                   .BYTE   mne_ldyx        ; $BC  LDY abs,X
00CEB4  2  01                   .BYTE   mne_ldax        ; $BD  LDA abs,X
00CEB5  2  49                   .BYTE   mne_ldxx        ; $BE  LDX abs,Y
00CEB6  2  01                   .BYTE   mne_ldax        ; $BF  LDA absl,X
00CEB7  2               ;
00CEB7  2  58                   .BYTE   mne_cpyx        ; $C0  CPY #
00CEB8  2  35                   .BYTE   mne_cmpx        ; $C1  CMP (dp,X)
00CEB9  2  31                   .BYTE   mne_repx        ; $C2  REP #
00CEBA  2  35                   .BYTE   mne_cmpx        ; $C3  CMP <offset>,S
00CEBB  2  58                   .BYTE   mne_cpyx        ; $C4  CPY dp
00CEBC  2  35                   .BYTE   mne_cmpx        ; $C5  CMP dp
00CEBD  2  12                   .BYTE   mne_decx        ; $C6  DEC dp
00CEBE  2  35                   .BYTE   mne_cmpx        ; $C7  CMP [dp]
00CEBF  2  57                   .BYTE   mne_inyx        ; $C8  INY
00CEC0  2  35                   .BYTE   mne_cmpx        ; $C9  CMP #
00CEC1  2  4A                   .BYTE   mne_dexx        ; $CA  DEX
00CEC2  2  20                   .BYTE   mne_waix        ; $CB  WAI
00CEC3  2  58                   .BYTE   mne_cpyx        ; $CC  CPY abs
00CEC4  2  35                   .BYTE   mne_cmpx        ; $CD  CMP abs
00CEC5  2  12                   .BYTE   mne_decx        ; $CE  DEC abs
00CEC6  2  35                   .BYTE   mne_cmpx        ; $CF  CMP absl
00CEC7  2               ;
00CEC7  2  1F                   .BYTE   mne_bnex        ; $D0  BNE abs
00CEC8  2  35                   .BYTE   mne_cmpx        ; $D1  CMP (<dp>),Y
00CEC9  2  35                   .BYTE   mne_cmpx        ; $D2  CMP (dp)
00CECA  2  35                   .BYTE   mne_cmpx        ; $D3  CMP (<offset>,S),Y
00CECB  2  21                   .BYTE   mne_peix        ; $D4  PEI dp
00CECC  2  35                   .BYTE   mne_cmpx        ; $D5  CMP dp,X
00CECD  2  12                   .BYTE   mne_decx        ; $D6  DEC dp,X
00CECE  2  35                   .BYTE   mne_cmpx        ; $D7  CMP [dp],Y
00CECF  2  1B                   .BYTE   mne_cldx        ; $D8  CLD
00CED0  2  35                   .BYTE   mne_cmpx        ; $D9  CMP abs,Y
00CED1  2  4B                   .BYTE   mne_phxx        ; $DA  PHX
00CED2  2  39                   .BYTE   mne_stpx        ; $DB  STP
00CED3  2  36                   .BYTE   mne_jmpx        ; $DC  JMP [abs]
00CED4  2  35                   .BYTE   mne_cmpx        ; $DD  CMP abs,X
00CED5  2  12                   .BYTE   mne_decx        ; $DE  DEC abs,X
00CED6  2  35                   .BYTE   mne_cmpx        ; $DF  CMP absl,X
00CED7  2               ;
00CED7  2  4E                   .BYTE   mne_cpxx        ; $E0  CPX #
00CED8  2  0E                   .BYTE   mne_sbcx        ; $E1  SBC (dp,X)
00CED9  2  32                   .BYTE   mne_sepx        ; $E2  SEP #
00CEDA  2  0E                   .BYTE   mne_sbcx        ; $E3  SBC <offset>,S
00CEDB  2  4E                   .BYTE   mne_cpxx        ; $E4  CPX dp
00CEDC  2  0E                   .BYTE   mne_sbcx        ; $E5  SBC dp
00CEDD  2  15                   .BYTE   mne_incx        ; $E6  INC dp
00CEDE  2  0E                   .BYTE   mne_sbcx        ; $E7  SBC [dp]
00CEDF  2  4D                   .BYTE   mne_inxx        ; $E8  INX
00CEE0  2  0E                   .BYTE   mne_sbcx        ; $E9  SBC #
00CEE1  2  38                   .BYTE   mne_nopx        ; $EA  NOP
00CEE2  2  00                   .BYTE   mne_xbax        ; $EB  XBA
00CEE3  2  4E                   .BYTE   mne_cpxx        ; $EC  CPX abs
00CEE4  2  0E                   .BYTE   mne_sbcx        ; $ED  SBC abs
00CEE5  2  15                   .BYTE   mne_incx        ; $EE  INC abs
00CEE6  2  0E                   .BYTE   mne_sbcx        ; $EF  SBC absl
00CEE7  2               ;
00CEE7  2  3B                   .BYTE   mne_beqx        ; $F0  BEQ abs
00CEE8  2  0E                   .BYTE   mne_sbcx        ; $F1  SBC (<dp>),Y
00CEE9  2  0E                   .BYTE   mne_sbcx        ; $F2  SBC (dp)
00CEEA  2  0E                   .BYTE   mne_sbcx        ; $F3  SBC (<offset>,S),Y
00CEEB  2  02                   .BYTE   mne_peax        ; $F4  PEA #
00CEEC  2  0E                   .BYTE   mne_sbcx        ; $F5  SBC dp,X
00CEED  2  15                   .BYTE   mne_incx        ; $F6  INC dp,X
00CEEE  2  0E                   .BYTE   mne_sbcx        ; $F7  SBC [dp],Y
00CEEF  2  19                   .BYTE   mne_sedx        ; $F8  SED
00CEF0  2  0E                   .BYTE   mne_sbcx        ; $F9  SBC abs,Y
00CEF1  2  4C                   .BYTE   mne_plxx        ; $FA  PLX
00CEF2  2  1E                   .BYTE   mne_xcex        ; $FB  XCE
00CEF3  2  3F                   .BYTE   mne_jsrx        ; $FC  JSR (abs,X)
00CEF4  2  0E                   .BYTE   mne_sbcx        ; $FD  SBC abs,X
00CEF5  2  15                   .BYTE   mne_incx        ; $FE  INC abs,X
00CEF6  2  0E                   .BYTE   mne_sbcx        ; $FF  SBC absl,X
00CEF7  2               ;
00CEF7  2               ;
00CEF7  2               ;	instruction addressing modes & sizes in opcode order...
00CEF7  2               ;
00CEF7  2               ;	    xxxxxxxx
00CEF7  2               ;	    ||||||||
00CEF7  2               ;	    ||||++++---> Addressing Mode
00CEF7  2               ;	    ||||         ----------------------------------
00CEF7  2               ;	    ||||          0000  dp, abs, absl, implied or A
00CEF7  2               ;	    ||||          0001  #
00CEF7  2               ;	    ||||          0010  dp,X, abs,X or absl,X
00CEF7  2               ;	    ||||          0011  dp,Y or abs,Y
00CEF7  2               ;	    ||||          0100  (dp) or (abs)
00CEF7  2               ;	    ||||          0101  [dp] or [abs]
00CEF7  2               ;	    ||||          0110  [dp],Y
00CEF7  2               ;	    ||||          0111  (dp,X) or (abs,X)
00CEF7  2               ;	    ||||          1000  (<dp>),Y
00CEF7  2               ;	    ||||          1001  <offset>,S
00CEF7  2               ;	    ||||          1010  (<offset>,S),Y
00CEF7  2               ;	    ||||          1011  sbnk,dbnk (MVN or MVP)
00CEF7  2               ;	    ||||          ---------------------------------
00CEF7  2               ;	    ||||           #    = immediate
00CEF7  2               ;	    ||||           A    = accumulator
00CEF7  2               ;	    ||||           abs  = absolute
00CEF7  2               ;	    ||||           absl = absolute long
00CEF7  2               ;	    ||||           dbnk = destination bank
00CEF7  2               ;	    ||||           dp   = direct (zero) page
00CEF7  2               ;	    ||||           S    = stack relative
00CEF7  2               ;	    ||||           sbnk = source bank
00CEF7  2               ;	    ||||         ----------------------------------
00CEF7  2               ;	    ||||
00CEF7  2               ;	    ||++-------> binary-encoded operand size
00CEF7  2               ;	    |+---------> 1: relative branch instruction
00CEF7  2               ;	    +----------> 1: variable operand size...
00CEF7  2               ;
00CEF7  2               ;	    -------------------------------------------------------------
00CEF7  2               ;	    Variable operand size refers to an immediate mode instruction
00CEF7  2               ;	    that can accept either an 8 or 16 bit operand.  During instr-
00CEF7  2               ;	    uction assembly, an 8 bit operand can be forced to 16 bits by
00CEF7  2               ;	    preceding the operand field with !,  e.g.,  LDA !#$01,  which
00CEF7  2               ;	    will assemble as $A9 $01 $00.
00CEF7  2               ;	    -------------------------------------------------------------
00CEF7  2               ;
00CEF7  2               mnetabam:
00CEF7  2  00                   .BYTE   ops0|am_nam     ; $00  BRK
00CEF8  2  17                   .BYTE   ops1|am_indx    ; $01  ORA (dp,X)
00CEF9  2  10                   .BYTE   ops1|am_nam     ; $02  COP
00CEFA  2  19                   .BYTE   ops1|am_stk     ; $03  ORA <offset>,S
00CEFB  2  10                   .BYTE   ops1|am_nam     ; $04  TSB dp
00CEFC  2  10                   .BYTE   ops1|am_nam     ; $05  ORA dp
00CEFD  2  10                   .BYTE   ops1|am_nam     ; $06  ASL dp
00CEFE  2  15                   .BYTE   ops1|am_indl    ; $07  ORA [dp]
00CEFF  2  00                   .BYTE   ops0|am_nam     ; $08  PHP
00CF00  2  91                   .BYTE   vops|am_imm     ; $09  ORA #
00CF01  2  00                   .BYTE   ops0|am_nam     ; $0A  ASL A
00CF02  2  00                   .BYTE   ops0|am_nam     ; $0B  PHD
00CF03  2  20                   .BYTE   ops2|am_nam     ; $0C  TSB abs
00CF04  2  20                   .BYTE   ops2|am_nam     ; $0D  ORA abs
00CF05  2  20                   .BYTE   ops2|am_nam     ; $0E  ASL abs
00CF06  2  30                   .BYTE   ops3|am_nam     ; $0F  ORA absl
00CF07  2               ;
00CF07  2  50                   .BYTE   bop1|am_nam     ; $10  BPL abs
00CF08  2  18                   .BYTE   ops1|am_indy    ; $11  ORA (<dp>),Y
00CF09  2  14                   .BYTE   ops1|am_ind     ; $12  ORA (dp)
00CF0A  2  1A                   .BYTE   ops1|am_stky    ; $13  ORA (<offset>,S),Y
00CF0B  2  10                   .BYTE   ops1|am_nam     ; $14  TRB dp
00CF0C  2  12                   .BYTE   ops1|am_adrx    ; $15  ORA dp,X
00CF0D  2  12                   .BYTE   ops1|am_adrx    ; $16  ASL dp,X
00CF0E  2  16                   .BYTE   ops1|am_indly   ; $17  ORA [dp],Y
00CF0F  2  00                   .BYTE   ops0|am_nam     ; $18  CLC
00CF10  2  20                   .BYTE   ops2|am_nam     ; $19  ORA abs
00CF11  2  00                   .BYTE   ops0|am_nam     ; $1A  INC A
00CF12  2  00                   .BYTE   ops0|am_nam     ; $1B  TCS
00CF13  2  20                   .BYTE   ops2|am_nam     ; $1C  TRB abs
00CF14  2  22                   .BYTE   ops2|am_adrx    ; $1D  ORA abs,X
00CF15  2  22                   .BYTE   ops2|am_adrx    ; $1E  ASL abs,X
00CF16  2  32                   .BYTE   ops3|am_adrx    ; $1F  ORA absl,X
00CF17  2               ;
00CF17  2  20                   .BYTE   ops2|am_nam     ; $20  JSR abs
00CF18  2  17                   .BYTE   ops1|am_indx    ; $21  AND (dp,X)
00CF19  2  30                   .BYTE   ops3|am_nam     ; $22  JSL absl
00CF1A  2  19                   .BYTE   ops1|am_stk     ; $23  AND <offset>,S
00CF1B  2  10                   .BYTE   ops1|am_nam     ; $24  BIT dp
00CF1C  2  10                   .BYTE   ops1|am_nam     ; $25  AND dp
00CF1D  2  10                   .BYTE   ops1|am_nam     ; $26  ROL dp
00CF1E  2  15                   .BYTE   ops1|am_indl    ; $27  AND [dp]
00CF1F  2  00                   .BYTE   ops0|am_nam     ; $28  PLP
00CF20  2  91                   .BYTE   vops|am_imm     ; $29  AND #
00CF21  2  00                   .BYTE   ops0|am_nam     ; $2A  ROL A
00CF22  2  00                   .BYTE   ops0|am_nam     ; $2B  PLD
00CF23  2  20                   .BYTE   ops2|am_nam     ; $2C  BIT abs
00CF24  2  20                   .BYTE   ops2|am_nam     ; $2D  AND abs
00CF25  2  20                   .BYTE   ops2|am_nam     ; $2E  ROL abs
00CF26  2  30                   .BYTE   ops3|am_nam     ; $2F  AND absl
00CF27  2               ;
00CF27  2  50                   .BYTE   bop1|am_nam     ; $30  BMI abs
00CF28  2  18                   .BYTE   ops1|am_indy    ; $31  AND (<dp>),Y
00CF29  2  14                   .BYTE   ops1|am_ind     ; $32  AND (dp)
00CF2A  2  1A                   .BYTE   ops1|am_stky    ; $33  AND (<offset>,S),Y
00CF2B  2  12                   .BYTE   ops1|am_adrx    ; $34  BIT dp,X
00CF2C  2  12                   .BYTE   ops1|am_adrx    ; $35  AND dp,X
00CF2D  2  12                   .BYTE   ops1|am_adrx    ; $36  ROL dp,X
00CF2E  2  16                   .BYTE   ops1|am_indly   ; $37  AND [dp],Y
00CF2F  2  00                   .BYTE   ops0|am_nam     ; $38  SEC
00CF30  2  23                   .BYTE   ops2|am_adry    ; $39  AND abs,Y
00CF31  2  00                   .BYTE   ops0|am_nam     ; $3A  DEC A
00CF32  2  00                   .BYTE   ops0|am_nam     ; $3B  TSC
00CF33  2  22                   .BYTE   ops2|am_adrx    ; $3C  BIT abs,X
00CF34  2  22                   .BYTE   ops2|am_adrx    ; $3D  AND abs,X
00CF35  2  22                   .BYTE   ops2|am_adrx    ; $3E  ROL abs,X
00CF36  2  32                   .BYTE   ops3|am_adrx    ; $3F  AND absl,X
00CF37  2               ;
00CF37  2  00                   .BYTE   ops0|am_nam     ; $40  RTI
00CF38  2  17                   .BYTE   ops1|am_indx    ; $41  EOR (dp,X)
00CF39  2  00                   .BYTE   ops0|am_nam     ; $42  WDM
00CF3A  2  19                   .BYTE   ops1|am_stk     ; $43  EOR <offset>,S
00CF3B  2  2B                   .BYTE   ops2|am_move    ; $44  MVP sb,db
00CF3C  2  10                   .BYTE   ops1|am_nam     ; $45  EOR dp
00CF3D  2  10                   .BYTE   ops1|am_nam     ; $46  LSR dp
00CF3E  2  15                   .BYTE   ops1|am_indl    ; $47  EOR [dp]
00CF3F  2  00                   .BYTE   ops0|am_nam     ; $48  PHA
00CF40  2  91                   .BYTE   vops|am_imm     ; $49  EOR #
00CF41  2  00                   .BYTE   ops0|am_nam     ; $4A  LSR A
00CF42  2  00                   .BYTE   ops0|am_nam     ; $4B  PHK
00CF43  2  20                   .BYTE   ops2|am_nam     ; $4C  JMP abs
00CF44  2  20                   .BYTE   ops2|am_nam     ; $4D  EOR abs
00CF45  2  20                   .BYTE   ops2|am_nam     ; $4E  LSR abs
00CF46  2  30                   .BYTE   ops3|am_nam     ; $4F  EOR absl
00CF47  2               ;
00CF47  2  50                   .BYTE   bop1|am_nam     ; $50  BVC abs
00CF48  2  18                   .BYTE   ops1|am_indy    ; $51  EOR (<dp>),Y
00CF49  2  14                   .BYTE   ops1|am_ind     ; $52  EOR (dp)
00CF4A  2  1A                   .BYTE   ops1|am_stky    ; $53  EOR (<offset>,S),Y
00CF4B  2  2B                   .BYTE   ops2|am_move    ; $54  MVN sb,db
00CF4C  2  12                   .BYTE   ops1|am_adrx    ; $55  EOR dp,X
00CF4D  2  12                   .BYTE   ops1|am_adrx    ; $56  LSR dp,X
00CF4E  2  16                   .BYTE   ops1|am_indly   ; $57  EOR [dp],Y
00CF4F  2  00                   .BYTE   ops0|am_nam     ; $58  CLI
00CF50  2  23                   .BYTE   ops2|am_adry    ; $59  EOR abs,Y
00CF51  2  00                   .BYTE   ops0|am_nam     ; $5A  PHY
00CF52  2  00                   .BYTE   ops0|am_nam     ; $5B  TCD
00CF53  2  30                   .BYTE   ops3|am_nam     ; $5C  JML absl
00CF54  2  22                   .BYTE   ops2|am_adrx    ; $5D  EOR abs,X
00CF55  2  22                   .BYTE   ops2|am_adrx    ; $5E  LSR abs,X
00CF56  2  32                   .BYTE   ops3|am_adrx    ; $5F  EOR absl,X
00CF57  2               ;
00CF57  2  00                   .BYTE   ops0|am_nam     ; $60  RTS
00CF58  2  17                   .BYTE   ops1|am_indx    ; $61  ADC (dp,X)
00CF59  2  60                   .BYTE   bop2|am_nam     ; $62  PER
00CF5A  2  19                   .BYTE   ops1|am_stk     ; $63  ADC <offset>,S
00CF5B  2  10                   .BYTE   ops1|am_nam     ; $64  STZ dp
00CF5C  2  10                   .BYTE   ops1|am_nam     ; $65  ADC dp
00CF5D  2  10                   .BYTE   ops1|am_nam     ; $66  ROR dp
00CF5E  2  15                   .BYTE   ops1|am_indl    ; $67  ADC [dp]
00CF5F  2  00                   .BYTE   ops0|am_nam     ; $68  PLA
00CF60  2  91                   .BYTE   vops|am_imm     ; $69  ADC #
00CF61  2  00                   .BYTE   ops0|am_nam     ; $6A  ROR A
00CF62  2  00                   .BYTE   ops0|am_nam     ; $6B  RTL
00CF63  2  24                   .BYTE   ops2|am_ind     ; $6C  JMP (abs)
00CF64  2  20                   .BYTE   ops2|am_nam     ; $6D  ADC abs
00CF65  2  20                   .BYTE   ops2|am_nam     ; $6E  ROR abs
00CF66  2  30                   .BYTE   ops3|am_nam     ; $6F  ADC absl
00CF67  2               ;
00CF67  2  50                   .BYTE   bop1|am_nam     ; $70  BVS abs
00CF68  2  18                   .BYTE   ops1|am_indy    ; $71  ADC (<dp>),Y
00CF69  2  14                   .BYTE   ops1|am_ind     ; $72  ADC (dp)
00CF6A  2  1A                   .BYTE   ops1|am_stky    ; $73  ADC (<offset>,S),Y
00CF6B  2  12                   .BYTE   ops1|am_adrx    ; $74  STZ dp,X
00CF6C  2  12                   .BYTE   ops1|am_adrx    ; $75  ADC dp,X
00CF6D  2  12                   .BYTE   ops1|am_adrx    ; $76  ROR dp,X
00CF6E  2  16                   .BYTE   ops1|am_indly   ; $77  ADC [dp],Y
00CF6F  2  00                   .BYTE   ops0|am_nam     ; $78  SEI
00CF70  2  23                   .BYTE   ops2|am_adry    ; $79  ADC abs,Y
00CF71  2  00                   .BYTE   ops0|am_nam     ; $7A  PLY
00CF72  2  00                   .BYTE   ops0|am_nam     ; $7B  TDC
00CF73  2  27                   .BYTE   ops2|am_indx    ; $7C  JMP (abs,X)
00CF74  2  22                   .BYTE   ops2|am_adrx    ; $7D  ADC abs,X
00CF75  2  22                   .BYTE   ops2|am_adrx    ; $7E  ROR abs,X
00CF76  2  32                   .BYTE   ops3|am_adrx    ; $7F  ADC absl,X
00CF77  2               ;
00CF77  2  50                   .BYTE   bop1|am_nam     ; $80  BRA abs
00CF78  2  17                   .BYTE   ops1|am_indx    ; $81  STA (dp,X)
00CF79  2  60                   .BYTE   bop2|am_nam     ; $82  BRL abs
00CF7A  2  19                   .BYTE   ops1|am_stk     ; $83  STA <offset>,S
00CF7B  2  10                   .BYTE   ops1|am_nam     ; $84  STY dp
00CF7C  2  10                   .BYTE   ops1|am_nam     ; $85  STA dp
00CF7D  2  10                   .BYTE   ops1|am_nam     ; $86  STX dp
00CF7E  2  15                   .BYTE   ops1|am_indl    ; $87  STA [dp]
00CF7F  2  00                   .BYTE   ops0|am_nam     ; $88  DEY
00CF80  2  91                   .BYTE   vops|am_imm     ; $89  BIT #
00CF81  2  00                   .BYTE   ops0|am_nam     ; $8A  TXA
00CF82  2  00                   .BYTE   ops0|am_nam     ; $8B  PHB
00CF83  2  20                   .BYTE   ops2|am_nam     ; $8C  STY abs
00CF84  2  20                   .BYTE   ops2|am_nam     ; $8D  STA abs
00CF85  2  20                   .BYTE   ops2|am_nam     ; $8E  STX abs
00CF86  2  30                   .BYTE   ops3|am_nam     ; $8F  STA absl
00CF87  2               ;
00CF87  2  50                   .BYTE   bop1|am_nam     ; $90  BCC abs
00CF88  2  18                   .BYTE   ops1|am_indy    ; $91  STA (<dp>),Y
00CF89  2  14                   .BYTE   ops1|am_ind     ; $92  STA (dp)
00CF8A  2  1A                   .BYTE   ops1|am_stky    ; $93  STA (<offset>,S),Y
00CF8B  2  12                   .BYTE   ops1|am_adrx    ; $94  STY dp,X
00CF8C  2  12                   .BYTE   ops1|am_adrx    ; $95  STA dp,X
00CF8D  2  13                   .BYTE   ops1|am_adry    ; $96  STX dp,Y
00CF8E  2  16                   .BYTE   ops1|am_indly   ; $97  STA [dp],Y
00CF8F  2  00                   .BYTE   ops0|am_nam     ; $98  TYA
00CF90  2  23                   .BYTE   ops2|am_adry    ; $99  STA abs,Y
00CF91  2  00                   .BYTE   ops0|am_nam     ; $9A  TXS
00CF92  2  00                   .BYTE   ops0|am_nam     ; $9B  TXY
00CF93  2  20                   .BYTE   ops2|am_nam     ; $9C  STZ abs
00CF94  2  22                   .BYTE   ops2|am_adrx    ; $9D  STA abs,X
00CF95  2  22                   .BYTE   ops2|am_adrx    ; $9E  STZ abs,X
00CF96  2  32                   .BYTE   ops3|am_adrx    ; $9F  STA absl,X
00CF97  2               ;
00CF97  2  91                   .BYTE   vops|am_imm     ; $A0  LDY #
00CF98  2  17                   .BYTE   ops1|am_indx    ; $A1  LDA (dp,X)
00CF99  2  91                   .BYTE   vops|am_imm     ; $A2  LDX #
00CF9A  2  19                   .BYTE   ops1|am_stk     ; $A3  LDA <offset>,S
00CF9B  2  10                   .BYTE   ops1|am_nam     ; $A4  LDY dp
00CF9C  2  10                   .BYTE   ops1|am_nam     ; $A5  LDA dp
00CF9D  2  10                   .BYTE   ops1|am_nam     ; $A6  LDX dp
00CF9E  2  15                   .BYTE   ops1|am_indl    ; $A7  LDA [dp]
00CF9F  2  00                   .BYTE   ops0|am_nam     ; $A8  TAY
00CFA0  2  91                   .BYTE   vops|am_imm     ; $A9  LDA #
00CFA1  2  00                   .BYTE   ops0|am_nam     ; $AA  TAX
00CFA2  2  00                   .BYTE   ops0|am_nam     ; $AB  PLB
00CFA3  2  20                   .BYTE   ops2|am_nam     ; $AC  LDY abs
00CFA4  2  20                   .BYTE   ops2|am_nam     ; $AD  LDA abs
00CFA5  2  20                   .BYTE   ops2|am_nam     ; $AE  LDX abs
00CFA6  2  30                   .BYTE   ops3|am_nam     ; $AF  LDA absl
00CFA7  2               ;
00CFA7  2  50                   .BYTE   bop1|am_nam     ; $B0  BCS abs
00CFA8  2  18                   .BYTE   ops1|am_indy    ; $B1  LDA (<dp>),Y
00CFA9  2  14                   .BYTE   ops1|am_ind     ; $B2  LDA (dp)
00CFAA  2  1A                   .BYTE   ops1|am_stky    ; $B3  LDA (<offset>,S),Y
00CFAB  2  12                   .BYTE   ops1|am_adrx    ; $B4  LDY dp,X
00CFAC  2  12                   .BYTE   ops1|am_adrx    ; $B5  LDA dp,X
00CFAD  2  13                   .BYTE   ops1|am_adry    ; $B6  LDX dp,Y
00CFAE  2  16                   .BYTE   ops1|am_indly   ; $B7  LDA [dp],Y
00CFAF  2  00                   .BYTE   ops0|am_nam     ; $B8  CLV
00CFB0  2  23                   .BYTE   ops2|am_adry    ; $B9  LDA abs,Y
00CFB1  2  00                   .BYTE   ops0|am_nam     ; $BA  TSX
00CFB2  2  00                   .BYTE   ops0|am_nam     ; $BB  TYX
00CFB3  2  22                   .BYTE   ops2|am_adrx    ; $BC  LDY abs,X
00CFB4  2  22                   .BYTE   ops2|am_adrx    ; $BD  LDA abs,X
00CFB5  2  23                   .BYTE   ops2|am_adry    ; $BE  LDX abs,Y
00CFB6  2  32                   .BYTE   ops3|am_adrx    ; $BF  LDA absl,X
00CFB7  2               ;
00CFB7  2  91                   .BYTE   vops|am_imm     ; $C0  CPY #
00CFB8  2  17                   .BYTE   ops1|am_indx    ; $C1  CMP (dp,X)
00CFB9  2  11                   .BYTE   ops1|am_imm     ; $C2  REP #
00CFBA  2  19                   .BYTE   ops1|am_stk     ; $C3  CMP <offset>,S
00CFBB  2  10                   .BYTE   ops1|am_nam     ; $C4  CPY dp
00CFBC  2  10                   .BYTE   ops1|am_nam     ; $C5  CMP dp
00CFBD  2  10                   .BYTE   ops1|am_nam     ; $C6  DEC dp
00CFBE  2  15                   .BYTE   ops1|am_indl    ; $C7  CMP [dp]
00CFBF  2  00                   .BYTE   ops0|am_nam     ; $C8  INY
00CFC0  2  91                   .BYTE   vops|am_imm     ; $C9  CMP #
00CFC1  2  00                   .BYTE   ops0|am_nam     ; $CA  DEX
00CFC2  2  00                   .BYTE   ops0|am_nam     ; $CB  WAI
00CFC3  2  20                   .BYTE   ops2|am_nam     ; $CC  CPY abs
00CFC4  2  20                   .BYTE   ops2|am_nam     ; $CD  CMP abs
00CFC5  2  20                   .BYTE   ops2|am_nam     ; $CE  DEC abs
00CFC6  2  30                   .BYTE   ops3|am_nam     ; $CF  CMP absl
00CFC7  2               ;
00CFC7  2  50                   .BYTE   bop1|am_nam     ; $D0  BNE abs
00CFC8  2  18                   .BYTE   ops1|am_indy    ; $D1  CMP (<dp>),Y
00CFC9  2  14                   .BYTE   ops1|am_ind     ; $D2  CMP (dp)
00CFCA  2  1A                   .BYTE   ops1|am_stky    ; $D3  CMP (<offset>,S),Y
00CFCB  2  10                   .BYTE   ops1|am_nam     ; $D4  PEI dp
00CFCC  2  12                   .BYTE   ops1|am_adrx    ; $D5  CMP dp,X
00CFCD  2  12                   .BYTE   ops1|am_adrx    ; $D6  DEC dp,X
00CFCE  2  16                   .BYTE   ops1|am_indly   ; $D7  CMP [dp],Y
00CFCF  2  00                   .BYTE   ops0|am_nam     ; $D8  CLD
00CFD0  2  23                   .BYTE   ops2|am_adry    ; $D9  CMP abs,Y
00CFD1  2  00                   .BYTE   ops0|am_nam     ; $DA  PHX
00CFD2  2  00                   .BYTE   ops0|am_nam     ; $DB  STP
00CFD3  2  25                   .BYTE   ops2|am_indl    ; $DC  JMP [abs]
00CFD4  2  22                   .BYTE   ops2|am_adrx    ; $DD  CMP abs,X
00CFD5  2  22                   .BYTE   ops2|am_adrx    ; $DE  DEC abs,X
00CFD6  2  32                   .BYTE   ops3|am_adrx    ; $DF  CMP absl,X
00CFD7  2               ;
00CFD7  2  91                   .BYTE   vops|am_imm     ; $E0  CPX #
00CFD8  2  17                   .BYTE   ops1|am_indx    ; $E1  SBC (dp,X)
00CFD9  2  11                   .BYTE   ops1|am_imm     ; $E2  SEP #
00CFDA  2  19                   .BYTE   ops1|am_stk     ; $E3  SBC <offset>,S
00CFDB  2  10                   .BYTE   ops1|am_nam     ; $E4  CPX dp
00CFDC  2  10                   .BYTE   ops1|am_nam     ; $E5  SBC dp
00CFDD  2  10                   .BYTE   ops1|am_nam     ; $E6  INC dp
00CFDE  2  15                   .BYTE   ops1|am_indl    ; $E7  SBC [dp]
00CFDF  2  00                   .BYTE   ops0|am_nam     ; $E8  INX
00CFE0  2  91                   .BYTE   vops|am_imm     ; $E9  SBC #
00CFE1  2  00                   .BYTE   ops0|am_nam     ; $EA  NOP
00CFE2  2  00                   .BYTE   ops0|am_nam     ; $EB  XBA
00CFE3  2  20                   .BYTE   ops2|am_nam     ; $EC  CPX abs
00CFE4  2  20                   .BYTE   ops2|am_nam     ; $ED  SBC abs
00CFE5  2  20                   .BYTE   ops2|am_nam     ; $EE  INC abs
00CFE6  2  30                   .BYTE   ops3|am_nam     ; $EF  SBC absl
00CFE7  2               ;
00CFE7  2  50                   .BYTE   bop1|am_nam     ; $F0  BEQ abs
00CFE8  2  18                   .BYTE   ops1|am_indy    ; $F1  SBC (<dp>),Y
00CFE9  2  14                   .BYTE   ops1|am_ind     ; $F2  SBC (dp)
00CFEA  2  1A                   .BYTE   ops1|am_stky    ; $F3  SBC (<offset>,S),Y
00CFEB  2  21                   .BYTE   ops2|am_imm     ; $F4  PEA #
00CFEC  2  12                   .BYTE   ops1|am_adrx    ; $F5  SBC dp,X
00CFED  2  12                   .BYTE   ops1|am_adrx    ; $F6  INC dp,X
00CFEE  2  16                   .BYTE   ops1|am_indly   ; $F7  SBC [dp],Y
00CFEF  2  00                   .BYTE   ops0|am_nam     ; $F8  SED
00CFF0  2  23                   .BYTE   ops2|am_adry    ; $F9  SBC abs,Y
00CFF1  2  00                   .BYTE   ops0|am_nam     ; $FA  PLX
00CFF2  2  00                   .BYTE   ops0|am_nam     ; $FB  XCE
00CFF3  2  27                   .BYTE   ops2|am_indx    ; $FC  JSR (abs,X)
00CFF4  2  22                   .BYTE   ops2|am_adrx    ; $FD  SBC abs,X
00CFF5  2  22                   .BYTE   ops2|am_adrx    ; $FE  INC abs,X
00CFF6  2  32                   .BYTE   ops3|am_adrx    ; $FF  SBC absl,X
00CFF7  2               ;
00CFF7  2               ;
00CFF7  2               ;	.X & .Y immediate mode opcodes...
00CFF7  2               ;
00CFF7  2               vopidx:
00CFF7  2  E0                   .BYTE   opc_cpxi        ;CPX #
00CFF8  2  C0                   .BYTE   opc_cpyi        ;CPY #
00CFF9  2  A2                   .BYTE   opc_ldxi        ;LDX #
00CFFA  2  A0                   .BYTE   opc_ldyi        ;LDY #
00CFFB  2               n_vopidx        = *-vopidx      ;number of opcodes
00CFFB  2               ;
00CFFB  2               ;
00CFFB  2               ;	addressing mode symbology lookup...
00CFFB  2               ;
00CFFB  2               ms_lutab:
00CFFB  2  13 D0                .WORD   ms_nam          ;no symbol
00CFFD  2  1D D0                .WORD   ms_imm          ;#
00CFFF  2  15 D0                .WORD   ms_addrx        ;<addr>,X
00D001  2  19 D0                .WORD   ms_addry        ;<addr>,Y
00D003  2  1F D0                .WORD   ms_ind          ;(<addr>)
00D005  2  22 D0                .WORD   ms_indl         ;[<dp>]
00D007  2  25 D0                .WORD   ms_indly        ;[<dp>],Y
00D009  2  2A D0                .WORD   ms_indx         ;(<addr>,X)
00D00B  2  2F D0                .WORD   ms_indy         ;(<dp>),Y
00D00D  2  37 D0                .WORD   ms_stk          ;<offset>,S
00D00F  2  3B D0                .WORD   ms_stky         ;(<offset>,S),Y
00D011  2  13 D0                .WORD   ms_nam          ;<sbnk>,<dbnk>
00D013  2               ;
00D013  2               ;
00D013  2               ;	addressing mode symbology strings...
00D013  2               ;
00D013  2               ms_nam:
00D013  2  20 00                .BYTE   " ",0           ;no symbol
00D015  2               ms_addrx:
00D015  2  20 2C 58 00          .BYTE   " ,X",0         ;<addr>,X
00D019  2               ms_addry:
00D019  2  20 2C 59 00          .BYTE   " ,Y",0         ;<addr>,Y
00D01D  2               ms_imm:
00D01D  2  23 00                .BYTE   "#",0           ;#
00D01F  2               ms_ind:
00D01F  2  28 29 00             .BYTE   "()",0          ;(<addr>)
00D022  2               ms_indl:
00D022  2  5B 5D 00             .BYTE   "[]",0          ;[<dp>]
00D025  2               ms_indly:
00D025  2  5B 5D 2C 59          .BYTE   "[],Y",0        ;[<dp>],Y
00D029  2  00           
00D02A  2               ms_indx:
00D02A  2  28 2C 58 29          .BYTE   "(,X)",0        ;(<addr>,X)
00D02E  2  00           
00D02F  2               ms_indy:
00D02F  2  28 29 2C 59          .BYTE   "(),Y",0        ;(<dp>),Y
00D033  2  00           
00D034  2               ms_move:
00D034  2  2C 24 00             .BYTE   ",$",0          ;<sbnk>,<dbnk>
00D037  2               ms_stk:
00D037  2  20 2C 53 00          .BYTE   " ,S",0         ;<offset>,S
00D03B  2               ms_stky:
00D03B  2  28 2C 53 29          .BYTE   "(,S),Y",0      ;(<offset>,S),Y
00D03F  2  2C 59 00     
00D042  2               ;
00D042  2               ;================================================================================
00D042  2               ;
00D042  2               ;CONSOLE DISPLAY CONTROL STRINGS
00D042  2               ;
00D042  2               dc_lf:
00D042  2  0D 0A                LF                      ;newline
00D044  2  00                   .BYTE   0
00D045  2               ;
00D045  2               dc_bs:  ;destructive backspace
00D045  2  08                   .BYTE   a_bs
00D046  2  20                   .BYTE   $20
00D047  2  08                   .BYTE   a_bs
00D048  2  00                   .BYTE   0
00D049  2               ;
00D049  2               dc_cl_DUMB:                     ;clear to end of line
00D049  2  0D 0A                .BYTE   $0d,$0a
00D04B  2  00                   .BYTE   0
00D04C  2               dc_cl_ANSI:                     ;clear to end of line
00D04C  2  1B 5B 4B             .BYTE   a_esc,"[K"
00D04F  2  00                   .BYTE   0
00D050  2               dc_cl_WYSE:                     ;clear to end of line
00D050  2  1B 54                .BYTE   a_esc,"T"
00D052  2  00                   .BYTE   0
00D053  2               
00D053  2               ;
00D053  2               ;
00D053  2               
00D053  2               ;
00D053  2               ;================================================================================
00D053  2               ;
00D053  2               ;TEXT STRINGS
00D053  2               ;
00D053  2               mm_brk:
00D053  2  07                   RB
00D054  2  0D 0A                LF
00D056  2  2A 42 52 4B          .BYTE   "*BRK"
00D05A  2  0D 0A                LF
00D05C  2  00                   .BYTE   0
00D05D  2               ;
00D05D  2               mm_entry:
00D05D  2  0D 0A                LF
00D05F  2  53 75 70 65          .BYTE   "Supermon 816 "
00D063  2  72 6D 6F 6E  
00D067  2  20 38 31 36  
00D06C  2  31 2E 30 2E          SOFTVERS
00D070  2  32           
00D071  2  20                   .BYTE   " "
00D072  2  0D 0A                LF
00D074  2  00                   .BYTE   0
00D075  2               ;
00D075  2               mm_err:
00D075  2  20 2A 45 52          .BYTE   " *ERR ",0
00D079  2  52 20 00     
00D07C  2               ;
00D07C  2               mm_prmpt:
00D07C  2  0D 0A                LF
00D07E  2  2E 00                .BYTE   ".",0
00D080  2               ;
00D080  2               mm_regs:
00D080  2  0D 0A                LF
00D082  2  50 42 20 20          .BYTE   "PB  PC   NVmxDIZC  .C   .X   .Y   SP"
00D086  2  50 43 20 20  
00D08A  2  20 4E 56 6D  
00D0A6  2  0D 0A                LF
00D0A8  2  00                   .BYTE   0
00D0A9  2               mm_regs1:
00D0A9  2  0D 0A                LF
00D0AB  2  20 44 50 20          .BYTE   " DP  DB"
00D0AF  2  20 44 42     
00D0B2  2  0D 0A                LF
00D0B4  2  00                   .BYTE   0
00D0B5  2               
00D0B5  2               ;
00D0B5  2               mm_rts:
00D0B5  2  07                   RB
00D0B6  2  0D 0A                LF
00D0B8  2  2A 52 54 53          .BYTE   "*RTS"
00D0BC  2  0D 0A                LF
00D0BE  2  00                   .BYTE   0
00D0BF  2               
00D0BF  2               
00D0BF  2               mm_S19_prmpt:
00D0BF  2  0D 0A                LF
00D0C1  2  42 65 67 69          .BYTE   "Begin sending S28 encoded file. . ."
00D0C5  2  6E 20 73 65  
00D0C9  2  6E 64 69 6E  
00D0E4  2  0D 0A                LF
00D0E6  2  00                   .BYTE   0
00D0E7  2               
00D0E7  2               ;
00D0E7  2               ALIVEM:
00D0E7  2  0D 0A                .BYTE   $0D,$0A
00D0E9  2  0D 0A                .BYTE   $0D,$0A
00D0EB  2  20 20 20 5F          .BYTE   "   __ _____  ___  __   __",$0D,$0A
00D0EF  2  5F 20 5F 5F  
00D0F3  2  5F 5F 5F 20  
00D106  2  20 20 2F 20          .BYTE   "  / /| ____|/ _ \/_ | / /",$0D,$0A
00D10A  2  2F 7C 20 5F  
00D10E  2  5F 5F 5F 7C  
00D121  2  20 2F 20 2F          .BYTE   " / /_| |__ | (_) || |/ /_",$0D,$0A
00D125  2  5F 7C 20 7C  
00D129  2  5F 5F 20 7C  
00D13C  2  7C 20 20 5F          .BYTE   "|  _ \___ \ > _ < | |  _ \",$0D,$0A
00D140  2  20 5C 5F 5F  
00D144  2  5F 20 5C 20  
00D158  2  7C 20 28 5F          .BYTE   "| (_) |__) | (_) || | (_) |",$0D,$0A
00D15C  2  29 20 7C 5F  
00D160  2  5F 29 20 7C  
00D175  2  20 5C 5F 5F          .BYTE   " \___/____/ \___/ |_|\___/ ",$0D,$0A
00D179  2  5F 2F 5F 5F  
00D17D  2  5F 5F 2F 20  
00D192  2  0D 0A                .BYTE   $0D,$0A
00D194  2  36 35 63 38          .BYTE   "65c816 BIOS (NATIVE MODE)",$0D,$0A
00D198  2  31 36 20 42  
00D19C  2  49 4F 53 20  
00D1AF  2  57 45 38 31          .BYTE   "WE816-MARK2 8/10/2024 - D.WERNER",$0D,$0A
00D1B3  2  36 2D 4D 41  
00D1B7  2  52 4B 32 20  
00D1D1  2  2D 2D 2D 2D          .BYTE   "-------------------------------------",$0D,$0A
00D1D5  2  2D 2D 2D 2D  
00D1D9  2  2D 2D 2D 2D  
00D1F8  2  0D 0A 00             .BYTE   $0D,$0A,0
00D1FB  2               ;
00D1FB  2               
00D1FB  2               
00D1FB  2               _txtend_        = *             ;end of program text
00D1FB  2               ;
00D1FB  2               ;================================================================================
00D1FB  2               
00D1FB  1               
00D1FB  1               ;__INTRETURN____________________________________________________
00D1FB  1               ;
00D1FB  1               ; Handle Interrupts
00D1FB  1               ;
00D1FB  1               ;_______________________________________________________________
00D1FB  1               ;
00D1FB  1               INTRETURN:
00D1FB  1  40                   RTI                     ;
00D1FC  1               
00D1FC  1               ;__BATEST_______________________________________________________
00D1FC  1               ;
00D1FC  1               ; Perform Basic Hardware Assurance Test
00D1FC  1               ;
00D1FC  1               ;_______________________________________________________________
00D1FC  1               ;
00D1FC  1               BATEST:
00D1FC  1  60                   RTS
00D1FD  1               
00D1FD  1               
00D1FD  1               
00D1FD  1               ;__CONSOLE_INIT_________________________________________________
00D1FD  1               ;
00D1FD  1               ; Initialize Attached Console Devices
00D1FD  1               ;
00D1FD  1               ;_______________________________________________________________
00D1FD  1               ;
00D1FD  1               CONSOLE_INIT:
00D1FD  1  08                   PHP
00D1FE  1  E2 30                ACCUMULATORINDEX8
00D200  1               
00D200  1  20 57 D2             JSR     SERIAL_CONSOLE_INIT
00D203  1  20 B5 D2             JSR     SETUPVIDEO
00D206  1  A9 0F                LDA     #$0F
00D208  1  20 FB D3             JSR     SetColor
00D20B  1  20 9C D4             JSR     ClearScreen
00D20E  1  A9 00                LDA     #$00
00D210  1  8D 41 03             STA     ConsoleDevice
00D213  1  20 E3 D4             JSR     INITKEYBOARD
00D216  1               
00D216  1  28                   PLP
00D217  1  60                   RTS
00D218  1               
00D218  1               
00D218  1               ;__OUTCH_______________________________________________________
00D218  1               ;
00D218  1               ; OUTPUT CHAR IN LOW BYTE OF ACC TO CONSOLE
00D218  1               ;
00D218  1               ; Current Console Device stored in ConsoleDevice
00D218  1               ;
00D218  1               ; 0=Serial
00D218  1               ; 1=On Board 9918/KB
00D218  1               ;______________________________________________________________
00D218  1               OUTCH:
00D218  1  DA                   PHX
00D219  1  5A                   PHY
00D21A  1  08                   PHP
00D21B  1  E2 30                ACCUMULATORINDEX8
00D21D  1  AA                   TAX
00D21E  1  AF 41 03 00          LDA     F:ConsoleDevice
00D222  1  C9 01                CMP     #$01
00D224  1  D0 08                BNE     OUTCH2
00D226  1  8A                   TXA
00D227  1  20 21 D3             JSR     OutVideoCh
00D22A  1  28                   PLP
00D22B  1  7A                   PLY
00D22C  1  FA                   PLX
00D22D  1  60                   RTS
00D22E  1               
00D22E  1               ; Default (serial)
00D22E  1               OUTCH2:
00D22E  1  8A                   TXA
00D22F  1  20 78 D2             JSR     SERIAL_OUTCH
00D232  1  28                   PLP
00D233  1  7A                   PLY
00D234  1  FA                   PLX
00D235  1  60                   RTS
00D236  1               
00D236  1               
00D236  1               ;__INCHW_______________________________________________________
00D236  1               ;
00D236  1               ; INPUT CHAR FROM CONSOLE TO ACC  (WAIT FOR CHAR)
00D236  1               ;
00D236  1               ;______________________________________________________________
00D236  1               INCHW:
00D236  1  DA                   PHX
00D237  1  5A                   PHY
00D238  1  08                   PHP
00D239  1  E2 30                ACCUMULATORINDEX8
00D23B  1               
00D23B  1               ;        LDA     F:ConsoleDevice
00D23B  1               ;        CMP     #$01
00D23B  1               ;        BNE     INCHW2
00D23B  1               ;        JSR     GetKey
00D23B  1               ;        PLP
00D23B  1               ;        PLY
00D23B  1               ;        PLX
00D23B  1               ;        RTS
00D23B  1               
00D23B  1               ; Default (serial)
00D23B  1               INCHW2:
00D23B  1  20 8D D2             JSR     SERIAL_INCHW
00D23E  1  28                   PLP
00D23F  1  7A                   PLY
00D240  1  FA                   PLX
00D241  1  60                   RTS
00D242  1               
00D242  1               
00D242  1               ;__INCH________________________________________________________
00D242  1               ;
00D242  1               ; INPUT CHAR FROM CONSOLE TO ACC
00D242  1               ;
00D242  1               ;______________________________________________________________
00D242  1               INCH:
00D242  1  DA                   PHX
00D243  1  5A                   PHY
00D244  1  08                   PHP
00D245  1  E2 30                ACCUMULATORINDEX8
00D247  1               
00D247  1               ;      LDA     F:ConsoleDevice
00D247  1               ;      CMP     #$01
00D247  1               ;      BNE     INCH2
00D247  1               
00D247  1               ;     JSR     ScanKeyboard
00D247  1               ;     CMP     #$FF
00D247  1               ;     BEQ     INCH2S
00D247  1               ;      JSR     GetKey
00D247  1               ;     BRA     INCH2C
00D247  1               
00D247  1               ; Default (serial)
00D247  1               INCH2:
00D247  1  20 A0 D2             JSR     SERIAL_INCH
00D24A  1  B0 05                BCS     INCH2S
00D24C  1               
00D24C  1               
00D24C  1               INCH2C:
00D24C  1  28                   PLP
00D24D  1  7A                   PLY
00D24E  1  FA                   PLX
00D24F  1  18                   CLC
00D250  1  60                   RTS
00D251  1               INCH2S:
00D251  1  28                   PLP
00D252  1  7A                   PLY
00D253  1  FA                   PLX
00D254  1  38                   SEC
00D255  1  60                   RTS
00D256  1               
00D256  1               DONOOP:
00D256  1               nothere:
00D256  1  60                   RTS
00D257  1               
00D257  1               
00D257  1               ;__Device_Driver_Code___________________________________________
00D257  1               ;
00D257  1                       .INCLUDE "conserial.asm"
00D257  2               ;__CONSERIAL_______________________________________________________________________________________
00D257  2               ;
00D257  2               ;	SERIAL CONSOLE DRIVER FOR THE RBC 65c816 SBC
00D257  2               ;
00D257  2               ;	WRITTEN BY: DAN WERNER -- 2/25/2018
00D257  2               ;
00D257  2               ;__________________________________________________________________________________________________
00D257  2               
00D257  2               
00D257  2               ;
00D257  2               ;__SERIAL_CONSOLE_INIT___________________________________________
00D257  2               ;
00D257  2               ;	INITIALIZE UART
00D257  2               ;	PARAMS:	SER_BAUD NEEDS TO BE SET TO BAUD RATE
00D257  2               ;	1200:	96	 = 1,843,200 / ( 16 X 1200 )
00D257  2               ;	2400:	48	 = 1,843,200 / ( 16 X 2400 )
00D257  2               ;	4800:	24	 = 1,843,200 / ( 16 X 4800 )
00D257  2               ;	9600:	12	 = 1,843,200 / ( 16 X 9600 )
00D257  2               ;	19K2:	06	 = 1,843,200 / ( 16 X 19,200 )
00D257  2               ;	38K4:	03
00D257  2               ;	57K6:	02
00D257  2               ;	115K2:	01
00D257  2               ;
00D257  2               ;_______________________________________________________________
00D257  2               ;
00D257  2               SERIAL_CONSOLE_INIT:
00D257  2  08                   PHP
00D258  2  E2 30                ACCUMULATORINDEX8
00D25A  2               
00D25A  2               ;        LDX     #63             ;
00D25A  2               ;        JSR     RTC_READ        ; get magic number
00D25A  2               ;        CMP     #166            ; is valid?
00D25A  2               ;        BEQ     UART_INIT1
00D25A  2  A9 80                LDA     #$80            ;
00D25C  2  8F 03 FE 00          STA     F:UART3         ; SET DLAB FLAG
00D260  2  A9 0C                LDA     #12             ; SET TO 12 = 9600 BAUD
00D262  2               ;        BRA     UART_INIT2
00D262  2               ;UART_INIT1:
00D262  2               ;        LDA     #$80            ;
00D262  2               ;        STA     F:UART3           ; SET DLAB FLAG
00D262  2               ;        LDX     #41             ;
00D262  2               ;        JSR     RTC_READ        ; get baud rate
00D262  2               UART_INIT2:
00D262  2  8F 00 FE 00          STA     F:UART0         ; save baud rate
00D266  2  A9 00                LDA     #00             ;
00D268  2  8F 01 FE 00          STA     F:UART1         ;
00D26C  2  A9 03                LDA     #03             ;
00D26E  2  8F 03 FE 00          STA     F:UART3         ; SET 8 BIT DATA, 1 STOPBIT
00D272  2  8F 04 FE 00          STA     F:UART4         ;
00D276  2  28                   PLP
00D277  2  60                   RTS
00D278  2               
00D278  2               ;__OUTCH_______________________________________________________
00D278  2               ;
00D278  2               ; OUTPUT CHAR IN LOW BYTE OF ACC TO UART
00D278  2               ;
00D278  2               ;______________________________________________________________
00D278  2               SERIAL_OUTCH:
00D278  2  08                   PHP
00D279  2  E2 30                ACCUMULATORINDEX8
00D27B  2  48                   PHA                     ; STORE ACC
00D27C  2               TX_BUSYLP:
00D27C  2  AF 05 FE 00          LDA     F:UART5         ; READ LINE STATUS REGISTER
00D280  2  29 20                AND     #$20            ; TEST IF UART IS READY TO SEND (BIT 5)
00D282  2  C9 00                CMP     #$00
00D284  2  F0 F6                BEQ     TX_BUSYLP       ; IF NOT REPEAT
00D286  2  68                   PLA                     ; RESTORE ACC
00D287  2  8F 00 FE 00          STA     F:UART0         ; THEN WRITE THE CHAR TO UART
00D28B  2               
00D28B  2  28                   PLP                     ; RESTORE CPU CONTEXT
00D28C  2  60                   RTS                     ; DONE
00D28D  2               
00D28D  2               
00D28D  2               ;__INCHW_______________________________________________________
00D28D  2               ;
00D28D  2               ; INPUT CHAR FROM UART TO ACC  (WAIT FOR CHAR)
00D28D  2               ;
00D28D  2               ;______________________________________________________________
00D28D  2               SERIAL_INCHW:
00D28D  2  08                   PHP
00D28E  2  E2 30                ACCUMULATORINDEX8
00D290  2               SERIAL_INCHW1:
00D290  2  AF 05 FE 00          LDA     F:UART5         ; READ LINE STATUS REGISTER
00D294  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
00D296  2  C9 00                CMP     #$00
00D298  2  F0 F6                BEQ     SERIAL_INCHW1   ; LOOP UNTIL DATA IS READY
00D29A  2  AF 00 FE 00          LDA     F:UART0         ; THEN READ THE CHAR FROM THE UART
00D29E  2               
00D29E  2  28                   PLP                     ; RESTORE CPU CONTEXT
00D29F  2  60                   RTS
00D2A0  2               
00D2A0  2               
00D2A0  2               ;__INCH_______________________________________________________
00D2A0  2               ;
00D2A0  2               ; INPUT CHAR FROM UART TO ACC (DO NOT WAIT FOR CHAR)
00D2A0  2               ; CArry set if invalid character
00D2A0  2               ;______________________________________________________________
00D2A0  2               SERIAL_INCH:
00D2A0  2  08                   PHP
00D2A1  2  E2 30                ACCUMULATORINDEX8
00D2A3  2  AF 05 FE 00          LDA     F:UART5         ; READ LINE STATUS REGISTER
00D2A7  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
00D2A9  2  F0 07                BEQ     SERIAL_INCH1    ; NO CHAR FOUND
00D2AB  2  AF 00 FE 00          LDA     F:UART0         ; THEN READ THE CHAR FROM THE UART
00D2AF  2  28                   PLP                     ; RESTORE CPU CONTEXT
00D2B0  2  18                   CLC
00D2B1  2  60                   RTS
00D2B2  2               SERIAL_INCH1:
00D2B2  2  28                   PLP                     ; RESTORE CPU CONTEXT
00D2B3  2  38                   SEC
00D2B4  2  60                   RTS
00D2B5  2               
00D2B5  1                       .INCLUDE "conlocal.asm"
00D2B5  2               ;__CONLOCAL_______________________________________________________________________________________
00D2B5  2               ;
00D2B5  2               ;	LOCAL CONSOLE DRIVER FOR THE WE816-MARK2
00D2B5  2               ;
00D2B5  2               ;	WRITTEN BY: DAN WERNER -- 8/18/2024
00D2B5  2               ;
00D2B5  2               ;_________________________________________________________________________________________________
00D2B5  2               
00D2B5  2               ;       SETUPVIDEO
00D2B5  2               ;       OutVideoCh
00D2B5  2               ;       SetXYVEC:
00D2B5  2               ;       CPYVVEC:
00D2B5  2               ;        SrlUpVEC:
00D2B5  2               ;       SetColorVEC:
00D2B5  2               ;       ClearScrVec:
00D2B5  2               ;
00D2B5  2               ;       INITKEYBOARD
00D2B5  2               ;       GetKey
00D2B5  2               ;
00D2B5  2               ;;;
00D2B5  2               ;;;
00D2B5  2               ;;; 	VRAM Memory Map
00D2B5  2               ;;;	$1000-$177F	40/80 Text Page 1
00D2B5  2               ;;;	$1800-$1F7F	40/80 Color Page 1
00D2B5  2               ;;;	$2000-$277F	40/80 Text Page 2
00D2B5  2               ;;;	$2800-$2F7F	40/80 Color Page 2
00D2B5  2               ;;;	$2000-$5FFF	HIRES PAGE 1
00D2B5  2               ;;;	$6000-$8FFF	HIRES PAGE 2
00D2B5  2               ;;;	$2000-$BFFF	DOUBLE HIRES
00D2B5  2               ; IO PORTS
00D2B5  2               ; Address|Description                                   |Value          |Value
00D2B5  2               ;--------|----------------------------------------------|---------------|--------
00D2B5  2               ;$fe30   | Scan Line Emulation                          | on            | off
00D2B5  2               ;$fe31   | Display Page                                 | page 0        | page 1
00D2B5  2               ;$fe32   | character generator write offset             | write offset  |
00D2B5  2               ;$fe33   | character generator write                    | Value         |
00D2B5  2               ;$fe34   | device command                               | Command       |
00D2B5  2               ;$fe35   | Text Mode                                    | on            | off
00D2B5  2               ;$fe36   | Lores Mode                                   | on            | off
00D2B5  2               ;$fe37   | Double Lores Mode (must be in lores first)   | on            | off
00D2B5  2               ;$fe38   | Hires Mode                                   | on            | off
00D2B5  2               ;$fe39   | Double Hires Mode (must be in hires first)   | on            | off
00D2B5  2               ;$fe3A   | 80 Col Mode (must be in text mode)           | on            | off
00D2B5  2               ;$fe3b   | Mixed Mode   (must be in lores/hires first)  | on            | off
00D2B5  2               ;$fe3c   | Quad Hires  (must be in hires first)         | on            | off
00D2B5  2               ;$fe3d   | Mono Hires  (must be in hires first)         | on            | off
00D2B5  2               
00D2B5  2               VDP_PAGE        = $fe31
00D2B5  2               VDP_TEXT_MODE   = $fe35
00D2B5  2               VDP_80COL_MODE  = $fe3A
00D2B5  2               
00D2B5  2               
00D2B5  2               
00D2B5  2               
00D2B5  2               ;__SETUPVIDEO____________________________________________________________________________
00D2B5  2               ;   Setup Video registers
00D2B5  2               ;________________________________________________________________________________________
00D2B5  2               SETUPVIDEO:
00D2B5  2  5A                   PHY
00D2B6  2  48                   PHA
00D2B7  2  08                   PHP
00D2B8  2  E2 30                ACCUMULATORINDEX8
00D2BA  2               
00D2BA  2               ;	Setup Width Parm
00D2BA  2  A9 28                LDA     #40
00D2BC  2  8F 43 03 00          STA     F:VIDEOWIDTH
00D2C0  2               
00D2C0  2  A9 01                LDA     #1
00D2C2  2  8F 31 FE 00          STA     F:VDP_PAGE
00D2C6  2               
00D2C6  2  A9 01                LDA     #1
00D2C8  2  8F 35 FE 00          STA     F:VDP_TEXT_MODE
00D2CC  2               
00D2CC  2  A9 02                LDA     #2
00D2CE  2  8F 3A FE 00          STA     F:VDP_80COL_MODE
00D2D2  2               
00D2D2  2  A9 0F                LDA     #$0F
00D2D4  2  8F 44 03 00          STA     F:DEFAULT_COLOR
00D2D8  2               
00D2D8  2  20 9C D4             JSR     ClearScreen
00D2DB  2               
00D2DB  2  28                   PLP
00D2DC  2  68                   PLA
00D2DD  2  7A                   PLY
00D2DE  2  60                   RTS
00D2DF  2               
00D2DF  2               
00D2DF  2               ;__Cursor________________________________________________________________________________
00D2DF  2               ;   Draw A cursor
00D2DF  2               ;
00D2DF  2               ;________________________________________________________________________________________
00D2DF  2               CURSOR:
00D2DF  2  DA                   PHX
00D2E0  2  5A                   PHY
00D2E1  2  48                   PHA
00D2E2  2  08                   PHP
00D2E3  2  E2 20                ACCUMULATOR8
00D2E5  2  C2 10                INDEX16
00D2E7  2  20 A8 D3             JSR     GetVideoAddressOffset
00D2EA  2  BF 00 18 00          LDA     F:$1800,x
00D2EE  2  C9 00                CMP     #$00
00D2F0  2  D0 04                BNE     :+
00D2F2  2  AF 44 03 00          LDA     F:DEFAULT_COLOR
00D2F6  2               :
00D2F6  2  0A                   ASL     a
00D2F7  2  0A                   ASL     a
00D2F8  2  0A                   ASL     a
00D2F9  2  0A                   ASL     a
00D2FA  2  29 F0                AND     #$F0
00D2FC  2  8F 42 03 00          STA     F:CSRCHAR
00D300  2  BF 00 18 00          LDA     F:$1800,x
00D304  2  4A                   LSR     a
00D305  2  4A                   LSR     a
00D306  2  4A                   LSR     a
00D307  2  4A                   LSR     a
00D308  2  29 0F                AND     #$0f
00D30A  2  0F 42 03 00          ORA     F:CSRCHAR
00D30E  2  9F 00 18 00          STA     F:$1800,x
00D312  2  BF 00 10 00          LDA     F:$1000,x
00D316  2  8F 42 03 00          STA     F:CSRCHAR
00D31A  2  28                   PLP
00D31B  2  68                   PLA
00D31C  2  7A                   PLY
00D31D  2  FA                   PLX
00D31E  2  60                   RTS
00D31F  2               
00D31F  2               ;__UnCursor______________________________________________________________________________
00D31F  2               ;   Remove the cursor
00D31F  2               ;
00D31F  2               ;________________________________________________________________________________________
00D31F  2               UNCURSOR:
00D31F  2  80 BE                BRA     CURSOR
00D321  2               
00D321  2               
00D321  2               
00D321  2               
00D321  2               ;__OutVideoCh_____________________________________________________________________________
00D321  2               ;   Output char to screen
00D321  2               ;
00D321  2               ; Char in A
00D321  2               ;________________________________________________________________________________________
00D321  2               OutVideoCh:
00D321  2  DA                   PHX
00D322  2  5A                   PHY
00D323  2  48                   PHA
00D324  2  08                   PHP
00D325  2  E2 30                ACCUMULATORINDEX8
00D327  2  48                   PHA
00D328  2  AF 30 03 00          LDA     F:CSRX
00D32C  2  AA                   TAX
00D32D  2  AF 31 03 00          LDA     F:CSRY
00D331  2  A8                   TAY
00D332  2  68                   PLA
00D333  2  C9 0A                CMP     #10
00D335  2  F0 45                BEQ     OutVideoCh_Exit
00D337  2  C9 0D                CMP     #13
00D339  2  F0 50                BEQ     OutVideoCh_CR
00D33B  2  C9 08                CMP     #8
00D33D  2  D0 03 4C 94          LBEQ    OutVideoCh_BS
00D341  2  D3           
00D342  2  20 A8 D3             JSR     GetVideoAddressOffset
00D345  2  9F 00 10 00          STA     F:$1000,X
00D349  2  AF 44 03 00          LDA     F:DEFAULT_COLOR
00D34D  2  9F 00 18 00          STA     F:$1800,X
00D351  2  E2 10                INDEX8
00D353  2  AF 30 03 00          LDA     F:CSRX
00D357  2  AA                   TAX
00D358  2  E8                   INX
00D359  2  8A                   TXA
00D35A  2  CF 43 03 00          CMP     F:VIDEOWIDTH
00D35E  2  D0 1C                BNE     OutVideoCh_Exit
00D360  2  C8                   INY
00D361  2  A2 00                LDX     #0
00D363  2  C0 18                CPY     #24
00D365  2  D0 15                BNE     OutVideoCh_Exit
00D367  2               OutVideoCh_CR1:
00D367  2  A2 00                LDX     #0
00D369  2  8A                   TXA
00D36A  2  8F 30 03 00          STA     F:CSRX
00D36E  2  A0 17                LDY     #23
00D370  2  98                   TYA
00D371  2  8F 31 03 00          STA     F:CSRY
00D375  2  AF 43 03 00          LDA     F:VIDEOWIDTH
00D379  2  20 15 D4             JSR     ScrollUp
00D37C  2               
00D37C  2               OutVideoCh_Exit:
00D37C  2  8A                   TXA
00D37D  2  8F 30 03 00          STA     F:CSRX
00D381  2  98                   TYA
00D382  2  8F 31 03 00          STA     F:CSRY
00D386  2  28                   PLP
00D387  2  68                   PLA
00D388  2  7A                   PLY
00D389  2  FA                   PLX
00D38A  2  60                   RTS
00D38B  2               OutVideoCh_CR:
00D38B  2  C8                   INY
00D38C  2  C0 18                CPY     #24
00D38E  2  F0 D7                BEQ     OutVideoCh_CR1
00D390  2  A2 00                LDX     #0
00D392  2  80 E8                BRA     OutVideoCh_Exit
00D394  2               OutVideoCh_BS:
00D394  2  E0 00                CPX     #0
00D396  2  F0 03                BEQ     OutVideoCh_BS1
00D398  2  CA                   DEX
00D399  2  80 E1                BRA     OutVideoCh_Exit
00D39B  2               OutVideoCh_BS1:
00D39B  2  C0 00                CPY     #0
00D39D  2  F0 DD                BEQ     OutVideoCh_Exit
00D39F  2  88                   DEY
00D3A0  2  AF 43 03 00          LDA     F:VIDEOWIDTH
00D3A4  2  3A                   DEC     A
00D3A5  2  AA                   TAX
00D3A6  2  80 D4                BRA     OutVideoCh_Exit
00D3A8  2               
00D3A8  2               GetVideoAddressOffset:
00D3A8  2  48                   PHA
00D3A9  2  AF 31 03 00          LDA     F:CSRY
00D3AD  2  C2 30                ACCUMULATORINDEX16
00D3AF  2  29 FF 00             AND     #$00FF
00D3B2  2  8F 36 03 00          STA     F:TEMP
00D3B6  2  18                   CLC
00D3B7  2  0A                   ASL     A
00D3B8  2  0A                   ASL     A
00D3B9  2  0A                   ASL     A
00D3BA  2  0A                   ASL     A
00D3BB  2  0A                   ASL     A
00D3BC  2  48                   PHA
00D3BD  2  AF 36 03 00          LDA     F:TEMP
00D3C1  2  18                   CLC
00D3C2  2  0A                   ASL     A
00D3C3  2  0A                   ASL     A
00D3C4  2  0A                   ASL     A
00D3C5  2  8F 36 03 00          STA     F:TEMP
00D3C9  2  68                   PLA
00D3CA  2  18                   CLC
00D3CB  2  6F 36 03 00          ADC     F:TEMP
00D3CF  2  8F 36 03 00          STA     F:TEMP
00D3D3  2               ; if 80 columns double it.
00D3D3  2  E2 20                ACCUMULATOR8
00D3D5  2  AF 43 03 00          LDA     F:VIDEOWIDTH
00D3D9  2  C9 28                CMP     #40
00D3DB  2  F0 0B                BEQ     :+
00D3DD  2  C2 20                ACCUMULATOR16
00D3DF  2  AF 36 03 00          LDA     F:TEMP
00D3E3  2  0A                   ASL     A
00D3E4  2  8F 36 03 00          STA     F:TEMP
00D3E8  2               :
00D3E8  2  C2 20                ACCUMULATOR16
00D3EA  2  AF 30 03 00          LDA     F:CSRX
00D3EE  2  29 FF 00             AND     #$00FF
00D3F1  2  18                   CLC
00D3F2  2  6F 36 03 00          ADC     F:TEMP
00D3F6  2  AA                   TAX
00D3F7  2  E2 20                ACCUMULATOR8
00D3F9  2  68                   PLA
00D3FA  2  60                   RTS
00D3FB  2               
00D3FB  2               
00D3FB  2               
00D3FB  2               
00D3FB  2               ;__SetColor______________________________________________________________________________
00D3FB  2               ;   Setup 9918 Color
00D3FB  2               ;
00D3FB  2               ; Color in A - High 4 bits background, Low 4 bits Foreground
00D3FB  2               ;________________________________________________________________________________________
00D3FB  2               SetColor:
00D3FB  2  08                   PHP
00D3FC  2  E2 30                ACCUMULATORINDEX8
00D3FE  2  8F 44 03 00          STA     F:DEFAULT_COLOR
00D402  2  28                   PLP
00D403  2  60                   RTS
00D404  2               
00D404  2               ;__SetXY_________________________________________________________________________________
00D404  2               ;   Setup 9918 Cursor Position
00D404  2               ;
00D404  2               ; Screen Coords in X,Y
00D404  2               ;________________________________________________________________________________________
00D404  2               SetXY:
00D404  2  48                   PHA
00D405  2  08                   PHP
00D406  2  E2 30                ACCUMULATORINDEX8
00D408  2  98                   TYA
00D409  2  8F 31 03 00          STA     F:CSRY
00D40D  2  8A                   TXA
00D40E  2  8F 30 03 00          STA     F:CSRX
00D412  2  28                   PLP
00D413  2  68                   PLA
00D414  2  60                   RTS
00D415  2               
00D415  2               ;__ScrollUp______________________________________________________________________________
00D415  2               ;   Scroll the screen up one line
00D415  2               ;
00D415  2               ; number of positions in line in A
00D415  2               
00D415  2               ;________________________________________________________________________________________
00D415  2               ;ScrollUp:
00D415  2               ;        PHA
00D415  2               ;        PHX
00D415  2               ;        PHY
00D415  2               ;        PHP
00D415  2               ;        PHB
00D415  2               ;        SETBANK 0
00D415  2               ;        ACCUMULATORINDEX16
00D415  2               
00D415  2               ;        LDA     #$0397          ; SCROLL SCREEN MEMORY
00D415  2               ;        LDX     #$1028
00D415  2               ;        LDY     #$1000
00D415  2               ;        MVN     #$00,#$00
00D415  2               
00D415  2               ;        LDA     #$0397          ; SCROLL COLOR MEMORY
00D415  2               ;        LDX     #$1828
00D415  2               ;        LDY     #$1800
00D415  2               ;        MVN     #$00,#$00
00D415  2               
00D415  2               ;        ACCUMULATORINDEX8
00D415  2               ;        LDX     #$00            ; CLEAR BOTTOM LINE
00D415  2               ;ScrollUpLoop:
00D415  2               ;        LDA     #32
00D415  2               ;        STA     F:$1398,X
00D415  2               ;        LDA     F:DEFAULT_COLOR
00D415  2               ;        STA     F:$1B98,X
00D415  2               ;        INX
00D415  2               ;        CPX     #40
00D415  2               ;        BNE     ScrollUpLoop
00D415  2               ;        LDX     #0
00D415  2               ;        LDY     #23
00D415  2               ;        JSR     SetXY
00D415  2               
00D415  2               ;        PLB
00D415  2               ;        PLP
00D415  2               ;        PLY
00D415  2               ;        PLX
00D415  2               ;        PLA
00D415  2               ;        RTS
00D415  2               
00D415  2               
00D415  2               
00D415  2               ;__ScrollUp______________________________________________________________________________
00D415  2               ;   Scroll the screen up one line
00D415  2               ;
00D415  2               ; number of positions in line in A
00D415  2               
00D415  2               ;________________________________________________________________________________________
00D415  2               ScrollUp:
00D415  2  48                   PHA
00D416  2  DA                   PHX
00D417  2  5A                   PHY
00D418  2  08                   PHP
00D419  2  8B                   PHB
00D41A  2  DA A2 00 DA          SETBANK 0
00D41E  2  AB FA        
00D420  2               ; if 80 columns double it.
00D420  2  E2 20                ACCUMULATOR8
00D422  2  AF 43 03 00          LDA     F:VIDEOWIDTH
00D426  2  C9 28                CMP     #40
00D428  2  F0 34                BEQ     ScrollUp_40
00D42A  2               
00D42A  2  C2 30                ACCUMULATORINDEX16
00D42C  2  A9 29 07             LDA     #$0729          ; SCROLL SCREEN MEMORY
00D42F  2  A2 50 10             LDX     #$1050
00D432  2  A0 00 10             LDY     #$1000
00D435  2  54 00 00             MVN     #$00,#$00
00D438  2               
00D438  2  A9 29 07             LDA     #$0729          ; SCROLL COLOR MEMORY
00D43B  2  A2 50 18             LDX     #$1850
00D43E  2  A0 00 18             LDY     #$1800
00D441  2  54 00 00             MVN     #$00,#$00
00D444  2               
00D444  2  E2 30                ACCUMULATORINDEX8
00D446  2  A2 00                LDX     #$00            ; CLEAR BOTTOM LINE
00D448  2               
00D448  2               ScrollUpLoop80:
00D448  2  A9 20                LDA     #32
00D44A  2  9F 30 17 00          STA     F:$1730,X
00D44E  2  AF 44 03 00          LDA     F:DEFAULT_COLOR
00D452  2  9F 30 1F 00          STA     F:$1F30,X
00D456  2  E8                   INX
00D457  2  E0 50                CPX     #80
00D459  2  D0 ED                BNE     ScrollUpLoop80
00D45B  2  4C 8F D4             JMP     ScrollUpEnd
00D45E  2               
00D45E  2               ScrollUp_40:
00D45E  2  C2 30                ACCUMULATORINDEX16
00D460  2               
00D460  2  A9 97 03             LDA     #$0397          ; SCROLL SCREEN MEMORY
00D463  2  A2 28 10             LDX     #$1028
00D466  2  A0 00 10             LDY     #$1000
00D469  2  54 00 00             MVN     #$00,#$00
00D46C  2               
00D46C  2  A9 97 03             LDA     #$0397          ; SCROLL COLOR MEMORY
00D46F  2  A2 28 18             LDX     #$1828
00D472  2  A0 00 18             LDY     #$1800
00D475  2  54 00 00             MVN     #$00,#$00
00D478  2               
00D478  2  E2 30                ACCUMULATORINDEX8
00D47A  2  A2 00                LDX     #$00            ; CLEAR BOTTOM LINE
00D47C  2               ScrollUpLoop40:
00D47C  2  A9 20                LDA     #32
00D47E  2  9F 98 13 00          STA     F:$1398,X
00D482  2  AF 44 03 00          LDA     F:DEFAULT_COLOR
00D486  2  9F 98 1B 00          STA     F:$1B98,X
00D48A  2  E8                   INX
00D48B  2  E0 28                CPX     #40
00D48D  2  D0 ED                BNE     ScrollUpLoop40
00D48F  2               ScrollUpEnd:
00D48F  2  A2 00                LDX     #0
00D491  2  A0 17                LDY     #23
00D493  2  20 04 D4             JSR     SetXY
00D496  2  AB                   PLB
00D497  2  28                   PLP
00D498  2  7A                   PLY
00D499  2  FA                   PLX
00D49A  2  68                   PLA
00D49B  2  60                   RTS
00D49C  2               
00D49C  2               
00D49C  2               ;__ClearScreen___________________________________________________________________________
00D49C  2               ;  clear Screen
00D49C  2               ;________________________________________________________________________________________
00D49C  2               ClearScreen:
00D49C  2  5A                   PHY
00D49D  2  48                   PHA
00D49E  2  08                   PHP
00D49F  2  C2 10                INDEX16
00D4A1  2  E2 20                ACCUMULATOR8
00D4A3  2               
00D4A3  2               
00D4A3  2               ; Now let's clear
00D4A3  2  AF 43 03 00          LDA     F:VIDEOWIDTH
00D4A7  2  C9 50                CMP     #80
00D4A9  2  F0 05                BEQ     :+
00D4AB  2  A2 C1 03             LDX     #$03C1
00D4AE  2  80 03                BRA     :++
00D4B0  2               :
00D4B0  2  A2 80 07             LDX     #$0780
00D4B3  2               :
00D4B3  2  A9 20                LDA     #32
00D4B5  2               ClearScreen1:
00D4B5  2  CA                   DEX
00D4B6  2  9F 00 10 00          STA     F:$1000,X
00D4BA  2  D0 F9                BNE     ClearScreen1
00D4BC  2               
00D4BC  2  AF 43 03 00          LDA     F:VIDEOWIDTH
00D4C0  2  C9 50                CMP     #80
00D4C2  2  F0 05                BEQ     :+
00D4C4  2  A2 C1 03             LDX     #$03C1
00D4C7  2  80 03                BRA     :++
00D4C9  2               :
00D4C9  2  A2 80 07             LDX     #$0780
00D4CC  2               :
00D4CC  2  AF 44 03 00          LDA     F:DEFAULT_COLOR
00D4D0  2               ClearScreen2:
00D4D0  2  CA                   DEX
00D4D1  2  9F 00 18 00          STA     F:$1800,X
00D4D5  2  D0 F9                BNE     ClearScreen2
00D4D7  2               
00D4D7  2               
00D4D7  2  E2 10                INDEX8
00D4D9  2  A2 00                LDX     #0
00D4DB  2  9B                   TXY
00D4DC  2  20 04 D4             JSR     SetXY
00D4DF  2  28                   PLP
00D4E0  2  68                   PLA
00D4E1  2  7A                   PLY
00D4E2  2  60                   RTS
00D4E3  2               
00D4E3  2               
00D4E3  2               
00D4E3  2               
00D4E3  2               ;___________________________________________________________________________________________________
00D4E3  2               ; Initialize Keyboard
00D4E3  2               ;___________________________________________________________________________________________________
00D4E3  2               
00D4E3  2               INITKEYBOARD:
00D4E3  2  08                   PHP
00D4E4  2  E2 30                ACCUMULATORINDEX8
00D4E6  2  48                   PHA
00D4E7  2  A9 F0                LDA     #$F0
00D4E9  2  8F 32 03 00          STA     F:LEDS
00D4ED  2  A9 00                LDA     #00
00D4EF  2  8D 33 03             STA     KeyLock
00D4F2  2  68                   PLA
00D4F3  2  28                   PLP
00D4F4  2  60                   RTS
00D4F5  2               
00D4F5  2               ;___________________________________________________________________________________________________
00D4F5  2               ; Get a key from Keyboard
00D4F5  2               ;
00D4F5  2               ; Returns Key in A
00D4F5  2               ;___________________________________________________________________________________________________
00D4F5  2               
00D4F5  2               GetKey:
00D4F5  2  08                   PHP
00D4F6  2  E2 30                ACCUMULATORINDEX8
00D4F8  2  DA                   PHX
00D4F9  2  5A                   PHY
00D4FA  2               
00D4FA  2               GetKey_Loop:
00D4FA  2  20 65 D7             JSR     kbdDelay
00D4FD  2  20 2E D5             JSR     ScanKeyboard
00D500  2  C9 FF                CMP     #$FF
00D502  2  F0 F6                BEQ     GetKey_Loop
00D504  2  8F 37 03 00          STA     F:TEMP+1
00D508  2  20 B0 D5             JSR     ModifierKeyCheck
00D50B  2  8F 34 03 00          STA     F:ScannedKey
00D50F  2               GetKey_loop1:
00D50F  2  20 65 D7             JSR     kbdDelay
00D512  2  20 2E D5             JSR     ScanKeyboard
00D515  2  CF 37 03 00          CMP     F:TEMP+1
00D519  2  F0 F4                BEQ     GetKey_loop1
00D51B  2               
00D51B  2  AF 34 03 00          LDA     F:ScannedKey
00D51F  2  20 EF D5             JSR     DecodeKeyboard
00D522  2               
00D522  2  C9 FF                CMP     #$FF
00D524  2  F0 D4                BEQ     GetKey_Loop
00D526  2  C9 00                CMP     #$00
00D528  2  F0 D0                BEQ     GetKey_Loop
00D52A  2  7A                   PLY
00D52B  2  FA                   PLX
00D52C  2  28                   PLP
00D52D  2  60                   RTS
00D52E  2               
00D52E  2               
00D52E  2               ;___________________________________________________________________________________________________
00D52E  2               ; Scan Keyboard
00D52E  2               ;
00D52E  2               ; Returns Scancode in A
00D52E  2               ;
00D52E  2               ;___________________________________________________________________________________________________
00D52E  2               ScanKeyboard:
00D52E  2  08                   PHP
00D52F  2  E2 30                ACCUMULATORINDEX8
00D531  2  DA                   PHX
00D532  2  5A                   PHY
00D533  2  A9 FF                LDA     #$ff            ; SET OUTPUT DIRECTION
00D535  2  8F 22 FE 00          STA     F:via2ddrb      ; write value
00D539  2  A9 00                LDA     #$00            ; SET INPUT DIRECTION
00D53B  2  8F 23 FE 00          STA     F:via2ddra      ; write value
00D53F  2               
00D53F  2  A0 00                LDY     #$00            ; SET ROW AND LEDS
00D541  2               outerScanLoop:
00D541  2  C0 09                CPY     #09
00D543  2  F0 46                BEQ     KeyNotFound
00D545  2  98                   TYA
00D546  2  8F 36 03 00          STA     F:TEMP
00D54A  2  AF 32 03 00          LDA     F:LEDS
00D54E  2  0F 36 03 00          ORA     F:TEMP
00D552  2  8F 20 FE 00          STA     F:via2regb      ; write value
00D556  2               innerScanLoop:
00D556  2  AF 21 FE 00          LDA     F:via2rega      ; read value
00D55A  2  A2 00                LDX     #$00
00D55C  2  C9 FF                CMP     #$FF            ;NO KEY PRESSED
00D55E  2  F0 27                BEQ     exitInnerScanLoop
00D560  2  C9 FE                CMP     #$FE            ; COL 1 key Pressed
00D562  2  F0 2D                BEQ     keyFound
00D564  2  E8                   INX
00D565  2  C9 FD                CMP     #$FD            ; COL 2 key Pressed
00D567  2  F0 28                BEQ     keyFound
00D569  2  E8                   INX
00D56A  2  C9 FB                CMP     #$FB            ; COL 3 key Pressed
00D56C  2  F0 23                BEQ     keyFound
00D56E  2  E8                   INX
00D56F  2  C9 F7                CMP     #$F7            ; COL 4 key Pressed
00D571  2  F0 1E                BEQ     keyFound
00D573  2  E8                   INX
00D574  2  C9 EF                CMP     #$EF            ; COL 5 key Pressed
00D576  2  F0 19                BEQ     keyFound
00D578  2  E8                   INX
00D579  2  C9 DF                CMP     #$DF            ; COL 6 key Pressed
00D57B  2  F0 14                BEQ     keyFound
00D57D  2  E8                   INX
00D57E  2  C9 BF                CMP     #$BF            ; COL 7 key Pressed
00D580  2  F0 0F                BEQ     keyFound
00D582  2  E8                   INX
00D583  2  C9 7F                CMP     #$7F            ; COL 8 key Pressed
00D585  2  F0 0A                BEQ     keyFound
00D587  2               exitInnerScanLoop:
00D587  2  C8                   INY
00D588  2  4C 41 D5             JMP     outerScanLoop
00D58B  2               KeyNotFound:
00D58B  2  A9 FF                LDA     #$FF
00D58D  2  7A                   PLY
00D58E  2  FA                   PLX
00D58F  2  28                   PLP
00D590  2  60                   RTS
00D591  2               keyFound:
00D591  2  8A                   TXA
00D592  2  8F 36 03 00          STA     F:TEMP
00D596  2  98                   TYA
00D597  2  18                   CLC
00D598  2  0A                   ASL
00D599  2  0A                   ASL
00D59A  2  0A                   ASL
00D59B  2  18                   CLC
00D59C  2  6F 36 03 00          ADC     F:TEMP
00D5A0  2  C9 30                CMP     #48
00D5A2  2  F0 E7                BEQ     KeyNotFound
00D5A4  2  C9 31                CMP     #49
00D5A6  2  F0 E3                BEQ     KeyNotFound
00D5A8  2  C9 32                CMP     #50
00D5AA  2  F0 DF                BEQ     KeyNotFound
00D5AC  2  7A                   PLY
00D5AD  2  FA                   PLX
00D5AE  2  28                   PLP
00D5AF  2  60                   RTS
00D5B0  2               
00D5B0  2               ;___________________________________________________________________________________________________
00D5B0  2               ; Check for Modifier keys (Shift, Control, Graph/Alt)
00D5B0  2               ; Requires Scancode in A
00D5B0  2               ; Returns modified Scancode in A
00D5B0  2               ;
00D5B0  2               ;___________________________________________________________________________________________________
00D5B0  2               ModifierKeyCheck:
00D5B0  2  08                   PHP
00D5B1  2  E2 30                ACCUMULATORINDEX8
00D5B3  2  48                   PHA
00D5B4  2               ; Check for Modifiers
00D5B4  2  AF 32 03 00          LDA     F:LEDS
00D5B8  2  09 06                ORA     #06
00D5BA  2  8F 20 FE 00          STA     F:via2regb      ; write value
00D5BE  2  AF 21 FE 00          LDA     F:via2rega      ; read value
00D5C2  2  C9 FF                CMP     #$FF            ;NO KEY PRESSED
00D5C4  2  F0 26                BEQ     exit_Scan
00D5C6  2  C9 FE                CMP     #$FE            ; COL 1 key Pressed
00D5C8  2  D0 06                BNE     check_Ctrl
00D5CA  2  68                   PLA
00D5CB  2  18                   CLC
00D5CC  2  69 48                ADC     #72
00D5CE  2  28                   PLP
00D5CF  2  60                   RTS
00D5D0  2               check_Ctrl:
00D5D0  2  C9 FD                CMP     #$FD            ; COL 2 key Pressed
00D5D2  2  D0 0A                BNE     check_Graph
00D5D4  2  68                   PLA
00D5D5  2  C9 30                CMP     #48
00D5D7  2  B0 03                BCS     skip_Ctrl
00D5D9  2  18                   CLC
00D5DA  2  69 90                ADC     #144
00D5DC  2               skip_Ctrl:
00D5DC  2  28                   PLP
00D5DD  2  60                   RTS
00D5DE  2               check_Graph:
00D5DE  2  C9 FB                CMP     #$FB            ; COL 3 key Pressed
00D5E0  2  D0 0A                BNE     exit_Scan
00D5E2  2               check_Graph1:
00D5E2  2  68                   PLA
00D5E3  2  C9 30                CMP     #48
00D5E5  2  B0 F5                BCS     skip_Ctrl
00D5E7  2  18                   CLC
00D5E8  2  69 C0                ADC     #192
00D5EA  2  28                   PLP
00D5EB  2  60                   RTS
00D5EC  2               exit_Scan:
00D5EC  2  68                   PLA
00D5ED  2  28                   PLP
00D5EE  2  60                   RTS
00D5EF  2               
00D5EF  2               
00D5EF  2               ;___________________________________________________________________________________________________
00D5EF  2               ; Decode Keyboard
00D5EF  2               ;
00D5EF  2               ; Scancode in A
00D5EF  2               ; Returns Decoded Ascii in A
00D5EF  2               ;
00D5EF  2               ;___________________________________________________________________________________________________
00D5EF  2               DecodeKeyboard:
00D5EF  2  08                   PHP
00D5F0  2  E2 30                ACCUMULATORINDEX8
00D5F2  2  DA                   PHX
00D5F3  2  C9 33                CMP     #51             ; is CapsLock
00D5F5  2  F0 19                BEQ     is_CapsLock
00D5F7  2  C9 34                CMP     #52             ; is graphLock?
00D5F9  2  F0 55                BEQ     is_GraphLock
00D5FB  2  C9 30                CMP     #48
00D5FD  2  B0 09                BCS     skip_Lock
00D5FF  2  C9 16                CMP     #22
00D601  2  90 05                BCC     skip_Lock
00D603  2  18                   CLC
00D604  2  6F 33 03 00          ADC     F:KeyLock
00D608  2               skip_Lock:
00D608  2  AA                   TAX
00D609  2  BF 75 D6 00          LDA     F:DecodeTable,X
00D60D  2  FA                   PLX
00D60E  2  28                   PLP
00D60F  2  60                   RTS
00D610  2               is_CapsLock:
00D610  2               ; check for toggle and set LEDs
00D610  2  AF 32 03 00          LDA     F:LEDS
00D614  2  29 10                AND     #$10
00D616  2  C9 00                CMP     #$00
00D618  2  F0 1B                BEQ     Cap_off
00D61A  2  AF 32 03 00          LDA     F:LEDS
00D61E  2  29 C0                AND     #$C0
00D620  2  09 20                ORA     #$20
00D622  2  8F 32 03 00          STA     F:LEDS
00D626  2  8F 20 FE 00          STA     F:via2regb      ; write value
00D62A  2  A9 48                LDA     #72
00D62C  2  8F 33 03 00          STA     F:KeyLock
00D630  2  A9 FF                LDA     #$FF
00D632  2  FA                   PLX
00D633  2  28                   PLP
00D634  2  60                   RTS
00D635  2               Cap_off:
00D635  2  AF 32 03 00          LDA     F:LEDS
00D639  2  29 C0                AND     #$C0
00D63B  2  09 30                ORA     #$30
00D63D  2  8F 32 03 00          STA     F:LEDS
00D641  2  8F 20 FE 00          STA     F:via2regb      ; write value
00D645  2  A9 00                LDA     #0
00D647  2  8F 33 03 00          STA     F:KeyLock
00D64B  2  A9 FF                LDA     #$FF
00D64D  2  FA                   PLX
00D64E  2  28                   PLP
00D64F  2  60                   RTS
00D650  2               is_GraphLock:
00D650  2               ; check for toggle and set LEDs
00D650  2  AF 32 03 00          LDA     F:LEDS
00D654  2  29 20                AND     #$20
00D656  2  C9 00                CMP     #$00
00D658  2  F0 DB                BEQ     Cap_off
00D65A  2  AF 32 03 00          LDA     F:LEDS
00D65E  2  29 C0                AND     #$C0
00D660  2  09 10                ORA     #$10
00D662  2  8F 32 03 00          STA     F:LEDS
00D666  2  8F 20 FE 00          STA     F:via2regb      ; write value
00D66A  2  A9 C0                LDA     #192
00D66C  2  8F 33 03 00          STA     F:KeyLock
00D670  2  A9 FF                LDA     #$FF
00D672  2  FA                   PLX
00D673  2  28                   PLP
00D674  2  60                   RTS
00D675  2               
00D675  2               DecodeTable:
00D675  2  30 31 32 33          .BYTE   '0','1','2','3','4','5','6','7'; 0
00D679  2  34 35 36 37  
00D67D  2  38 39 2D 3D          .BYTE   '8','9','-','=','\','[',']',';'; 8
00D681  2  5C 5B 5D 3B  
00D685  2  27 7E 2C 2E          .BYTE   39,'~',',','.','/',00,'a','b'; 16
00D689  2  2F 00 61 62  
00D68D  2  63 64 65 66          .BYTE   'c','d','e','f','g','h','i','j'; 24
00D691  2  67 68 69 6A  
00D695  2  6B 6C 6D 6E          .BYTE   'k','l','m','n','o','p','q','r'; 32
00D699  2  6F 70 71 72  
00D69D  2  73 74 75 76          .BYTE   's','t','u','v','w','x','y','z'; 40
00D6A1  2  77 78 79 7A  
00D6A5  2  FF FF FF FF          .BYTE   $FF,$FF,$FF,$FF,$FF,11,12,14; 48
00D6A9  2  FF 0B 0C 0E  
00D6AD  2  0F 10 1B 09          .BYTE   15,16,27,09,03,08,17,13; 56
00D6B1  2  03 08 11 0D  
00D6B5  2  20 1C 1D 1E          .BYTE   32,28,29,30,31,01,02,04; 64
00D6B9  2  1F 01 02 04  
00D6BD  2               
00D6BD  2  29 21 40 23          .BYTE   ')','!','@','#','$','%','^','&'; 72  ; Shift
00D6C1  2  24 25 5E 26  
00D6C5  2  2A 28 5F 2B          .BYTE   '*','(','_','+','|','{','}',':'; 80
00D6C9  2  7C 7B 7D 3A  
00D6CD  2  22 7E 3C 3E          .BYTE   34,'~','<','>','?',00,'A','B'; 88
00D6D1  2  3F 00 41 42  
00D6D5  2  43 44 45 46          .BYTE   'C','D','E','F','G','H','I','J'; 96
00D6D9  2  47 48 49 4A  
00D6DD  2  4B 4C 4D 4E          .BYTE   'K','L','M','N','O','P','Q','R'; 104
00D6E1  2  4F 50 51 52  
00D6E5  2  53 54 55 56          .BYTE   'S','T','U','V','W','X','Y','Z'; 112
00D6E9  2  57 58 59 5A  
00D6ED  2  FF FF FF FF          .BYTE   $FF,$FF,$FF,$FF,$FF,18,19,20; 120
00D6F1  2  FF 12 13 14  
00D6F5  2  15 16 1B 09          .BYTE   21,22,27,09,03,08,23,13; 128
00D6F9  2  03 08 17 0D  
00D6FD  2  20 1C 1D 1E          .BYTE   32,28,29,30,31,01,02,04; 136
00D701  2  1F 01 02 04  
00D705  2               
00D705  2  30 31 32 33          .BYTE   '0','1','2','3','4','5','6','7'; 144 ; Control
00D709  2  34 35 36 37  
00D70D  2  38 39 EA E1          .BYTE   '8','9',234,225,224,248,249,000; 152
00D711  2  E0 F8 F9 00  
00D715  2  FA FB FE B0          .BYTE   250,251,254,176,177,00,01,02; 160
00D719  2  B1 00 01 02  
00D71D  2  03 04 05 06          .BYTE   03,04,05,06,07,08,09,10; 168
00D721  2  07 08 09 0A  
00D725  2  0B 0C 0D 0E          .BYTE   11,12,13,14,15,16,17,18; 176
00D729  2  0F 10 11 12  
00D72D  2  13 14 15 16          .BYTE   19,20,21,22,23,24,25,26; 184
00D731  2  17 18 19 1A  
00D735  2               
00D735  2  00 B2 B3 B4          .BYTE   000,178,179,180,181,182,183,184; 192 ; Graph
00D739  2  B5 B6 B7 B8  
00D73D  2  B9 BA BB BC          .BYTE   185,186,187,188,189,190,191,192; 200
00D741  2  BD BE BF C0  
00D745  2  C1 C2 C3 C4          .BYTE   193,194,195,196,197,198,199,200; 208
00D749  2  C5 C6 C7 C8  
00D74D  2  C9 CA CB CC          .BYTE   201,202,203,204,205,206,207,208; 216
00D751  2  CD CE CF D0  
00D755  2  D1 D2 D3 D4          .BYTE   209,210,211,212,213,214,215,216; 224
00D759  2  D5 D6 D7 D8  
00D75D  2  D9 DA DB DC          .BYTE   217,218,219,220,221,222,223,167; 232
00D761  2  DD DE DF A7  
00D765  2               
00D765  2               
00D765  2               
00D765  2               
00D765  2               ;***********************************************************************************;
00D765  2               ;
00D765  2               ;  delay
00D765  2               kbdDelay:
00D765  2  08                   PHP
00D766  2  E2 30                ACCUMULATORINDEX8
00D768  2  48                   PHA
00D769  2  DA                   PHX
00D76A  2  A2 40                LDX     #KBD_DELAY
00D76C  2  A9 40                LDA     #$40            ; set for 1024 cycles (MHZ)
00D76E  2  8F 29 FE 00          STA     F:via2t2ch      ; set VIA 2 T2C_h
00D772  2               kbdDelay_a:
00D772  2  AF 2D FE 00          LDA     F:via2ifr       ; get VIA 2 IFR
00D776  2  29 20                AND     #$20            ; mask T2 interrupt
00D778  2  F0 F8                BEQ     kbdDelay_a      ; loop until T2 interrupt
00D77A  2  CA                   DEX
00D77B  2  D0 F5                BNE     kbdDelay_a
00D77D  2  FA                   PLX
00D77E  2  68                   PLA
00D77F  2  28                   PLP
00D780  2  60                   RTS
00D781  2               ;________________________________________________________________________________________
00D781  2               
00D781  1                       .INCLUDE "iec.asm"
00D781  2                       .A8
00D781  2                       .I8
00D781  2               
00D781  2               ;__IEC_____________________________________________________________________________________________
00D781  2               ;
00D781  2               ;	IEC SERIAL DRIVER
00D781  2               ;   ORIGINALLY FROM COMMODORE 64 KERNAL
00D781  2               ;	CONVERTED FOR 65816 BY: DAN WERNER -- 4/6/2021
00D781  2               ;
00D781  2               ;__________________________________________________________________________________________________
00D781  2               
00D781  2               ;***********************************************************************************;
00D781  2               ;
00D781  2               ; set serial data out high
00D781  2               
00D781  2               LAB_E4A0:
00D781  2  AD 2C FE             LDA     via2pcr         ; get VIA 2 PCR
00D784  2  29 DF                AND     #$DF            ; set CB2 low, serial data out high
00D786  2  8D 2C FE             STA     via2pcr         ; set VIA 2 PCR
00D789  2  60                   RTS
00D78A  2               
00D78A  2               
00D78A  2               ;***********************************************************************************;
00D78A  2               ;
00D78A  2               ; set serial data out low
00D78A  2               
00D78A  2               LAB_E4A9:
00D78A  2  AD 2C FE             LDA     via2pcr         ; get VIA 2 PCR
00D78D  2  09 20                ORA     #$20            ; set CB2 high, serial data out low
00D78F  2  8D 2C FE             STA     via2pcr         ; set VIA 2 PCR
00D792  2  60                   RTS
00D793  2               
00D793  2               
00D793  2               ;***********************************************************************************;
00D793  2               ;
00D793  2               ; get serial clock status
00D793  2               
00D793  2               LAB_E4B2:
00D793  2  AD 1F FE             LDA     via1ora         ; get VIA 1 DRA, no handshake
00D796  2  CD 1F FE             CMP     via1ora         ; compare with self
00D799  2  D0 F8                BNE     LAB_E4B2        ; loop if changing
00D79B  2               
00D79B  2  4A                   LSR                     ; shift serial clock to Cb
00D79C  2  60                   RTS
00D79D  2               
00D79D  2               
00D79D  2               ;***********************************************************************************;
00D79D  2               ;
00D79D  2               ; command a serial bus device to TALK
00D79D  2               
00D79D  2               ; to use this routine the accumulator must first be loaded with a device number
00D79D  2               ; between 4 and 30. When called this routine converts this device number to a talk
00D79D  2               ; address. Then this data is transmitted as a command on the Serial bus.
00D79D  2               
00D79D  2               LAB_EE14:
00D79D  2  09 40                ORA     #$40            ; OR with the TALK command
00D79F  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_2009
00D7A0  2               
00D7A0  2               
00D7A0  2               ;***********************************************************************************;
00D7A0  2               ;
00D7A0  2               ; command devices on the serial bus to LISTEN
00D7A0  2               
00D7A0  2               ; this routine will command a device on the serial bus to receive data. The
00D7A0  2               ; accumulator must be loaded with a device number between 4 and 31 before calling
00D7A0  2               ; this routine. LISTEN convert this to a listen address then transmit this data as
00D7A0  2               ; a command on the serial bus. The specified device will then go into listen mode
00D7A0  2               ; and be ready to accept information.
00D7A0  2               
00D7A0  2               LAB_EE17:
00D7A0  2  09 20                ORA     #$20            ; OR with the LISTEN command
00D7A2  2  20 D7 DB             JSR     LAB_F160        ; check RS232 bus idle, setup timers
00D7A5  2               
00D7A5  2               ;***********************************************************************************;
00D7A5  2               ;
00D7A5  2               ; send control character
00D7A5  2               
00D7A5  2               LAB_EE1C:
00D7A5  2  48                   PHA                     ; save device address
00D7A6  2  2C 12 03             BIT     IECDCF          ; test deferred character flag
00D7A9  2  10 0D                BPL     LAB_EE2B        ; branch if no defered character
00D7AB  2               
00D7AB  2  38                   SEC                     ; flag EOI
00D7AC  2  6E 14 03             ROR     IECBCI          ; rotate into EOI flag byte
00D7AF  2  20 D7 D7             JSR     LAB_EE49        ; Tx byte on serial bus
00D7B2  2               
00D7B2  2  4E 12 03             LSR     IECDCF          ; clear deferred character flag
00D7B5  2  4E 14 03             LSR     IECBCI          ; clear EOI flag
00D7B8  2               LAB_EE2B:
00D7B8  2               
00D7B8  2  68                   PLA                     ; restore device address
00D7B9  2  8D 13 03             STA     IECDC           ; save as serial defered character
00D7BC  2  20 81 D7             JSR     LAB_E4A0        ; set serial data out high
00D7BF  2  C9 3F                CMP     #$3F            ; compare read byte with $3F
00D7C1  2  D0 03                BNE     LAB_EE38        ; branch if not $3F, this branch will always be taken as
00D7C3  2               ; after VIA 2's PCR is read it is ANDed with $DF, so the
00D7C3  2               ; result can never be $3F
00D7C3  2               
00D7C3  2  20 33 D9             JSR     LAB_EF84        ; set serial clock high
00D7C6  2               
00D7C6  2               LAB_EE38:
00D7C6  2  AD 1F FE             LDA     via1ora         ; get VIA 1 DRA, no handshake
00D7C9  2  09 80                ORA     #$80            ; set serial ATN low
00D7CB  2  8D 1F FE             STA     via1ora         ; set VIA 1 DRA, no handshake
00D7CE  2               
00D7CE  2               
00D7CE  2               ;***********************************************************************************;
00D7CE  2               ;
00D7CE  2               ; if the code drops through to here the serial clock is low and the serial data has been
00D7CE  2               ; released so the following code will have no effect apart from delaying the first byte
00D7CE  2               ; by 1ms
00D7CE  2               
00D7CE  2               ;## set clk/data, wait and Tx byte on serial bus
00D7CE  2               LAB_EE40:
00D7CE  2  20 3C D9             JSR     LAB_EF8D        ; set serial clock low
00D7D1  2  20 81 D7             JSR     LAB_E4A0        ; set serial data out high
00D7D4  2  20 45 D9             JSR     LAB_EF96        ; 1ms delay
00D7D7  2               
00D7D7  2               ;***********************************************************************************;
00D7D7  2               ;
00D7D7  2               ; Tx byte on serial bus
00D7D7  2               
00D7D7  2               LAB_EE49:
00D7D7  2  78                   SEI                     ; disable interrupts
00D7D8  2  20 81 D7             JSR     LAB_E4A0        ; set serial data out high
00D7DB  2  20 93 D7             JSR     LAB_E4B2        ; get serial clock status
00D7DE  2  4A                   LSR                     ; shift serial data to Cb
00D7DF  2  B0 6E                BCS     LAB_EEB4        ; if data high do device not present
00D7E1  2  20 33 D9             JSR     LAB_EF84        ; set serial clock high
00D7E4  2  2C 14 03             BIT     IECBCI          ; test EOI flag
00D7E7  2  10 0C                BPL     LAB_EE66        ; branch if not EOI
00D7E9  2               ; I think this is the EOI sequence so the serial clock has been released and the serial
00D7E9  2               ; data is being held low by the peripherals. first up wait for the serial data to rise
00D7E9  2               
00D7E9  2               LAB_EE5A:
00D7E9  2  20 93 D7             JSR     LAB_E4B2        ; get serial clock status
00D7EC  2  4A                   LSR                     ; shift serial data to Cb
00D7ED  2  90 FA                BCC     LAB_EE5A        ; loop if data low
00D7EF  2               
00D7EF  2               ; now the data is high, EOI is signalled by waiting for at least 200us without pulling
00D7EF  2               ; the serial clock line low again. the listener should respond by pulling the serial
00D7EF  2               ; data line low
00D7EF  2               
00D7EF  2               LAB_EE60:
00D7EF  2  20 93 D7             JSR     LAB_E4B2        ; get serial clock status
00D7F2  2  4A                   LSR                     ; shift serial data to Cb
00D7F3  2  B0 FA                BCS     LAB_EE60        ; loop if data high
00D7F5  2               
00D7F5  2               ; the serial data has gone low ending the EOI sequence, now just wait for the serial
00D7F5  2               ; data line to go high again or, if this isn't an EOI sequence, just wait for the serial
00D7F5  2               ; data to go high the first time
00D7F5  2               
00D7F5  2               LAB_EE66:
00D7F5  2  20 93 D7             JSR     LAB_E4B2        ; get serial clock status
00D7F8  2  4A                   LSR                     ; shift serial data to Cb
00D7F9  2  90 FA                BCC     LAB_EE66        ; loop if data low
00D7FB  2               
00D7FB  2               ; serial data is high now pull the clock low, preferably within 60us
00D7FB  2               
00D7FB  2  20 3C D9             JSR     LAB_EF8D        ; set serial clock low
00D7FE  2               
00D7FE  2               ; now the Vic has to send the eight bits, LSB first. first it sets the serial data line
00D7FE  2               ; to reflect the bit in the byte, then it sets the serial clock to high. The serial
00D7FE  2               ; clock is left high for 26 cycles, 23us on a PAL Vic, before it is again pulled low
00D7FE  2               ; and the serial data is allowed high again
00D7FE  2               
00D7FE  2  A9 08                LDA     #$08            ; eight bits to do
00D800  2  8D 15 03             STA     IECBTC          ; set serial bus bit count
00D803  2               LAB_EE73:
00D803  2  AD 1F FE             LDA     via1ora         ; get VIA 1 DRA, no handshake
00D806  2  CD 1F FE             CMP     via1ora         ; compare with self
00D809  2  D0 F8                BNE     LAB_EE73        ; loop if changing
00D80B  2               
00D80B  2  4A                   LSR                     ; serial clock to carry
00D80C  2  4A                   LSR                     ; serial data to carry
00D80D  2  90 43                BCC     LAB_EEB7        ; if data low do timeout on serial bus
00D80F  2  20 43 DC             JSR     IEC_DELAY
00D812  2  6E 13 03             ROR     IECDC           ; rotate transmit byte
00D815  2  B0 05                BCS     LAB_EE88        ; branch if bit = 1
00D817  2               
00D817  2  20 8A D7             JSR     LAB_E4A9        ; else set serial data out low
00D81A  2  D0 03                BNE     LAB_EE8B        ; branch always
00D81C  2               
00D81C  2               LAB_EE88:
00D81C  2  20 81 D7             JSR     LAB_E4A0        ; set serial data out high
00D81F  2               LAB_EE8B:
00D81F  2  20 43 DC             JSR     IEC_DELAY
00D822  2  20 33 D9             JSR     LAB_EF84        ; set serial clock high
00D825  2  EA                   NOP                     ; waste ..
00D826  2  EA                   NOP                     ; .. a ..
00D827  2  EA                   NOP                     ; .. cycle ..
00D828  2  EA                   NOP                     ; .. or two
00D829  2  20 43 DC             JSR     IEC_DELAY
00D82C  2  AD 2C FE             LDA     via2pcr         ; get VIA 2 PCR
00D82F  2  29 DF                AND     #$DF            ; set CB2 low, serial data out high
00D831  2  09 02                ORA     #$02            ; set CA2 high, serial clock out low
00D833  2  8D 2C FE             STA     via2pcr         ; save VIA 2 PCR
00D836  2  CE 15 03             DEC     IECBTC          ; decrement serial bus bit count
00D839  2  D0 C8                BNE     LAB_EE73        ; loop if not all done
00D83B  2               
00D83B  2               ; now all eight bits have been sent it's up to the peripheral to signal the byte was
00D83B  2               ; received by pulling the serial data low. this should be done within one milisecond
00D83B  2               
00D83B  2  A9 40                LDA     #$40            ; wait for up to about 1ms (MHZ)
00D83D  2  8D 29 FE             STA     via2t2ch        ; set VIA 2 T2C_h
00D840  2               LAB_EEA5:
00D840  2  AD 2D FE             LDA     via2ifr         ; get VIA 2 IFR
00D843  2  29 20                AND     #$20            ; mask T2 interrupt
00D845  2  D0 0B                BNE     LAB_EEB7        ; if T2 interrupt do timeout on serial bus
00D847  2               
00D847  2  20 93 D7             JSR     LAB_E4B2        ; get serial clock status
00D84A  2  4A                   LSR                     ; shift serial data to Cb
00D84B  2  B0 F3                BCS     LAB_EEA5        ; if data high go wait some more
00D84D  2               
00D84D  2  58                   CLI                     ; enable interrupts
00D84E  2  60                   RTS
00D84F  2               
00D84F  2               
00D84F  2               ;***********************************************************************************;
00D84F  2               ;
00D84F  2               ; device not present
00D84F  2               
00D84F  2               LAB_EEB4:
00D84F  2  A9 80                LDA     #$80            ; error $80, device not present
00D851  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_03A9
00D852  2               
00D852  2               
00D852  2               ;***********************************************************************************;
00D852  2               ;
00D852  2               ; timeout on serial bus
00D852  2               
00D852  2               LAB_EEB7:
00D852  2  A9 03                LDA     #$03            ; error $03, write timeout
00D854  2               LAB_EEB9:
00D854  2  20 52 D9             JSR     LAB_FE6A        ; OR into serial status byte
00D857  2  58                   CLI                     ; enable interrupts
00D858  2  18                   CLC                     ; clear for branch
00D859  2  90 55                BCC     LAB_EF09        ; ATN high, delay, clock high then data high, branch always
00D85B  2               
00D85B  2               
00D85B  2               ;***********************************************************************************;
00D85B  2               ;
00D85B  2               ; send secondary address after LISTEN
00D85B  2               
00D85B  2               ; this routine is used to send a secondary address to an I/O device after a call to
00D85B  2               ; the LISTEN routine is made and the device commanded to LISTEN. The routine cannot
00D85B  2               ; be used to send a secondary address after a call to the TALK routine.
00D85B  2               
00D85B  2               ; A secondary address is usually used to give set-up information to a device before
00D85B  2               ; I/O operations begin.
00D85B  2               
00D85B  2               ; When a secondary address is to be sent to a device on the serial bus the address
00D85B  2               ; must first be ORed with $60.
00D85B  2               
00D85B  2               LAB_EEC0:
00D85B  2  8D 13 03             STA     IECDC           ; save defered byte
00D85E  2  20 CE D7             JSR     LAB_EE40        ; set clk/data, wait and Tx byte on serial bus
00D861  2               ; set serial ATN high
00D861  2               
00D861  2               LAB_EEC5:
00D861  2  AD 1F FE             LDA     via1ora         ; get VIA 1 DRA, no handshake
00D864  2  29 7F                AND     #$7F            ; set serial ATN high
00D866  2  8D 1F FE             STA     via1ora         ; set VIA 1 DRA, no handshake
00D869  2  60                   RTS
00D86A  2               
00D86A  2               
00D86A  2               ;***********************************************************************************;
00D86A  2               ;
00D86A  2               ; send secondary address after TALK
00D86A  2               
00D86A  2               ; this routine transmits a secondary address on the serial bus for a TALK device.
00D86A  2               ; This routine must be called with a number between 4 and 31 in the accumulator.
00D86A  2               ; The routine will send this number as a secondary address command over the serial
00D86A  2               ; bus. This routine can only be called after a call to the TALK routine. It will
00D86A  2               ; not work after a LISTEN.
00D86A  2               
00D86A  2               LAB_EECE:
00D86A  2  8D 13 03             STA     IECDC           ; save the secondary address byte to transmit
00D86D  2  20 CE D7             JSR     LAB_EE40        ; set clk/data, wait and Tx byte on serial bus
00D870  2               
00D870  2  2C 17 03             BIT     IECSTW          ; test serial status byte
00D873  2  10 02                BPL     LAB_EED3        ; if device present
00D875  2  38                   SEC
00D876  2  60                   RTS
00D877  2               
00D877  2               ;***********************************************************************************;
00D877  2               ;
00D877  2               ; wait for bus end after send
00D877  2               
00D877  2               LAB_EED3:
00D877  2  78                   SEI                     ; disable interrupts
00D878  2  20 8A D7             JSR     LAB_E4A9        ; set serial data out low
00D87B  2  20 61 D8             JSR     LAB_EEC5        ; set serial ATN high
00D87E  2  20 33 D9             JSR     LAB_EF84        ; set serial clock high
00D881  2               LAB_EEDD:
00D881  2  20 93 D7             JSR     LAB_E4B2        ; get serial clock status
00D884  2  B0 FB                BCS     LAB_EEDD        ; branch if clock high
00D886  2               
00D886  2  58                   CLI                     ; enable interrupts
00D887  2  60                   RTS
00D888  2               
00D888  2               
00D888  2               ;***********************************************************************************;
00D888  2               ;
00D888  2               ; output a byte to the serial bus
00D888  2               
00D888  2               ; this routine is used to send information to devices on the serial bus. A call to
00D888  2               ; this routine will put a data byte onto the serial bus using full handshaking.
00D888  2               ; Before this routine is called the LISTEN routine, LAB_FFB1, must be used to
00D888  2               ; command a device on the serial bus to get ready to receive data.
00D888  2               
00D888  2               ; the accumulator is loaded with a byte to output as data on the serial bus. A
00D888  2               ; device must be listening or the status word will return a timeout. This routine
00D888  2               ; always buffers one character. So when a call to the UNLISTEN routine, LAB_FFAE,
00D888  2               ; is made to end the data transmission, the buffered character is sent with EOI
00D888  2               ; set. Then the UNLISTEN command is sent to the device.
00D888  2               
00D888  2               LAB_EEE4:
00D888  2  2C 12 03             BIT     IECDCF          ; test deferred character flag
00D88B  2  30 06                BMI     LAB_EEED        ; branch if defered character
00D88D  2               
00D88D  2  38                   SEC                     ; set carry
00D88E  2  6E 12 03             ROR     IECDCF          ; shift into deferred character flag
00D891  2  D0 05                BNE     LAB_EEF2        ; save byte and exit, branch always
00D893  2               
00D893  2               LAB_EEED:
00D893  2  48                   PHA                     ; save byte
00D894  2  20 D7 D7             JSR     LAB_EE49        ; Tx byte on serial bus
00D897  2  68                   PLA                     ; restore byte
00D898  2               LAB_EEF2:
00D898  2  8D 13 03             STA     IECDC           ; save defered byte
00D89B  2  18                   CLC                     ; flag ok
00D89C  2  60                   RTS
00D89D  2               
00D89D  2               
00D89D  2               ;***********************************************************************************;
00D89D  2               ;
00D89D  2               ; command the serial bus to UNTALK
00D89D  2               
00D89D  2               ; this routine will transmit an UNTALK command on the serial bus. All devices
00D89D  2               ; previously set to TALK will stop sending data when this command is received.
00D89D  2               
00D89D  2               LAB_EEF6:
00D89D  2  20 3C D9             JSR     LAB_EF8D        ; set serial clock low
00D8A0  2  AD 1F FE             LDA     via1ora         ; get VIA 1 DRA, no handshake
00D8A3  2  09 80                ORA     #$80            ; set serial ATN low
00D8A5  2  8D 1F FE             STA     via1ora         ; set VIA 1 DRA, no handshake
00D8A8  2               
00D8A8  2  A9 5F                LDA     #$5F            ; set the UNTALK command
00D8AA  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_3FA9
00D8AB  2               
00D8AB  2               
00D8AB  2               ;***********************************************************************************;
00D8AB  2               ;
00D8AB  2               ; command the serial bus to UNLISTEN
00D8AB  2               
00D8AB  2               ; this routine commands all devices on the serial bus to stop receiving data from
00D8AB  2               ; the computer. Calling this routine results in an UNLISTEN command being transmitted
00D8AB  2               ; on the serial bus. Only devices previously commanded to listen will be affected.
00D8AB  2               
00D8AB  2               ; This routine is normally used after the computer is finished sending data to
00D8AB  2               ; external devices. Sending the UNLISTEN will command the listening devices to get
00D8AB  2               ; off the serial bus so it can be used for other purposes.
00D8AB  2               
00D8AB  2               LAB_EF04:
00D8AB  2  A9 3F                LDA     #$3F            ; set the UNLISTEN command
00D8AD  2  20 A5 D7             JSR     LAB_EE1C        ; send control character
00D8B0  2               
00D8B0  2               ; ATN high, delay, clock high then data high
00D8B0  2               
00D8B0  2               LAB_EF09:
00D8B0  2  20 61 D8             JSR     LAB_EEC5        ; set serial ATN high
00D8B3  2               
00D8B3  2               ; 1ms delay, clock high then data high
00D8B3  2               
00D8B3  2               LAB_EF0C:
00D8B3  2  8A                   TXA                     ; save device number
00D8B4  2  A2 0B                LDX     #$0B            ; short delay
00D8B6  2               LAB_EF0F:
00D8B6  2  CA                   DEX                     ; decrement count
00D8B7  2  D0 FD                BNE     LAB_EF0F        ; loop if not all done
00D8B9  2               
00D8B9  2  AA                   TAX                     ; restore device number
00D8BA  2  20 33 D9             JSR     LAB_EF84        ; set serial clock high
00D8BD  2  4C 81 D7             JMP     LAB_E4A0        ; set serial data out high and return
00D8C0  2               
00D8C0  2               
00D8C0  2               ;***********************************************************************************;
00D8C0  2               ;
00D8C0  2               ; input a byte from the serial bus
00D8C0  2               
00D8C0  2               ; this routine reads a byte of data from the serial bus using full handshaking. the
00D8C0  2               ; data is returned in the accumulator. before using this routine the TALK routine,
00D8C0  2               ; LAB_FFB4, must have been called first to command the device on the serial bus to
00D8C0  2               ; send data on the bus. if the input device needs a secondary command it must be sent
00D8C0  2               ; by using the TKSA routine, LAB_FF96, before calling this routine.
00D8C0  2               
00D8C0  2               ; errors are returned in the status word which can be read by calling the READST
00D8C0  2               ; routine, LAB_FFB7.
00D8C0  2               
00D8C0  2               LAB_EF19:
00D8C0  2  78                   SEI                     ; disable interrupts
00D8C1  2  A9 00                LDA     #$00            ; clear A
00D8C3  2  8D 15 03             STA     IECBTC          ; clear serial bus bit count
00D8C6  2  20 33 D9             JSR     LAB_EF84        ; set serial clock high
00D8C9  2               LAB_EF21:
00D8C9  2  20 93 D7             JSR     LAB_E4B2        ; get serial clock status
00D8CC  2  90 FB                BCC     LAB_EF21        ; loop while clock low
00D8CE  2               
00D8CE  2  20 81 D7             JSR     LAB_E4A0        ; set serial data out high
00D8D1  2               LAB_EF29:
00D8D1  2  A9 10                LDA     #$10            ; set timeout count high byte (MHZ DEPENDENT)
00D8D3  2  8D 29 FE             STA     via2t2ch        ; set VIA 2 T2C_h
00D8D6  2               LAB_EF2E:
00D8D6  2  AD 2D FE             LDA     via2ifr         ; get VIA 2 IFR
00D8D9  2  29 20                AND     #$20            ; mask T2 interrupt
00D8DB  2  D0 07                BNE     LAB_EF3C        ; branch if T2 interrupt
00D8DD  2               
00D8DD  2  20 93 D7             JSR     LAB_E4B2        ; get serial clock status
00D8E0  2  B0 F4                BCS     LAB_EF2E        ; loop if clock high
00D8E2  2               
00D8E2  2  90 1A                BCC     LAB_EF54        ; else go se 8 bits to do, branch always
00D8E4  2               
00D8E4  2               ; T2 timed out
00D8E4  2               LAB_EF3C:
00D8E4  2  AD 15 03             LDA     IECBTC          ; get serial bus bit count
00D8E7  2  F0 05                BEQ     LAB_EF45        ; if not already EOI then go flag EOI
00D8E9  2               
00D8E9  2  A9 02                LDA     #$02            ; error $02, read timeour
00D8EB  2  4C 54 D8             JMP     LAB_EEB9        ; set serial status and exit
00D8EE  2               
00D8EE  2               LAB_EF45:
00D8EE  2  20 8A D7             JSR     LAB_E4A9        ; set serial data out low
00D8F1  2  20 B3 D8             JSR     LAB_EF0C        ; 1ms delay, clock high then data high
00D8F4  2  A9 40                LDA     #$40            ; set EOI
00D8F6  2  20 52 D9             JSR     LAB_FE6A        ; OR into serial status byte
00D8F9  2  EE 15 03             INC     IECBTC          ; increment serial bus bit count, do error on next timeout
00D8FC  2  D0 D3                BNE     LAB_EF29        ; go try again
00D8FE  2               
00D8FE  2               LAB_EF54:
00D8FE  2  A9 08                LDA     #$08            ; 8 bits to do
00D900  2  8D 15 03             STA     IECBTC          ; set serial bus bit count
00D903  2               LAB_EF58:
00D903  2               
00D903  2               ; STICKS HERE IF NO DATA TO READ
00D903  2               
00D903  2  AD 1F FE             LDA     via1ora         ; get VIA 1 DRA, no handshake
00D906  2  CD 1F FE             CMP     via1ora         ; compare with self
00D909  2  D0 F8                BNE     LAB_EF58        ; loop if changing
00D90B  2               ; OR HERE?
00D90B  2  4A                   LSR                     ; serial clock into carry
00D90C  2  90 F5                BCC     LAB_EF58        ; loop while serial clock low
00D90E  2               
00D90E  2  4A                   LSR                     ; serial data into carry
00D90F  2  6E 16 03             ROR     IECCYC          ; shift data bit into receive byte
00D912  2               LAB_EF66:
00D912  2               
00D912  2  AD 1F FE             LDA     via1ora         ; get VIA 1 DRA, no handshake
00D915  2  CD 1F FE             CMP     via1ora         ; compare with self
00D918  2  D0 F8                BNE     LAB_EF66        ; loop if changing
00D91A  2               
00D91A  2  4A                   LSR                     ; serial clock into carry
00D91B  2  B0 F5                BCS     LAB_EF66        ; loop while serial clock high
00D91D  2               
00D91D  2  CE 15 03             DEC     IECBTC          ; decrement serial bus bit count
00D920  2  D0 E1                BNE     LAB_EF58        ; loop if not all done
00D922  2               
00D922  2  20 8A D7             JSR     LAB_E4A9        ; set serial data out low
00D925  2  AD 17 03             LDA     IECSTW          ; get serial status byte
00D928  2  F0 03                BEQ     LAB_EF7F        ; branch if no error
00D92A  2               
00D92A  2  20 B3 D8             JSR     LAB_EF0C        ; 1ms delay, clock high then data high
00D92D  2               LAB_EF7F:
00D92D  2  AD 16 03             LDA     IECCYC          ; get receive byte
00D930  2  58                   CLI                     ; enable interrupts
00D931  2  18                   CLC
00D932  2  60                   RTS
00D933  2               
00D933  2               
00D933  2               ;***********************************************************************************;
00D933  2               ;
00D933  2               ; set serial clock high
00D933  2               
00D933  2               LAB_EF84:
00D933  2  AD 2C FE             LDA     via2pcr         ; get VIA 2 PCR
00D936  2  29 FD                AND     #$FD            ; set CA2 low, serial clock out high
00D938  2  8D 2C FE             STA     via2pcr         ; set VIA 2 PCR
00D93B  2  60                   RTS
00D93C  2               
00D93C  2               
00D93C  2               ;***********************************************************************************;
00D93C  2               ;
00D93C  2               ; set serial clock low
00D93C  2               
00D93C  2               LAB_EF8D:
00D93C  2  AD 2C FE             LDA     via2pcr         ; get VIA 2 PCR
00D93F  2  09 02                ORA     #$02            ; set CA2 high, serial clock out low
00D941  2  8D 2C FE             STA     via2pcr         ; set VIA 2 PCR
00D944  2  60                   RTS
00D945  2               
00D945  2               
00D945  2               ;***********************************************************************************;
00D945  2               ;
00D945  2               ; 1ms delay
00D945  2               
00D945  2               LAB_EF96:
00D945  2  A9 40                LDA     #$40            ; set for 1024 cycles (MHZ)
00D947  2  8D 29 FE             STA     via2t2ch        ; set VIA 2 T2C_h
00D94A  2               LAB_EF9B:
00D94A  2  AD 2D FE             LDA     via2ifr         ; get VIA 2 IFR
00D94D  2  29 20                AND     #$20            ; mask T2 interrupt
00D94F  2  F0 F9                BEQ     LAB_EF9B        ; loop until T2 interrupt
00D951  2               
00D951  2  60                   RTS
00D952  2               
00D952  2               ; OR into serial status byte
00D952  2               
00D952  2               LAB_FE6A:
00D952  2  0D 17 03             ORA     IECSTW          ; OR with serial status byte
00D955  2  8D 17 03             STA     IECSTW          ; save serial status byte
00D958  2  60                   RTS
00D959  2               
00D959  2               
00D959  2               ;***********************************************************************************;
00D959  2               ;
00D959  2               ; load RAM from a device
00D959  2               
00D959  2               ; this routine will load data bytes from any input device directly into the memory
00D959  2               ; of the computer.
00D959  2               ; If the input device was OPENed with a secondary address of 0 the header information from
00D959  2               ; device will be ignored. In this case Location LOADBUF must contain the starting address for the
00D959  2               ; load. LOADBANK must also be specified with the appropriate bank number.  If the device was addressed with a secondary address of 1 or 2 the data will
00D959  2               ; load into memory starting at the location specified by the header. This routine
00D959  2               ; returns the address of the highest RAM location which was loaded.
00D959  2               
00D959  2               ; Before this routine can be called,
00D959  2               ;		the SETLFS
00D959  2               ;		LAB_FFBA(set logical, first and second addresses)
00D959  2               ;		SETNAM
00D959  2               ;		LAB_FFBD(clear filename)
00D959  2               ; 	routines must be called.
00D959  2               LOADTORAM:
00D959  2               LAB_F549:
00D959  2  A9 00                LDA     #$00            ; clear A
00D95B  2  8D 17 03             STA     IECSTW          ; clear serial status byte
00D95E  2  AC 18 03             LDY     IECFNLN         ; get file name length
00D961  2  D0 03                BNE     LAB_F563        ; branch if not null name
00D963  2  4C 6F DA             JMP     LAB_F793        ; else do missing file name error and return
00D966  2               LAB_F563:
00D966  2  20 8C DA             JSR     LAB_E4BC        ; get seconday address and print "Searching..."
00D969  2  A9 60                LDA     #$60            ;.
00D96B  2  8D 19 03             STA     IECSECAD        ; save the secondary address
00D96E  2  20 92 DA             JSR     LAB_F495        ; send secondary address and filename
00D971  2  AD 1C 03             LDA     IECDEVN         ; get device number
00D974  2  20 9D D7             JSR     LAB_EE14        ; command a serial bus device to TALK
00D977  2  AD 19 03             LDA     IECSECAD        ; get secondary address
00D97A  2  20 6A D8             JSR     LAB_EECE        ; send secondary address after TALK
00D97D  2  20 C0 D8             JSR     LAB_EF19        ; input a byte from the serial bus
00D980  2               
00D980  2  8D 1A 03             STA     IECBUFFL        ; save program start address low byte
00D983  2  AD 17 03             LDA     IECSTW          ; get serial status byte
00D986  2  4A                   LSR                     ; shift time out read ..
00D987  2  4A                   LSR                     ; .. into carry bit
00D988  2  B0 4A                BCS     LAB_F5C7        ; if timed out go do file not found error and return
00D98A  2  20 C0 D8             JSR     LAB_EF19        ; input a byte from the serial bus
00D98D  2  8D 1B 03             STA     IECBUFFH        ; save program start address high byte
00D990  2  20 DB DA             JSR     LAB_E4C1        ; set LOAD address if secondary address = 0
00D993  2               LAB_F58A:
00D993  2  A9 FD                LDA     #$FD            ; mask xxxx xx0x, clear time out read bit
00D995  2  2D 17 03             AND     IECSTW          ; mask serial status byte
00D998  2  8D 17 03             STA     IECSTW          ; set serial status byte
00D99B  2  20 5C DC             JSR     LAB_FFE1        ; scan stop key, return Zb = 1 = [STOP]
00D99E  2  D0 03                BNE     LAB_F598        ; branch if not [STOP]
00D9A0  2  4C 31 DA             JMP     LAB_F6CB        ; else close the serial bus device and flag stop
00D9A3  2               
00D9A3  2               LAB_F598:
00D9A3  2  20 C0 D8             JSR     LAB_EF19        ; input a byte from the serial bus
00D9A6  2  AA                   TAX                     ; copy byte
00D9A7  2  AD 17 03             LDA     IECSTW          ; get serial status byte
00D9AA  2  4A                   LSR                     ; shift time out read ..
00D9AB  2  4A                   LSR                     ; .. into carry bit
00D9AC  2  B0 E5                BCS     LAB_F58A        ; if timed out go ??
00D9AE  2               
00D9AE  2  AD 24 03             LDA     LOADBANK        ; set load bank
00D9B1  2  8B                   PHB
00D9B2  2  48                   PHA
00D9B3  2  8A                   TXA                     ; copy received byte back
00D9B4  2  C2 10                INDEX16
00D9B6  2  AE 22 03             LDX     LOADBUFL
00D9B9  2  AB                   PLB
00D9BA  2  95 00                STA     0,x             ; save byte to memory
00D9BC  2  AB                   PLB                     ; restore bank
00D9BD  2  E2 10                INDEX8
00D9BF  2               
00D9BF  2               LAB_F5B5:
00D9BF  2  EE 22 03             INC     LOADBUFL        ; increment save pointer low byte
00D9C2  2  D0 03                BNE     LAB_F5BB        ; if no rollover skip the high byte increment
00D9C4  2               
00D9C4  2  EE 23 03             INC     LOADBUFH        ; else increment save pointer high byte
00D9C7  2               LAB_F5BB:
00D9C7  2  2C 17 03             BIT     IECSTW          ; test serial status byte
00D9CA  2  50 C7                BVC     LAB_F58A        ; loop if not end of file
00D9CC  2               
00D9CC  2  20 9D D8             JSR     LAB_EEF6        ; command the serial bus to UNTALK
00D9CF  2  20 40 DA             JSR     LAB_F6DA        ; close serial bus device
00D9D2  2  90 03                BCC     LAB_F641        ; if ?? go flag ok and exit
00D9D4  2               
00D9D4  2               LAB_F5C7:
00D9D4  2  4C 63 DA             JMP     LAB_F787        ; do file not found error and return
00D9D7  2               
00D9D7  2               LAB_F641:
00D9D7  2  18                   CLC                     ; flag ok
00D9D8  2  AE 1A 03             LDX     IECBUFFL        ; get the LOAD end pointer low byte
00D9DB  2  AC 1B 03             LDY     IECBUFFH        ; get the LOAD end pointer high byte
00D9DE  2               LAB_F646:
00D9DE  2  60                   RTS
00D9DF  2               
00D9DF  2               ;***********************************************************************************;
00D9DF  2               ;
00D9DF  2               ; save RAM to a device
00D9DF  2               ; this routine saves a section of memory.
00D9DF  2               ; Start Address in IECSTRT
00D9DF  2               ; End Address in LOADBUF
00D9DF  2               ; LOADBANK must also be specified with the appropriate bank number.
00D9DF  2               
00D9DF  2               ; Before this routine can be called,
00D9DF  2               ;		the SETLFS
00D9DF  2               ;		LAB_FFBA(set logical, first and second addresses)
00D9DF  2               ;		SETNAM
00D9DF  2               ;		LAB_FFBD(clear filename)
00D9DF  2               ; 	routines must be called.
00D9DF  2               ;***********************************************************************************;
00D9DF  2               ;
00D9DF  2               ; save RAM to device, A = index to start address, XY = end address low/high
00D9DF  2               
00D9DF  2               IECSAVERAM:
00D9DF  2               ;***********************************************************************************;
00D9DF  2               ;
00D9DF  2               ; save
00D9DF  2               
00D9DF  2               LAB_F685:
00D9DF  2  A9 00                LDA     #$00            ; clear A
00D9E1  2  8D 17 03             STA     IECSTW          ; clear serial status byte
00D9E4  2  A9 61                LDA     #$61            ; set secondary address to $01
00D9E6  2               ; when a secondary address is to be sent to a device on
00D9E6  2               ; the serial bus the address must first be ORed with $60
00D9E6  2  8D 19 03             STA     IECSECAD        ; save secondary address
00D9E9  2  AC 18 03             LDY     IECFNLN         ; get file name length
00D9EC  2  D0 03                BNE     LAB_F69D        ; branch if filename not null
00D9EE  2  4C 6F DA             JMP     LAB_F793        ; else do missing file name error and return
00D9F1  2               
00D9F1  2               LAB_F69D:
00D9F1  2  20 92 DA             JSR     LAB_F495        ; send secondary address and filename
00D9F4  2  20 ED DA             JSR     LAB_F728        ; print saving [file name]
00D9F7  2  AD 1C 03             LDA     IECDEVN         ; get device number
00D9FA  2  20 A0 D7             JSR     LAB_EE17        ; command devices on the serial bus to LISTEN
00D9FD  2  AD 19 03             LDA     IECSECAD        ; get secondary address
00DA00  2  20 5B D8             JSR     LAB_EEC0        ; send secondary address after LISTEN
00DA03  2  A0 00                LDY     #$00            ; clear index
00DA05  2  20 FB DA             JSR     LAB_FBD2        ; copy I/O start address to buffer address
00DA08  2  AD 1A 03             LDA     IECBUFFL        ; get buffer address low byte
00DA0B  2  20 88 D8             JSR     LAB_EEE4        ; output a byte to the serial bus
00DA0E  2  AD 1B 03             LDA     IECBUFFH        ; get buffer address high byte
00DA11  2  20 88 D8             JSR     LAB_EEE4        ; output a byte to the serial bus
00DA14  2               LAB_F6BC:
00DA14  2               
00DA14  2  20 08 DB             JSR     LAB_FD11        ; check read/write pointer, return Cb = 1 if pointer >= end
00DA17  2  B0 24                BCS     LAB_F6D7        ; go do UNLISTEN if at end
00DA19  2               
00DA19  2  AD 24 03             LDA     LOADBANK        ; set load bank
00DA1C  2  8B                   PHB
00DA1D  2  48                   PHA
00DA1E  2  C2 10                INDEX16
00DA20  2  AE 1A 03             LDX     IECBUFFL
00DA23  2  AB                   PLB
00DA24  2  B5 00                LDA     0,x             ; load byte from memory
00DA26  2  AB                   PLB                     ; restore bank
00DA27  2  E2 10                INDEX8
00DA29  2               
00DA29  2  20 88 D8             JSR     LAB_EEE4        ; output a byte to the serial bus
00DA2C  2  20 5C DC             JSR     LAB_FFE1        ; scan stop key
00DA2F  2  D0 07                BNE     LAB_F6D2        ; if stop not pressed go increment pointer and loop for next
00DA31  2               
00DA31  2               ; else ..
00DA31  2               
00DA31  2               ; close the serial bus device and flag stop
00DA31  2               
00DA31  2               LAB_F6CB:
00DA31  2  20 40 DA             JSR     LAB_F6DA        ; close serial bus device
00DA34  2  A9 00                LDA     #$00            ;.
00DA36  2  38                   SEC                     ; flag stop
00DA37  2  60                   RTS
00DA38  2               
00DA38  2               LAB_F6D2:
00DA38  2  20 16 DB             JSR     LAB_FD1B        ; increment read/write pointer
00DA3B  2  D0 D7                BNE     LAB_F6BC        ; loop, branch always
00DA3D  2               
00DA3D  2               ;***********************************************************************************;
00DA3D  2               ;
00DA3D  2               ; ??
00DA3D  2               
00DA3D  2               LAB_F6D7:
00DA3D  2  20 AB D8             JSR     LAB_EF04        ; command the serial bus to UNLISTEN
00DA40  2               
00DA40  2               ; close the serial bus device
00DA40  2               
00DA40  2               LAB_F6DA:
00DA40  2  2C 19 03             BIT     IECSECAD        ; test the secondary address
00DA43  2  30 13                BMI     LAB_F6EF        ; if already closed just exit
00DA45  2               
00DA45  2  AD 1C 03             LDA     IECDEVN         ; get the device number
00DA48  2  20 A0 D7             JSR     LAB_EE17        ; command devices on the serial bus to LISTEN
00DA4B  2  AD 19 03             LDA     IECSECAD        ; get secondary address
00DA4E  2  29 EF                AND     #$EF            ; mask the channel number
00DA50  2  09 E0                ORA     #$E0            ; OR with the CLOSE command
00DA52  2  20 5B D8             JSR     LAB_EEC0        ; send secondary address after LISTEN
00DA55  2  20 AB D8             JSR     LAB_EF04        ; command the serial bus to UNLISTEN
00DA58  2               LAB_F6EF:
00DA58  2  18                   CLC                     ; flag ok
00DA59  2  60                   RTS
00DA5A  2               
00DA5A  2               ;***********************************************************************************;
00DA5A  2               ;
00DA5A  2               ; file error messages
00DA5A  2               LAB_F77E:
00DA5A  2  A9 01                LDA     #$01            ; too many files
00DA5C  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_02A9
00DA5D  2               LAB_F781:
00DA5D  2  A9 02                LDA     #$02            ; file already open
00DA5F  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_03A9
00DA60  2               LAB_F784:
00DA60  2  A9 03                LDA     #$03            ; file not open
00DA62  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_04A9
00DA63  2               LAB_F787:
00DA63  2  A9 04                LDA     #$04            ; file not found
00DA65  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_05A9
00DA66  2               LAB_F78A:
00DA66  2  A9 05                LDA     #$05            ; device not present
00DA68  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_06A9
00DA69  2               LAB_F78D:
00DA69  2  A9 06                LDA     #$06            ; not input file
00DA6B  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_07A9
00DA6C  2               LAB_F790:
00DA6C  2  A9 07                LDA     #$07            ; not output file
00DA6E  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_08A9
00DA6F  2               LAB_F793:
00DA6F  2  A9 08                LDA     #$08            ; missing file name
00DA71  2  2C                   .BYTE   $2C             ; makes next line BIT LAB_09A9
00DA72  2               LAB_F796:
00DA72  2  A9 09                LDA     #$09            ; illegal device number
00DA74  2               
00DA74  2  48                   PHA                     ; save error #
00DA75  2  20 1F DB             JSR     LAB_FFCC        ; close input and output channels
00DA78  2  A0 00                LDY     #LAB_F174-LAB_F174
00DA7A  2               ; index to "I/O ERROR #"
00DA7A  2  2C 1F 03             BIT     IECMSGM         ; test message mode flag
00DA7D  2  50 0A                BVC     LAB_F7AC        ; exit if kernal messages off
00DA7F  2               
00DA7F  2  20 79 DB             JSR     LAB_F1E6        ; display kernel I/O message
00DA82  2  68                   PLA                     ; restore error #
00DA83  2  48                   PHA                     ; copy error #
00DA84  2  09 30                ORA     #'0'            ; convert to ASCII
00DA86  2  20 18 D2             JSR     OUTCH           ; output character to channel
00DA89  2               LAB_F7AC:
00DA89  2  68                   PLA                     ; pull error number
00DA8A  2  38                   SEC                     ; flag error
00DA8B  2  60                   RTS
00DA8C  2               
00DA8C  2               
00DA8C  2               ;***********************************************************************************;
00DA8C  2               ;
00DA8C  2               ; get seconday address and print "Searching..."
00DA8C  2               
00DA8C  2               LAB_E4BC:
00DA8C  2  AE 19 03             LDX     IECSECAD        ; get secondary address
00DA8F  2  4C 88 DB             JMP     LAB_F647        ; print "Searching..." and return
00DA92  2               
00DA92  2               
00DA92  2               
00DA92  2               ;***********************************************************************************;
00DA92  2               ;
00DA92  2               ; send secondary address and filename
00DA92  2               
00DA92  2               LAB_F495:
00DA92  2  AD 19 03             LDA     IECSECAD        ; get secondary address
00DA95  2  30 42                BMI     LAB_F4C5        ; ok exit if -ve
00DA97  2               
00DA97  2  AC 18 03             LDY     IECFNLN         ; get file name length
00DA9A  2  F0 3D                BEQ     LAB_F4C5        ; ok exit if null
00DA9C  2               
00DA9C  2  AD 1C 03             LDA     IECDEVN         ; get device number
00DA9F  2  20 A0 D7             JSR     LAB_EE17        ; command devices on the serial bus to LISTEN
00DAA2  2               
00DAA2  2  AD 19 03             LDA     IECSECAD        ; get the secondary address
00DAA5  2  09 F0                ORA     #$F0            ; OR with the OPEN command
00DAA7  2  20 5B D8             JSR     LAB_EEC0        ; send secondary address after LISTEN
00DAAA  2  AD 17 03             LDA     IECSTW          ; get serial status byte
00DAAD  2  10 05                BPL     LAB_F4B2        ; branch if device present
00DAAF  2  68                   PLA                     ; else dump calling address low byte
00DAB0  2  68                   PLA                     ; dump calling address high byte
00DAB1  2  4C 66 DA             JMP     LAB_F78A        ; do device not present error and return
00DAB4  2               LAB_F4B2:
00DAB4  2  AD 18 03             LDA     IECFNLN         ; get file name length
00DAB7  2  F0 1D                BEQ     LAB_F4C2        ; branch if null name
00DAB9  2  A8                   TAY
00DABA  2  DA                   PHX
00DABB  2  C2 10                INDEX16
00DABD  2  AE 20 03             LDX     IECFNPL
00DAC0  2  DA                   PHX
00DAC1  2               LAB_F4B8:
00DAC1  2  C2 10                INDEX16
00DAC3  2  FA                   PLX
00DAC4  2  B5 00                LDA     0,X             ; get file name byte
00DAC6  2  E8                   INX
00DAC7  2  DA                   PHX
00DAC8  2  E2 10                INDEX8
00DACA  2  20 88 D8             JSR     LAB_EEE4        ; output a byte to the serial bus
00DACD  2  88                   DEY
00DACE  2  D0 F1                BNE     LAB_F4B8        ; loop if not all done
00DAD0  2  C2 10                INDEX16
00DAD2  2  FA                   PLX
00DAD3  2  E2 10                INDEX8
00DAD5  2  FA                   PLX
00DAD6  2               LAB_F4C2:
00DAD6  2  20 AB D8             JSR     LAB_EF04        ; command the serial bus to UNLISTEN
00DAD9  2               LAB_F4C5:
00DAD9  2  18                   CLC                     ; flag ok
00DADA  2  60                   RTS
00DADB  2               
00DADB  2               ;***********************************************************************************;
00DADB  2               ;
00DADB  2               ; set LOAD address if secondary address = 0
00DADB  2               
00DADB  2               LAB_E4C1:
00DADB  2  8A                   TXA                     ; copy secondary address
00DADC  2  D0 0C                BNE     LAB_E4CC        ; load location not set in LOAD call, so
00DADE  2               ; continue with load
00DADE  2  AD 1B 03             LDA     IECBUFFH        ; get load address high byte
00DAE1  2  8D 23 03             STA     LOADBUFH        ; save program start address high byte
00DAE4  2  AD 1A 03             LDA     IECBUFFL        ; get load address low byte
00DAE7  2  8D 22 03             STA     LOADBUFL        ; save program start address low byte
00DAEA  2               
00DAEA  2               LAB_E4CC:
00DAEA  2  4C BE DB             JMP     LAB_F66A        ; display "LOADING" or "VERIFYING" and return
00DAED  2               
00DAED  2               
00DAED  2               ;***********************************************************************************;
00DAED  2               ;
00DAED  2               ; print saving [file name]
00DAED  2               
00DAED  2               LAB_F728:
00DAED  2  AD 1F 03             LDA     IECMSGM         ; get message mode flag
00DAF0  2  10 08                BPL     LAB_F727        ; exit if control messages off
00DAF2  2               
00DAF2  2  A0 2A                LDY     #LAB_F1C5-LAB_F174
00DAF4  2               ; index to "SAVING "
00DAF4  2  20 79 DB             JSR     LAB_F1E6        ; display kernel I/O message
00DAF7  2  4C 9C DB             JMP     LAB_F659        ; print file name and return
00DAFA  2               LAB_F727:
00DAFA  2  60                   RTS
00DAFB  2               
00DAFB  2               ;***********************************************************************************;
00DAFB  2               ;
00DAFB  2               ; copy I/O start address to buffer address
00DAFB  2               
00DAFB  2               LAB_FBD2:
00DAFB  2  AD 1E 03             LDA     IECSTRTH        ; get I/O start address high byte
00DAFE  2  8D 1B 03             STA     IECBUFFH        ; set buffer address high byte
00DB01  2  AD 1D 03             LDA     IECSTRTL        ; get I/O start address low byte
00DB04  2  8D 1A 03             STA     IECBUFFL        ; set buffer address low byte
00DB07  2  60                   RTS
00DB08  2               
00DB08  2               
00DB08  2               
00DB08  2               ;***********************************************************************************;
00DB08  2               ;
00DB08  2               ; check read/write pointer
00DB08  2               ; return Cb = 1 if pointer >= end
00DB08  2               
00DB08  2               LAB_FD11:
00DB08  2  38                   SEC                     ; set carry for subtract
00DB09  2  AD 1A 03             LDA     IECBUFFL        ; get buffer address low byte
00DB0C  2  ED 22 03             SBC     LOADBUFL        ; subtract buffer end low byte
00DB0F  2  AD 1B 03             LDA     IECBUFFH        ; get buffer address high byte
00DB12  2  ED 23 03             SBC     LOADBUFH        ; subtract buffer end high byte
00DB15  2  60                   RTS
00DB16  2               
00DB16  2               ;***********************************************************************************;
00DB16  2               ;
00DB16  2               ; increment read/write pointer
00DB16  2               
00DB16  2               LAB_FD1B:
00DB16  2  EE 1A 03             INC     IECBUFFL        ; increment buffer address low byte
00DB19  2  D0 03                BNE     LAB_FD21        ; if no overflow skip the high byte increment
00DB1B  2               
00DB1B  2  EE 1B 03             INC     IECBUFFH        ; increment buffer address high byte
00DB1E  2               LAB_FD21:
00DB1E  2  60                   RTS
00DB1F  2               
00DB1F  2               ;***********************************************************************************;
00DB1F  2               ;
00DB1F  2               ; close input and output channels
00DB1F  2               
00DB1F  2               ; this routine is called to clear all open channels and restore the I/O channels to
00DB1F  2               ; their original default values. It is usually called after opening other I/O
00DB1F  2               ; channels and using them for input/output operations. The default input device is
00DB1F  2               ; 0, the keyboard. The default output device is 3, the screen.
00DB1F  2               
00DB1F  2               ; If one of the channels to be closed is to the serial port, an UNTALK signal is sent
00DB1F  2               ; first to clear the input channel or an UNLISTEN is sent to clear the output channel.
00DB1F  2               ; By not calling this routine and leaving listener(s) active on the serial bus,
00DB1F  2               ; several devices can receive the same data from the VIC at the same time. One way to
00DB1F  2               ; take advantage of this would be to command the printer to TALK and the disk to
00DB1F  2               ; LISTEN. This would allow direct printing of a disk file.
00DB1F  2               
00DB1F  2               LAB_FFCC:
00DB1F  2  20 AB D8             JSR     LAB_EF04        ; command the serial bus to UNLISTEN
00DB22  2               LAB_F3FC:
00DB22  2  20 9D D8             JSR     LAB_EEF6        ; command the serial bus to UNTALK
00DB25  2               LAB_F403:
00DB25  2  60                   RTS
00DB26  2               
00DB26  2               ;***********************************************************************************;
00DB26  2               ;
00DB26  2               ; kernel I/O messages
00DB26  2               
00DB26  2               LAB_F174:
00DB26  2  0A 0D 49 2F          .BYTE   $0A,$0D,"I/O ERROR #",0
00DB2A  2  4F 20 45 52  
00DB2E  2  52 4F 52 20  
00DB34  2               LAB_F180:
00DB34  2  0A 0D 53 45          .BYTE   $0A,$0D,"SEARCHING ",0
00DB38  2  41 52 43 48  
00DB3C  2  49 4E 47 20  
00DB41  2               LAB_F18B:
00DB41  2  46 4F 52 20          .BYTE   "FOR ",0
00DB45  2  00           
00DB46  2               LAB_F1BD:
00DB46  2  0A 0D 4C 4F          .BYTE   $0A,$0D,"LOADING",0
00DB4A  2  41 44 49 4E  
00DB4E  2  47 00        
00DB50  2               LAB_F1C5:
00DB50  2  0A 0D 53 41          .BYTE   $0A,$0D,"SAVING ",0
00DB54  2  56 49 4E 47  
00DB58  2  20 00        
00DB5A  2               LAB_F1CD:
00DB5A  2  0A 0D 56 45          .BYTE   $0A,$0D,"VERIFYING",0
00DB5E  2  52 49 46 59  
00DB62  2  49 4E 47 00  
00DB66  2               LAB_F1D7:
00DB66  2  0A 0D 46 4F          .BYTE   $0A,$0D,"FOUND ",0
00DB6A  2  55 4E 44 20  
00DB6E  2  00           
00DB6F  2               LAB_F1DE:
00DB6F  2  0A 0D 4F 4B          .BYTE   $0A,$0D,"OK",0
00DB73  2  00           
00DB74  2               
00DB74  2               
00DB74  2               ;***********************************************************************************;
00DB74  2               ;
00DB74  2               ; display control I/O message if in direct mode
00DB74  2               
00DB74  2               LAB_F1E2:
00DB74  2  2C 1F 03             BIT     IECMSGM         ; test message mode flag
00DB77  2  10 0D                BPL     LAB_F1F3        ; exit if control messages off
00DB79  2               
00DB79  2               ; display kernel I/O message
00DB79  2               
00DB79  2               LAB_F1E6:
00DB79  2  B9 26 DB             LDA     LAB_F174,Y      ; get byte from message table
00DB7C  2  F0 08                BEQ     LAB_F1F3        ; loop if not end of message
00DB7E  2  08                   PHP                     ; save status
00DB7F  2  20 18 D2             JSR     OUTCH           ; output character to channel
00DB82  2  C8                   INY                     ; increment index
00DB83  2  28                   PLP                     ; restore status
00DB84  2  80 F3                BRA     LAB_F1E6        ; loop if not end of message
00DB86  2               
00DB86  2               LAB_F1F3:
00DB86  2  18                   CLC                     ;.
00DB87  2  60                   RTS
00DB88  2               
00DB88  2               ;***********************************************************************************;
00DB88  2               ;
00DB88  2               ; print "searching"
00DB88  2               
00DB88  2               LAB_F647:
00DB88  2  AD 1F 03             LDA     IECMSGM         ; get message mode flag
00DB8B  2  10 30                BPL     LAB_F669        ; exit if control messages off
00DB8D  2               
00DB8D  2  A0 0E                LDY     #LAB_F180-LAB_F174
00DB8F  2               ; index to "SEARCHING "
00DB8F  2  20 79 DB             JSR     LAB_F1E6        ; display kernel I/O message
00DB92  2  AD 18 03             LDA     IECFNLN         ; get file name length
00DB95  2  F0 26                BEQ     LAB_F669        ; exit if null name
00DB97  2               
00DB97  2  A0 1B                LDY     #LAB_F18B-LAB_F174
00DB99  2               ; else index to "FOR "
00DB99  2  20 79 DB             JSR     LAB_F1E6        ; display kernel I/O message
00DB9C  2               
00DB9C  2               ; print file name
00DB9C  2               
00DB9C  2               LAB_F659:
00DB9C  2  AC 18 03             LDY     IECFNLN         ; get file name length
00DB9F  2  F0 1C                BEQ     LAB_F669        ; exit if null file name
00DBA1  2               
00DBA1  2  DA                   PHX
00DBA2  2  C2 10                INDEX16
00DBA4  2  AE 20 03             LDX     IECFNPL
00DBA7  2  DA                   PHX
00DBA8  2               LAB_F65F:
00DBA8  2  C2 10                INDEX16
00DBAA  2  FA                   PLX
00DBAB  2  B5 00                LDA     0,X             ; get file name byte
00DBAD  2  E8                   INX
00DBAE  2  DA                   PHX
00DBAF  2  E2 10                INDEX8
00DBB1  2  20 18 D2             JSR     OUTCH           ; output character to channel
00DBB4  2  88                   DEY
00DBB5  2  D0 F1                BNE     LAB_F65F        ; loop if more to do
00DBB7  2  C2 10                INDEX16
00DBB9  2  FA                   PLX
00DBBA  2  E2 10                INDEX8
00DBBC  2  FA                   PLX
00DBBD  2               LAB_F669:
00DBBD  2  60                   RTS
00DBBE  2               
00DBBE  2               ; display "LOADING" or "VERIFYING"
00DBBE  2               
00DBBE  2               LAB_F66A:
00DBBE  2  A0 20                LDY     #LAB_F1BD-LAB_F174
00DBC0  2               ; point to "LOADING"
00DBC0  2               LAB_F672:
00DBC0  2  4C 74 DB             JMP     LAB_F1E2        ; display kernel I/O message if in direct mode and return
00DBC3  2               
00DBC3  2               LAB_FE49:
00DBC3  2  8D 18 03             STA     IECFNLN         ; set file name length
00DBC6  2  8E 20 03             STX     IECFNPL         ; set file name pointer low byte
00DBC9  2  8C 21 03             STY     IECFNPH         ; set file name pointer high byte
00DBCC  2  60                   RTS
00DBCD  2               
00DBCD  2               LAB_FE50:
00DBCD  2  8D 26 03             STA     IECLFN          ; SET LOGICAL FILE NUMBER
00DBD0  2  8E 1C 03             STX     IECDEVN         ; set device number
00DBD3  2  8C 19 03             STY     IECSECAD        ; set secondary address or command
00DBD6  2  60                   RTS
00DBD7  2               
00DBD7  2               
00DBD7  2               
00DBD7  2               LAB_F160:
00DBD7  2  48                   PHA                     ; save A
00DBD8  2  AD 1E FE             LDA     via1ier         ; get VIA 1 IER
00DBDB  2  F0 0C                BEQ     LAB_F172        ; branch if no interrupts enabled. this branch will
00DBDD  2               ; never be taken as b7 of IER always reads as 1
00DBDD  2               ; according to the 6522 data sheet
00DBDD  2               LAB_F166:
00DBDD  2  AD 1E FE             LDA     via1ier         ; get VIA 1 IER
00DBE0  2  29 60                AND     #$60            ; mask 0xx0 0000, T1 and T2 interrupts
00DBE2  2  D0 F9                BNE     LAB_F166        ; loop if T1 or T2 active
00DBE4  2               
00DBE4  2  A9 10                LDA     #$10            ; disable CB1 interrupt
00DBE6  2  8D 1E FE             STA     via1ier         ; set VIA 1 IER
00DBE9  2               LAB_F172:
00DBE9  2  68                   PLA                     ; restore A
00DBEA  2  60                   RTS
00DBEB  2               
00DBEB  2               
00DBEB  2               ;***********************************************************************************;
00DBEB  2               ;
00DBEB  2               ; initialize I/O registers
00DBEB  2               
00DBEB  2               INITIEC:
00DBEB  2  A9 7F                LDA     #$7F            ; disable all interrupts
00DBED  2  8D 1E FE             STA     via1ier         ; on VIA 1 IER ..
00DBF0  2  8D 2E FE             STA     via2ier         ; .. and VIA 2 IER
00DBF3  2               
00DBF3  2  A9 40                LDA     #$40            ; set T1 free run, T2 clock ï¿½2,
00DBF5  2               ; SR disabled, latches disabled
00DBF5  2  8D 2B FE             STA     via2acr         ; set VIA 2 ACR
00DBF8  2               
00DBF8  2  A9 40                LDA     #$40            ; set T1 free run, T2 clock ï¿½2,
00DBFA  2               ; SR disabled, latches disabled
00DBFA  2  8D 1B FE             STA     via1acr         ; set VIA 1 ACR
00DBFD  2               
00DBFD  2  A9 FE                LDA     #$FE            ; CB2 high, RS232 Tx
00DBFF  2               ; CB1 +ve edge,
00DBFF  2               ; CA2 high, tape motor off
00DBFF  2               ; CA1 -ve edge
00DBFF  2  8D 1C FE             STA     via1pcr         ; set VIA 1 PCR
00DC02  2               
00DC02  2  A9 DE                LDA     #$DE            ; CB2 low, serial data out high
00DC04  2               ; CB1 +ve edge,
00DC04  2               ; CA2 high, serial clock out low
00DC04  2               ; CA1 -ve edge
00DC04  2  8D 2C FE             STA     via2pcr         ; set VIA 2 PCR
00DC07  2               
00DC07  2  A2 00                LDX     #$00            ; all inputs, RS232 interface or parallel user port
00DC09  2  8E 12 FE             STX     via1ddrb        ; set VIA 1 DDRB
00DC0C  2               
00DC0C  2  A2 FF                LDX     #$FF            ; all outputs, keyboard column
00DC0E  2  8E 22 FE             STX     via2ddrb        ; set VIA 2 DDRB
00DC11  2               
00DC11  2  A2 00                LDX     #$00            ; all inputs, keyboard row
00DC13  2  8E 23 FE             STX     via2ddra        ; set VIA 2 DDRA
00DC16  2               
00DC16  2  A2 C0                LDX     #$C0            ; OIII IIII, ATN out, light pen, joystick, serial data
00DC18  2               ; in, serial clk in
00DC18  2  8E 13 FE             STX     via1ddra        ; set VIA 1 DDRA
00DC1B  2               
00DC1B  2  A2 00                LDX     #$00            ; ATN out low, set ATN high
00DC1D  2  8E 1F FE             STX     via1ora         ; set VIA 1 DRA, no handshake
00DC20  2               
00DC20  2  A2 40                LDX     #$40            ; assert CS on DS1302
00DC22  2  8E 1F FE             STX     via1ora         ; set VIA 1 DRA, no handshake
00DC25  2               
00DC25  2  20 33 D9             JSR     LAB_EF84        ; set serial clock high
00DC28  2  20 3C D9             JSR     LAB_EF8D        ; set serial clock low
00DC2B  2               
00DC2B  2               
00DC2B  2               ;***********************************************************************************;
00DC2B  2               ;
00DC2B  2               ; set 60Hz and enable timer
00DC2B  2  A9 C0                LDA     #$C0            ; enable T1 interrupt
00DC2D  2  8D 2E FE             STA     via2ier         ; set VIA 2 IER
00DC30  2               ;	LDA	#$26			; set timer constant low byte [PAL]
00DC30  2               ;	LDA	#$89			; set timer constant low byte [NTSC]
00DC30  2  A9 FF                LDA     #$FF            ; set timer constant low byte [4MHz]
00DC32  2  8D 24 FE             STA     via2t1cl        ; set VIA 2 T1C_l
00DC35  2               ;	LDA	#$48			; set timer constant high byte [PAL]
00DC35  2               ;	LDA	#$42			; set timer constant high byte [NTSC]
00DC35  2  A9 FF                LDA     #$FF            ; set timer constant high byte [4MHz]
00DC37  2  8D 25 FE             STA     via2t1ch        ; set VIA 2 T1C_h
00DC3A  2               
00DC3A  2  A9 00                LDA     #$00
00DC3C  2  8D 14 03             STA     IECBCI
00DC3F  2  8D 25 03             STA     IECOPENF
00DC42  2  60                   RTS
00DC43  2               
00DC43  2               
00DC43  2               IEC_DELAY:
00DC43  2  48                   PHA
00DC44  2  68                   PLA
00DC45  2  48                   PHA
00DC46  2  68                   PLA
00DC47  2  48                   PHA
00DC48  2  68                   PLA
00DC49  2  48                   PHA
00DC4A  2  68                   PLA
00DC4B  2               
00DC4B  2  48                   PHA
00DC4C  2  68                   PLA
00DC4D  2  48                   PHA
00DC4E  2  68                   PLA
00DC4F  2  48                   PHA
00DC50  2  68                   PLA
00DC51  2  48                   PHA
00DC52  2  68                   PLA
00DC53  2  48                   PHA
00DC54  2  68                   PLA
00DC55  2  48                   PHA
00DC56  2  68                   PLA
00DC57  2  48                   PHA
00DC58  2  68                   PLA
00DC59  2  48                   PHA
00DC5A  2  68                   PLA
00DC5B  2  60                   RTS
00DC5C  2               
00DC5C  2               LAB_FFE1:
00DC5C  2  20 74 FF             JSR     INPVEC
00DC5F  2  C9 03                CMP     #$03
00DC61  2  60                   RTS
00DC62  2               
00DC62  2               
00DC62  2               ;***********************************************************************************;
00DC62  2               ;
00DC62  2               ; close a specified logical file
00DC62  2               
00DC62  2               ; this routine is used to close a logical file after all I/O operations have been
00DC62  2               ; completed on that file. This routine is called after the accumulator is loaded
00DC62  2               ; with the logical file number to be closed, the same number used when the file was
00DC62  2               ; opened using the OPEN routine.
00DC62  2               
00DC62  2               LAB_F34A:
00DC62  2  20 2F DD             JSR     LAB_F3D4        ; find file A
00DC65  2  F0 02                BEQ     LAB_F351        ; if the file is found go close it
00DC67  2               
00DC67  2  18                   CLC                     ; else thr file was closed so just flag ok
00DC68  2  60                   RTS
00DC69  2               
00DC69  2               ; found the file so close it
00DC69  2               LAB_F351:
00DC69  2  20 3B DD             JSR     LAB_F3DF        ; set file details from table,X
00DC6C  2  8A                   TXA                     ; copy file index to A
00DC6D  2  48                   PHA                     ; save file index
00DC6E  2  AD 1C 03             LDA     IECDEVN         ; get device number
00DC71  2               ; do serial bus device file close
00DC71  2               
00DC71  2               LAB_F3AE:
00DC71  2  20 40 DA             JSR     LAB_F6DA        ; close serial bus device
00DC74  2               LAB_F3B1:
00DC74  2  68                   PLA                     ; restore file index
00DC75  2               ;
00DC75  2               ; close file index X
00DC75  2               
00DC75  2               LAB_F3B2:
00DC75  2  AA                   TAX                     ; copy index to file to close
00DC76  2  CE 25 03             DEC     IECOPENF        ; decrement open file count
00DC79  2  EC 25 03             CPX     IECOPENF        ; compare index with open file count
00DC7C  2  F0 15                BEQ     LAB_F3CD        ; exit if equal, last entry was closing file
00DC7E  2               
00DC7E  2               ; else entry was not last in list so copy last table entry
00DC7E  2               ; file details over the details of the closing one
00DC7E  2  AC 25 03             LDY     IECOPENF        ; get open file count as index
00DC81  2  B9 B0 03             LDA     PTRLFT,Y        ; get last+1 logical file number from logical file table
00DC84  2  9D B0 03             STA     PTRLFT,X        ; save logical file number over closed file
00DC87  2  B9 BA 03             LDA     PTRDNT,Y        ; get last+1 device number from device number table
00DC8A  2  9D BA 03             STA     PTRDNT,X        ; save device number over closed file
00DC8D  2  B9 C4 03             LDA     PTRSAT,Y        ; get last+1 secondary address from secondary address table
00DC90  2  9D C4 03             STA     PTRSAT,X        ; save secondary address over closed file
00DC93  2               LAB_F3CD:
00DC93  2  18                   CLC                     ;.
00DC94  2               LAB_F3CE:
00DC94  2  60                   RTS
00DC95  2               
00DC95  2               ;***********************************************************************************;
00DC95  2               ;
00DC95  2               ; open a logical file
00DC95  2               
00DC95  2               ; this routine is used to open a logical file. Once the logical file is set up it
00DC95  2               ; can be used for input/output operations. Most of the I/O KERNAL routines call on
00DC95  2               ; this routine to create the logical files to operate on. No arguments need to be
00DC95  2               ; set up to use this routine, but both the SETLFS, LAB_FFBA, and SETNAM, LAB_FFBD,
00DC95  2               ; KERNAL routines must be called before using this routine.
00DC95  2               
00DC95  2               LAB_F40A:
00DC95  2  AE 26 03             LDX     IECLFN          ; get logical file number
00DC98  2  D0 03                BNE     LAB_F411        ; branch if there is a file
00DC9A  2               
00DC9A  2  4C 69 DA             JMP     LAB_F78D        ; else do not input file error and return
00DC9D  2               
00DC9D  2               LAB_F411:
00DC9D  2  20 29 DD             JSR     LAB_F3CF        ; find file
00DCA0  2  D0 03                BNE     LAB_F419        ; branch if file not found
00DCA2  2               
00DCA2  2  4C 5D DA             JMP     LAB_F781        ; else do file already open error and return
00DCA5  2               
00DCA5  2               LAB_F419:
00DCA5  2  AE 25 03             LDX     IECOPENF        ; get open file count
00DCA8  2  E0 0A                CPX     #$0A            ; compare with max
00DCAA  2  90 03                BCC     LAB_F422        ; branch if less
00DCAC  2               
00DCAC  2  4C 5A DA             JMP     LAB_F77E        ; else do too many files error and return
00DCAF  2               
00DCAF  2               LAB_F422:
00DCAF  2  EE 25 03             INC     IECOPENF        ; increment open file count
00DCB2  2  AD 26 03             LDA     IECLFN          ; get logical file number
00DCB5  2  9D B0 03             STA     PTRLFT,X        ; save to logical file table
00DCB8  2  AD 19 03             LDA     IECSECAD        ; get secondary address
00DCBB  2  09 60                ORA     #$60            ; OR with the OPEN CHANNEL command
00DCBD  2  8D 19 03             STA     IECSECAD        ; set secondary address
00DCC0  2  9D C4 03             STA     PTRSAT,X        ; save to secondary address table
00DCC3  2  AD 1C 03             LDA     IECDEVN         ; get device number
00DCC6  2  9D BA 03             STA     PTRDNT,X        ; save to device number table
00DCC9  2               ; serial bus device
00DCC9  2  20 92 DA             JSR     LAB_F495        ; send secondary address and filename
00DCCC  2  18                   CLC                     ; flag ok
00DCCD  2               LAB_F494:
00DCCD  2  60                   RTS
00DCCE  2               
00DCCE  2               ;***********************************************************************************;
00DCCE  2               ;
00DCCE  2               ; open a channel for input
00DCCE  2               
00DCCE  2               ; any logical file that has already been opened by the OPEN routine, LAB_FFC0, can be
00DCCE  2               ; defined as an input channel by this routine. the device on the channel must be an
00DCCE  2               ; input device or an error will occur and the routine will abort.
00DCCE  2               
00DCCE  2               ; if you are getting data from anywhere other than the keyboard, this routine must be
00DCCE  2               ; called before using either the CHRIN routine, LAB_FFCF, or the GETIN routine,
00DCCE  2               ; LAB_FFE4. if you are getting data from the keyboard and no other input channels are
00DCCE  2               ; open then the calls to this routine and to the OPEN routine, LAB_FFC0, are not needed.
00DCCE  2               
00DCCE  2               ; when used with a device on the serial bus this routine will automatically send the
00DCCE  2               ; listen address specified by the OPEN routine, LAB_FFC0, and any secondary address.
00DCCE  2               
00DCCE  2               ; possible errors are:
00DCCE  2               ;
00DCCE  2               ;	3 : file not open
00DCCE  2               ;	5 : device not present
00DCCE  2               ;	6 : file is not an input file
00DCCE  2               
00DCCE  2               LAB_F2C7:
00DCCE  2  20 29 DD             JSR     LAB_F3CF        ; find file
00DCD1  2  F0 03                BEQ     LAB_F2CF        ; branch if file opened
00DCD3  2  4C 60 DA             JMP     LAB_F784        ; do file not open error and return
00DCD6  2               
00DCD6  2               LAB_F2CF:
00DCD6  2  20 3B DD             JSR     LAB_F3DF        ; set file details from table,X
00DCD9  2  AD 1C 03             LDA     IECDEVN         ; get device number
00DCDC  2               ; device was serial bus device
00DCDC  2               LAB_F2F0:
00DCDC  2  AA                   TAX                     ; copy device number to X
00DCDD  2  20 9D D7             JSR     LAB_EE14        ; command a serial bus device to TALK
00DCE0  2  AD 19 03             LDA     IECSECAD        ; get secondary address
00DCE3  2  10 06                BPL     LAB_F2FE        ;.
00DCE5  2               
00DCE5  2  20 77 D8             JSR     LAB_EED3        ; wait for bus end after send
00DCE8  2  4C EE DC             JMP     LAB_F301        ;.
00DCEB  2               
00DCEB  2               LAB_F2FE:
00DCEB  2  20 6A D8             JSR     LAB_EECE        ; send secondary address after TALK
00DCEE  2               LAB_F301:
00DCEE  2  8A                   TXA                     ; copy device back to A
00DCEF  2  2C 17 03             BIT     IECSTW          ; test serial status byte
00DCF2  2  10 03                BPL     LAB_F2EC        ; if device present save device number and exit
00DCF4  2               
00DCF4  2  4C 66 DA             JMP     LAB_F78A        ; do device not present error and return
00DCF7  2               
00DCF7  2               LAB_F2EC:
00DCF7  2  8D 27 03             STA     IECIDN          ; save input device number
00DCFA  2  18                   CLC                     ; flag ok
00DCFB  2  60                   RTS
00DCFC  2               
00DCFC  2               ;***********************************************************************************;
00DCFC  2               ;
00DCFC  2               ; open a channel for output
00DCFC  2               
00DCFC  2               ; any logical file that has already been opened by the OPEN routine, LAB_FFC0, can be
00DCFC  2               ; defined as an output channel by this routine the device on the channel must be an
00DCFC  2               ; output device or an error will occur and the routine will abort.
00DCFC  2               
00DCFC  2               ; if you are sending data to anywhere other than the screen this routine must be
00DCFC  2               ; called before using the CHROUT routine, LAB_FFD2. if you are sending data to the
00DCFC  2               ; screen and no other output channels are open then the calls to this routine and to
00DCFC  2               ; the OPEN routine, LAB_FFC0, are not needed.
00DCFC  2               
00DCFC  2               ; when used with a device on the serial bus this routine will automatically send the
00DCFC  2               ; listen address specified by the OPEN routine, LAB_FFC0, and any secondary address.
00DCFC  2               
00DCFC  2               ; possible errors are:
00DCFC  2               ;
00DCFC  2               ;	3 : file not open
00DCFC  2               ;	5 : device not present
00DCFC  2               ;	7 : file is not an output file
00DCFC  2               
00DCFC  2               LAB_F309:
00DCFC  2  20 29 DD             JSR     LAB_F3CF        ; find file
00DCFF  2  F0 03                BEQ     LAB_F311        ; branch if file found
00DD01  2               
00DD01  2  4C 60 DA             JMP     LAB_F784        ; do file not open error and return
00DD04  2               
00DD04  2               LAB_F311:
00DD04  2  20 3B DD             JSR     LAB_F3DF        ; set file details from table,X
00DD07  2  AD 1C 03             LDA     IECDEVN         ; get device number
00DD0A  2  AA                   TAX                     ; copy device number
00DD0B  2  20 A0 D7             JSR     LAB_EE17        ; command devices on the serial bus to LISTEN
00DD0E  2  AD 19 03             LDA     IECSECAD        ; get secondary address
00DD11  2  10 05                BPL     LAB_F33F        ; branch if address to send
00DD13  2               
00DD13  2  20 61 D8             JSR     LAB_EEC5        ; else set serial ATN high
00DD16  2  D0 03                BNE     LAB_F342        ; branch always
00DD18  2               LAB_F33F:
00DD18  2  20 5B D8             JSR     LAB_EEC0        ; send secondary address after LISTEN
00DD1B  2               LAB_F342:
00DD1B  2  8A                   TXA                     ; copy device number back to A
00DD1C  2  2C 17 03             BIT     IECSTW          ; test serial status byte
00DD1F  2  10 03                BPL     LAB_F32E        ; if device present save output device number and exit
00DD21  2  4C 66 DA             JMP     LAB_F78A        ; else do device not present error and return
00DD24  2               
00DD24  2               LAB_F32E:
00DD24  2  8D 28 03             STA     IECODN          ; save output device number
00DD27  2  18                   CLC                     ; flag ok
00DD28  2  60                   RTS
00DD29  2               
00DD29  2               ;***********************************************************************************;
00DD29  2               ;
00DD29  2               ; find file
00DD29  2               
00DD29  2               LAB_F3CF:
00DD29  2  A9 00                LDA     #$00            ; clear A
00DD2B  2  8D 17 03             STA     IECSTW          ; clear serial status byte
00DD2E  2  8A                   TXA                     ; copy logical file number to A
00DD2F  2               
00DD2F  2               ; find file A
00DD2F  2               
00DD2F  2               LAB_F3D4:
00DD2F  2  AE 25 03             LDX     IECOPENF        ; get open file count
00DD32  2               LAB_F3D6:
00DD32  2  CA                   DEX                     ; decrememnt count to give index
00DD33  2  30 18                BMI     LAB_F3EE        ; exit if no files
00DD35  2               
00DD35  2  DD B0 03             CMP     PTRLFT,X        ; compare logical file number with table logical file number
00DD38  2  D0 F8                BNE     LAB_F3D6        ; loop if no match
00DD3A  2               
00DD3A  2  60                   RTS
00DD3B  2               
00DD3B  2               
00DD3B  2               ;***********************************************************************************;
00DD3B  2               ;
00DD3B  2               ; set file details from table,X
00DD3B  2               
00DD3B  2               LAB_F3DF:
00DD3B  2  BD B0 03             LDA     PTRLFT,X        ; get logical file from logical file table
00DD3E  2  8D 26 03             STA     IECLFN          ; set logical file
00DD41  2  BD BA 03             LDA     PTRDNT,X        ; get device number from device number table
00DD44  2  8D 1C 03             STA     IECDEVN         ; set device number
00DD47  2  BD C4 03             LDA     PTRSAT,X        ; get secondary address from secondary address table
00DD4A  2  8D 19 03             STA     IECSECAD        ; set secondary address
00DD4D  2               LAB_F3EE:
00DD4D  2  60                   RTS
00DD4E  2               
00DD4E  2               ;***********************************************************************************;
00DD4E  2               ;
00DD4E  2               ; close input and output channels
00DD4E  2               
00DD4E  2               ; this routine is called to clear all open channels and restore the I/O channels to
00DD4E  2               ; their original default values. It is usually called after opening other I/O
00DD4E  2               ; channels and using them for input/output operations. The default input device is
00DD4E  2               ; 0, the keyboard. The default output device is 3, the screen.
00DD4E  2               
00DD4E  2               ; If one of the channels to be closed is to the serial port, an UNTALK signal is sent
00DD4E  2               ; first to clear the input channel or an UNLISTEN is sent to clear the output channel.
00DD4E  2               ; By not calling this routine and leaving listener(s) active on the serial bus,
00DD4E  2               ; several devices can receive the same data from the VIC at the same time. One way to
00DD4E  2               ; take advantage of this would be to command the printer to TALK and the disk to
00DD4E  2               ; LISTEN. This would allow direct printing of a disk file.
00DD4E  2               
00DD4E  2               LAB_F3F3:
00DD4E  2  20 AB D8             JSR     LAB_EF04        ; command the serial bus to UNLISTEN
00DD51  2  20 9D D8             JSR     LAB_EEF6        ; command the serial bus to UNTALK
00DD54  2  A9 00                LDA     #$00            ; set for keyboard
00DD56  2  8D 28 03             STA     IECODN          ; set output device number to NULL
00DD59  2  8D 27 03             STA     IECIDN          ; set input device number to NULL
00DD5C  2  60                   RTS
00DD5D  2               
00DD5D  1               
00DD5D  1               
00DD5D  1               
00DD5D  1               ;______________________________________________________________
00DD5D  1               ;        INCLUDE 'RTC.ASM'
00DD5D  1               ;______________________________________________________________
00DD5D  1               
00DD5D  1               
00DD5D  1  00 00 00             .BYTE   00,00,00
00DD60  1               
00DD60  1                       .SEGMENT "NJUMP"
00DD60  1               ; BIOS JUMP TABLE (NATIVE)
00DD60  1                       .ORG    $FD00
00FD00  1               LPRINTVEC:
00FD00  1  20 18 D2             JSR     OUTCH
00FD03  1  6B                   RTL
00FD04  1               LINPVEC:
00FD04  1  20 42 D2             JSR     INCH
00FD07  1  6B                   RTL
00FD08  1               LINPWVEC:
00FD08  1  20 36 D2             JSR     INCHW
00FD0B  1  6B                   RTL
00FD0C  1               LSetXYVEC:
00FD0C  1  20 04 D4             JSR     SetXY
00FD0F  1  6B                   RTL
00FD10  1               LCPYVVEC:
00FD10  1  20 56 D2             JSR     DONOOP
00FD13  1  6B                   RTL
00FD14  1               LSrlUpVEC:
00FD14  1  20 15 D4             JSR     ScrollUp
00FD17  1  6B                   RTL
00FD18  1               LSetColorVEC:
00FD18  1  20 FB D3             JSR     SetColor
00FD1B  1  6B                   RTL
00FD1C  1               LCURSORVEC:
00FD1C  1  20 DF D2             JSR     CURSOR
00FD1F  1  6B                   RTL
00FD20  1               LUNCURSORVEC:
00FD20  1  20 1F D3             JSR     UNCURSOR
00FD23  1  6B                   RTL
00FD24  1               LWRITERTC:
00FD24  1  20 56 D2             JSR     DONOOP
00FD27  1  6B                   RTL
00FD28  1               LREADRTC:
00FD28  1  20 56 D2             JSR     DONOOP
00FD2B  1  6B                   RTL
00FD2C  1               LIECIN:
00FD2C  1  20 C0 D8             JSR     LAB_EF19        ;. Read byte from serial bus. (Must call TALK and TALKSA beforehands.)
00FD2F  1  6B                   RTL
00FD30  1               LIECOUT:
00FD30  1  20 88 D8             JSR     LAB_EEE4        ;. Write byte to serial bus. (Must call LISTEN and LSTNSA beforehands.)
00FD33  1  6B                   RTL
00FD34  1               LUNTALK:
00FD34  1  20 9D D8             JSR     LAB_EEF6        ;. Send UNTALK command to serial bus.
00FD37  1  6B                   RTL
00FD38  1               LUNLSTN:
00FD38  1  20 AB D8             JSR     LAB_EF04        ;. Send UNLISTEN command to serial bus.
00FD3B  1  6B                   RTL
00FD3C  1               LLISTEN:
00FD3C  1  20 A0 D7             JSR     LAB_EE17        ;. Send LISTEN command to serial bus.
00FD3F  1  6B                   RTL
00FD40  1               LTALK:
00FD40  1  20 9D D7             JSR     LAB_EE14        ;. Send TALK command to serial bus.
00FD43  1  6B                   RTL
00FD44  1               LSETLFS:
00FD44  1  20 CD DB             JSR     LAB_FE50        ;. Set file parameters.
00FD47  1  6B                   RTL
00FD48  1               LSETNAM:
00FD48  1  20 C3 DB             JSR     LAB_FE49        ;. Set file name parameters.
00FD4B  1  6B                   RTL
00FD4C  1               LLOAD:
00FD4C  1  20 59 D9             JSR     LOADTORAM       ;. Load or verify file. (Must call SETLFS and SETNAM beforehands.)
00FD4F  1  6B                   RTL
00FD50  1               LSAVE:
00FD50  1  20 DF D9             JSR     IECSAVERAM      ;. Save file. (Must call SETLFS and SETNAM beforehands.)
00FD53  1  6B                   RTL
00FD54  1               LIECINIT:
00FD54  1  20 EB DB             JSR     INITIEC         ; INIT IEC
00FD57  1  6B                   RTL
00FD58  1               LIECCLCH:
00FD58  1  20 4E DD             JSR     LAB_F3F3        ; close input and output channels
00FD5B  1  6B                   RTL
00FD5C  1               LIECOUTC:
00FD5C  1  20 FC DC             JSR     LAB_F309        ; open a channel for output
00FD5F  1  6B                   RTL
00FD60  1               LIECINPC:
00FD60  1  20 CE DC             JSR     LAB_F2C7        ; open a channel for input
00FD63  1  6B                   RTL
00FD64  1               LIECOPNLF:
00FD64  1  20 95 DC             JSR     LAB_F40A        ; open a logical file
00FD67  1  6B                   RTL
00FD68  1               LIECCLSLF:
00FD68  1  20 62 DC             JSR     LAB_F34A        ; close a specified logical file
00FD6B  1  6B                   RTL
00FD6C  1               LClearScrVec:
00FD6C  1  20 9C D4             JSR     ClearScreen     ; clear the 9918 Screen
00FD6F  1  6B                   RTL
00FD70  1               LLOADFONTVec:
00FD70  1  20 56 D2             JSR     DONOOP          ; LOAD THE FONT
00FD73  1  6B                   RTL
00FD74  1               
00FD74  1                       .SEGMENT "EJUMP"
00FD74  1               ; BIOS JUMP TABLE (Emulation)
00FD74  1                       .ORG    $FF71
00FF71  1               PRINTVEC:
00FF71  1  4C 18 D2             JMP     OUTCH
00FF74  1               INPVEC:
00FF74  1  4C 42 D2             JMP     INCH
00FF77  1               INPWVEC:
00FF77  1  4C 36 D2             JMP     INCHW
00FF7A  1               SetXYVEC:
00FF7A  1  4C 04 D4             JMP     SetXY
00FF7D  1               CPYVVEC:
00FF7D  1  4C 56 D2             JMP     DONOOP
00FF80  1               SrlUpVEC:
00FF80  1  4C 15 D4             JMP     ScrollUp
00FF83  1               SetColorVEC:
00FF83  1  4C FB D3             JMP     SetColor
00FF86  1               CURSORVEC:
00FF86  1  4C DF D2             JMP     CURSOR
00FF89  1               UNCURSORVEC:
00FF89  1  4C 1F D3             JMP     UNCURSOR
00FF8C  1               WRITERTC:
00FF8C  1  4C 56 D2             JMP     DONOOP
00FF8F  1               READRTC:
00FF8F  1  4C 56 D2             JMP     DONOOP
00FF92  1               IECIN:
00FF92  1  4C C0 D8             JMP     LAB_EF19        ; Read byte from serial bus. (Must call TALK and TALKSA beforehands.)
00FF95  1               IECOUT:
00FF95  1  4C 88 D8             JMP     LAB_EEE4        ; Write byte to serial bus. (Must call LISTEN and LSTNSA beforehands.)
00FF98  1               UNTALK:
00FF98  1  4C 9D D8             JMP     LAB_EEF6        ; Send UNTALK command to serial bus.
00FF9B  1               UNLSTN:
00FF9B  1  4C AB D8             JMP     LAB_EF04        ; Send UNLISTEN command to serial bus.
00FF9E  1               LISTEN:
00FF9E  1  4C A0 D7             JMP     LAB_EE17        ; Send LISTEN command to serial bus.
00FFA1  1               TALK:
00FFA1  1  4C 9D D7             JMP     LAB_EE14        ; Send TALK command to serial bus.
00FFA4  1               SETLFS:
00FFA4  1  4C CD DB             JMP     LAB_FE50        ; Set file parameters.
00FFA7  1               SETNAM:
00FFA7  1  4C C3 DB             JMP     LAB_FE49        ; Set file name parameters.
00FFAA  1               LOAD:
00FFAA  1  4C 59 D9             JMP     LOADTORAM       ; Load or verify file. (Must call SETLFS and SETNAM beforehands.)
00FFAD  1               SAVE:
00FFAD  1  4C DF D9             JMP     IECSAVERAM      ; Save file. (Must call SETLFS and SETNAM beforehands.)
00FFB0  1               IECINIT:
00FFB0  1  4C EB DB             JMP     INITIEC         ; INIT IEC
00FFB3  1               IECCLCH:
00FFB3  1  4C 4E DD             JMP     LAB_F3F3        ; close input and output channels
00FFB6  1               IECOUTC:
00FFB6  1  4C FC DC             JMP     LAB_F309        ; open a channel for output
00FFB9  1               IECINPC:
00FFB9  1  4C CE DC             JMP     LAB_F2C7        ; open a channel for input
00FFBC  1               IECOPNLF:
00FFBC  1  4C 95 DC             JMP     LAB_F40A        ; open a logical file
00FFBF  1               IECCLSLF:
00FFBF  1  4C 62 DC             JMP     LAB_F34A        ; close a specified logical file
00FFC2  1               ClearScrVec:
00FFC2  1  4C 9C D4             JMP     ClearScreen     ; clear the 9918 Screen
00FFC5  1               LOADFONTVec:
00FFC5  1  4C 56 D2             JMP     DONOOP          ; LOAD THE FONT
00FFC8  1               
00FFC8  1                       .SEGMENT "VECTORS"
00FFC8  1               ; 65c816 Native Vectors
00FFC8  1                       .ORG    $FFE4
00FFE4  1               COPVECTOR:
00FFE4  1  2F C0                .WORD   RCOPVECTOR
00FFE6  1               BRKVECTOR:
00FFE6  1  32 C0                .WORD   RBRKVECTOR
00FFE8  1               ABTVECTOR:
00FFE8  1  35 C0                .WORD   RABTVECTOR
00FFEA  1               NMIVECTOR:
00FFEA  1  38 C0                .WORD   RNMIVECTOR
00FFEC  1               resv1:
00FFEC  1  00 00                .WORD   $0000           ;
00FFEE  1               IRQVECTOR:
00FFEE  1  3B C0                .WORD   RIRQVECTOR      ; ROM VECTOR FOR IRQ
00FFF0  1               
00FFF0  1  00 00                .WORD   $0000           ;
00FFF2  1  00 00                .WORD   $0000           ;
00FFF4  1               
00FFF4  1               ; 6502 Emulation Vectors
00FFF4  1                       .ORG    $FFF4
00FFF4  1               ECOPVECTOR:
00FFF4  1  3E C0                .WORD   RECOPVECTOR
00FFF6  1               resv2:
00FFF6  1  00 00                .WORD   $0000
00FFF8  1               EABTVECTOR:
00FFF8  1  41 C0                .WORD   REABTVECTOR
00FFFA  1               ENMIVECTOR:
00FFFA  1  44 C0                .WORD   RENMIVECTOR
00FFFC  1               RSTVECTOR:
00FFFC  1  00 C0                .WORD   COLD_START      ;
00FFFE  1               EINTVECTOR:
00FFFE  1  47 C0                .WORD   REINTVECTOR     ; ROM VECTOR FOR IRQ
010000  1               
010000  1                       .END

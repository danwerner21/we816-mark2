ca65 V2.18 - Ubuntu 2.19-1
Main file   : dbasic816.asm
Current file: dbasic816.asm

000000r 1               .P816
000000r 1               .A8
000000r 1               .I8
000000r 1               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.23
000000r 1               ; THIS WORK IS DERIVED FROM ehBASIC BY LEE DAVIDSON
000000r 1               ;
000000r 1               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 1               
000000r 1               ; 2.00	new revision numbers start here
000000r 1               ; 2.01	fixed LCASE$() and UCASE$()
000000r 1               ; 2.02	new get value routine done
000000r 1               ; 2.03	changed RND() to galoise method
000000r 1               ; 2.04	fixed SPC()
000000r 1               ; 2.05	new get value routine fixedf
000000r 1               ; 2.06	changed USR() code
000000r 1               ; 2.07	fixed STR$()
000000r 1               ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
000000r 1               ; 2.09	fixed RND()
000000r 1               ; 2.10	integrated missed changes from an earlier version
000000r 1               ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 1               ; 2.21	fixed IF .. THEN RETURN to not cause error
000000r 1               ; 2.22	fixed RND() breaking the get byte routine
000000r 1               ; 2.30  CONVERT TO 65816 ADDRESS SPACE
000000r 1               
000000r 1               
000000r 1               
000000r 1                       .SEGMENT "HIGHMEM"
000000r 1               ;.ORG    0FF1000H
000000r 1                       .ORG    1000H
001000  1               BASICORG:
001000  1  4C 7B 26             JMP     BASICBEGIN
001003  1               ;____________________________________________________________________________________________
001003  1               ;
001003  1               ; MACROS
001003  1               
001003  1                       .INCLUDE "macros.asm"
001003  2               ;___________________________________________________________________________________________________
001003  2               ;
001003  2               ;	USEFUL 65186 MACROS
001003  2               ;__________________________________________________________________________________________________
001003  2               
001003  2               .macro       STORECONTEXT             ; Store Complete Context at the beginning of a Sub
001003  2                       PHX
001003  2                       phy
001003  2                       pha
001003  2                       php
001003  2               .endmacro
001003  2               
001003  2               .macro       RESTORECONTEXT                 ; Restore Complete Context at the end of a Sub
001003  2                       plp
001003  2                       pla
001003  2                       ply
001003  2                       plx
001003  2               .endmacro
001003  2               
001003  2               .macro       INDEX16                         ; Set 16bit Index Registers
001003  2               		REP #$10 		; 16 bit Index registers
001003  2               		.I16
001003  2               .endmacro
001003  2               .macro       INDEX8                          ; Set 8bit Index Registers
001003  2               		SEP #$10 		; 8 bit Index registers
001003  2               		.I8
001003  2               .endmacro
001003  2               
001003  2               .macro       ACCUMULATOR16                  ; Set 16bit Index Registers
001003  2               		REP #$20 		; 16 bit Index registers
001003  2               		.A16
001003  2               .endmacro
001003  2               
001003  2               .macro       ACCUMULATOR8                   ; Set 8bit Index Registers
001003  2               		SEP #$20 		; 8 bit Index registers
001003  2               		.A8
001003  2               .endmacro
001003  2               
001003  2               .macro       ACCUMULATORINDEX16             ; Set 16bit Index Registers
001003  2               		REP #$30 		; 16 bit Index registers
001003  2               		.A16
001003  2                               .I16
001003  2               .endmacro
001003  2               
001003  2               .macro       ACCUMULATORINDEX8              ; Set 8bit Index Registers
001003  2               		SEP #$30 		; 8 bit Index registers
001003  2               		.A8
001003  2                               .I8
001003  2               .endmacro
001003  2               
001003  2               .macro       LDAINDIRECTY PARM1
001003  2                   PHB
001003  2               	PHX
001003  2                   LDX #$01
001003  2                   LDA <PARM1,X
001003  2                   CMP #$00
001003  2                   BNE *+6
001003  2               	LDX #00
001003  2               	PHX
001003  2               	PLB
001003  2                   PLX
001003  2               	LDA	(<PARM1),Y		;
001003  2                   STA <TMPFLG
001003  2                   PLB
001003  2                   LDA <TMPFLG
001003  2               .endmacro
001003  2               
001003  2               .macro       STAINDIRECTY PARM1
001003  2                   PHB
001003  2               	PHX
001003  2                   PHA
001003  2                   LDX #$01
001003  2                   LDA <PARM1,X
001003  2                   CMP #$00
001003  2                   BNE *+6
001003  2               	LDX #00
001003  2               	PHX
001003  2               	PLB
001003  2                   PLA
001003  2                   PLX
001003  2               	STA	(<PARM1),Y		;
001003  2               	PLB
001003  2                   STA <TMPFLG
001003  2               .endmacro
001003  2               
001003  2               .macro       SETBANK PARM1
001003  2                   PHX
001003  2               	LDX #PARM1
001003  2               	PHX
001003  2               	PLB
001003  2                   PLX
001003  2               .endmacro
001003  2               
001003  2               
001003  2               .macro       FETCHINDIRECTY PARM1
001003  2                   PHB
001003  2               	PHA
001003  2                   PHX
001003  2                   LDX #$01
001003  2                   LDA <PARM1,X
001003  2                   CMP #$00
001003  2                   BNE *+6
001003  2               	LDX #00
001003  2               	PHX
001003  2               	PLB
001003  2                   PLX
001003  2                   LDA	(<PARM1),Y		;
001003  2                   STA <TMPFLG
001003  2                   PLA
001003  2                   PLB
001003  2               .endmacro
001003  2               
001003  2               .macro       CMPINDIRECTY PARM1
001003  2                   PHB
001003  2                   PHA
001003  2                   PHX
001003  2                   LDX #$01
001003  2                   LDA <PARM1,X
001003  2                   CMP #$00
001003  2                   BNE *+6
001003  2               	LDX #00
001003  2               	PHX
001003  2               	PLB
001003  2                   PLX
001003  2                   LDA	(<PARM1),Y		;
001003  2                   STA <TMPFLG
001003  2                   PLA
001003  2                   PLB
001003  2                   CMP	<TMPFLG		    ;
001003  2               .endmacro
001003  2               
001003  2               .macro       ADCINDIRECTY PARM1
001003  2                   PHB
001003  2                   PHA
001003  2                   PHX
001003  2                   LDX #$01
001003  2                   LDA <PARM1,X
001003  2                   CMP #$00
001003  2                   BNE *+6
001003  2               	LDX #00
001003  2               	PHX
001003  2               	PLB
001003  2                   PLX
001003  2                   LDA	(<PARM1),Y		;
001003  2                   STA <TMPFLG
001003  2                   PLA
001003  2                   PLB
001003  2                   CLC
001003  2                   ADC	<TMPFLG 		;
001003  2               .endmacro
001003  2               
001003  2               .macro       LBEQ PARM1
001003  2                    bne *+5
001003  2                    jmp PARM1
001003  2               .endmacro
001003  2               
001003  2               .macro       LBNE PARM1
001003  2                    beq *+5
001003  2                    jmp PARM1
001003  2               .endmacro
001003  2               
001003  2               .macro       LBCC PARM1
001003  2                    bcc *+4
001003  2                    bra *+5
001003  2                    jmp PARM1
001003  2               .endmacro
001003  2               
001003  2               .macro       LBCS PARM1
001003  2                    bcs *+4
001003  2                    bra *+5
001003  2                    jmp PARM1
001003  2               .endmacro
001003  2               
001003  1               
001003  1               ; ZERO PAGE DEFINITIONS
001003  1                       .INCLUDE "zeropage.asm"
001003  2               ;____________________________________________________________________________________________
001003  2               ;
001003  2               ; ZERO PAGE DEFINITIONS
001003  2               ;____________________________________________________________________________________________
001003  2               
001003  2               LAB_WARM        = $00           ; BASIC warm start entry point
001003  2               Wrmjpl          = LAB_WARM+1    ; BASIC warm start vector jump low byte
001003  2               Wrmjph          = LAB_WARM+2    ; BASIC warm start vector jump high byte
001003  2               TMPFLG          = $04
001003  2               VIDEOMODE       = $06
001003  2               LOCALWORK       = $07           ; word (2 bytes)
001003  2               Usrjmp          = $0A           ; USR function JMP address
001003  2               Usrjpl          = <Usrjmp+1     ; USR function JMP vector low byte
001003  2               Usrjph          = <Usrjmp+2     ; USR function JMP vector high byte
001003  2               Nullct          = $0D           ; nulls output after each line
001003  2               TPos            = $0E           ; BASIC terminal position byte
001003  2               TWidth          = $0F           ; BASIC terminal width byte
001003  2               Iclim           = $10           ; input column limit
001003  2               Itempl          = $11           ; temporary integer low byte
001003  2               Itemph          = <Itempl+1     ; temporary integer high byte
001003  2               
001003  2               nums_1          = <Itempl       ; number to bin/hex string convert MSB
001003  2               nums_2          = <nums_1+1     ; number to bin/hex string convert
001003  2               nums_3          = <nums_1+2     ; number to bin/hex string convert LSB
001003  2               
001003  2               Srchc           = $5B           ; search character
001003  2               Temp3           = <Srchc        ; temp byte used in number routines
001003  2               Scnquo          = $5C           ; scan-between-quotes flag
001003  2               Asrch           = <Scnquo       ; alt search character
001003  2               
001003  2               XOAw_l          = <Srchc        ; eXclusive OR, OR and AND word low byte
001003  2               XOAw_h          = <Scnquo       ; eXclusive OR, OR and AND word high byte
001003  2               
001003  2               Ibptr           = $5D           ; input buffer pointer
001003  2               Dimcnt          = <Ibptr        ; # of dimensions
001003  2               Tindx           = <Ibptr        ; token index
001003  2               
001003  2               Defdim          = $5E           ; default DIM flag
001003  2               Dtypef          = $5F           ; data type flag, $FF=string, $00=numeric
001003  2               Oquote          = $60           ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
001003  2               Gclctd          = $60           ; garbage collected flag
001003  2               Sufnxf          = $61           ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
001003  2               Imode           = $62           ; input mode flag, $00=INPUT, $80=READ
001003  2               Cflag           = $63           ; comparison evaluation flag
001003  2               
001003  2               TabSiz          = $64           ; TAB step size (was input flag)
001003  2               
001003  2               next_s          = $65           ; next descriptor stack address
001003  2               ; these two bytes form a word pointer to the item
001003  2               ; currently on top of the descriptor stack
001003  2               last_sl         = $66           ; last descriptor stack address low byte
001003  2               last_sh         = $67           ; last descriptor stack address high byte (always $00)
001003  2               
001003  2               des_sk          = $68           ; descriptor stack start address (temp strings)
001003  2               
001003  2               ;			= $70		; End of descriptor stack
001003  2               
001003  2               ut1_pl          = $71           ; utility pointer 1 low byte
001003  2               ut1_ph          = <ut1_pl+1     ; utility pointer 1 high byte
001003  2               ut2_pl          = $73           ; utility pointer 2 low byte
001003  2               ut2_ph          = <ut2_pl+1     ; utility pointer 2 high byte
001003  2               
001003  2               Temp_2          = <ut1_pl       ; temp byte for block move
001003  2               
001003  2               FACt_1          = $75           ; FAC temp mantissa1
001003  2               FACt_2          = <FACt_1+1     ; FAC temp mantissa2
001003  2               FACt_3          = <FACt_2+1     ; FAC temp mantissa3
001003  2               
001003  2               dims_l          = <FACt_2       ; array dimension size low byte
001003  2               dims_h          = <FACt_3       ; array dimension size high byte
001003  2               
001003  2               TempB           = $78           ; temp page 0 byte
001003  2               
001003  2               Smeml           = $79           ; start of mem low byte		(Start-of-Basic)
001003  2               Smemh           = <Smeml+1      ; start of mem high byte	(Start-of-Basic)
001003  2               Svarl           = $7B           ; start of vars low byte	(Start-of-Variables)
001003  2               Svarh           = <Svarl+1      ; start of vars high byte	(Start-of-Variables)
001003  2               Sarryl          = $7D           ; var mem end low byte		(Start-of-Arrays)
001003  2               Sarryh          = <Sarryl+1     ; var mem end high byte		(Start-of-Arrays)
001003  2               Earryl          = $7F           ; array mem end low byte	(End-of-Arrays)
001003  2               Earryh          = <Earryl+1     ; array mem end high byte	(End-of-Arrays)
001003  2               Sstorl          = $81           ; string storage low byte	(String storage (moving down))
001003  2               Sstorh          = <Sstorl+1     ; string storage high byte	(String storage (moving down))
001003  2               Sutill          = $83           ; string utility ptr low byte
001003  2               Sutilh          = <Sutill+1     ; string utility ptr high byte
001003  2               Ememl           = $85           ; end of mem low byte		(Limit-of-memory)
001003  2               Ememh           = <Ememl+1      ; end of mem high byte		(Limit-of-memory)
001003  2               
001003  2               Clinel          = $87           ; current line low byte		(Basic line number)
001003  2               Clineh          = <Clinel+1     ; current line high byte	(Basic line number)
001003  2               Blinel          = $89           ; break line low byte		(Previous Basic line number)
001003  2               Blineh          = <Blinel+1     ; break line high byte		(Previous Basic line number)
001003  2               
001003  2               Cpntrl          = $8B           ; continue pointer low byte
001003  2               Cpntrh          = <Cpntrl+1     ; continue pointer high byte
001003  2               
001003  2               Dlinel          = $8D           ; current DATA line low byte
001003  2               Dlineh          = <Dlinel+1     ; current DATA line high byte
001003  2               
001003  2               Dptrl           = $8F           ; DATA pointer low byte
001003  2               Dptrh           = <Dptrl+1      ; DATA pointer high byte
001003  2               
001003  2               Rdptrl          = $91           ; read pointer low byte
001003  2               Rdptrh          = <Rdptrl+1     ; read pointer high byte
001003  2               
001003  2               Varnm1          = $93           ; current var name 1st byte
001003  2               Varnm2          = <Varnm1+1     ; current var name 2nd byte
001003  2               
001003  2               Cvaral          = $95           ; current var address low byte
001003  2               Cvarah          = <Cvaral+1     ; current var address high byte
001003  2               
001003  2               Frnxtl          = $97           ; var pointer for FOR/NEXT low byte
001003  2               Frnxth          = <Frnxtl+1     ; var pointer for FOR/NEXT high byte
001003  2               
001003  2               Tidx1           = <Frnxtl       ; temp line index
001003  2               
001003  2               Lvarpl          = <Frnxtl       ; let var pointer low byte
001003  2               Lvarph          = <Frnxth       ; let var pointer high byte
001003  2               
001003  2               prstk           = $99           ; precedence stacked flag
001003  2               
001003  2               comp_f          = $9B           ; compare function flag, bits 0,1 and 2 used
001003  2               ; bit 2 set if >
001003  2               ; bit 1 set if =
001003  2               ; bit 0 set if <
001003  2               
001003  2               func_l          = $9C           ; function pointer low byte
001003  2               func_h          = <func_l+1     ; function pointer high byte
001003  2               
001003  2               garb_l          = <func_l       ; garbage collection working pointer low byte
001003  2               garb_h          = <func_h       ; garbage collection working pointer high byte
001003  2               
001003  2               des_2l          = $9E           ; string descriptor_2 pointer low byte
001003  2               des_2h          = <des_2l+1     ; string descriptor_2 pointer high byte
001003  2               
001003  2               g_step          = $A0           ; garbage collect step size
001003  2               
001003  2               Fnxjmp          = $A1           ; jump vector for functions
001003  2               Fnxjpl          = <Fnxjmp+1     ; functions jump vector low byte
001003  2               Fnxjph          = <Fnxjmp+2     ; functions jump vector high byte
001003  2               
001003  2               g_indx          = <Fnxjpl       ; garbage collect temp index
001003  2               
001003  2               FAC2_r          = $A3           ; FAC2 rounding byte
001003  2               
001003  2               Adatal          = $A4           ; array data pointer low byte
001003  2               Adatah          = <Adatal+1     ; array data pointer high  byte
001003  2               
001003  2               Nbendl          = <Adatal       ; new block end pointer low byte
001003  2               Nbendh          = <Adatah       ; new block end pointer high  byte
001003  2               
001003  2               Obendl          = $A6           ; old block end pointer low byte
001003  2               Obendh          = <Obendl+1     ; old block end pointer high  byte
001003  2               
001003  2               numexp          = $A8           ; string to float number exponent count
001003  2               expcnt          = $A9           ; string to float exponent count
001003  2               
001003  2               numbit          = <numexp       ; bit count for array element calculations
001003  2               
001003  2               numdpf          = $AA           ; string to float decimal point flag
001003  2               expneg          = $AB           ; string to float eval exponent -ve flag
001003  2               
001003  2               Astrtl          = <numdpf       ; array start pointer low byte
001003  2               Astrth          = <expneg       ; array start pointer high  byte
001003  2               
001003  2               Histrl          = <numdpf       ; highest string low byte
001003  2               Histrh          = <expneg       ; highest string high  byte
001003  2               
001003  2               Baslnl          = <numdpf       ; BASIC search line pointer low byte
001003  2               Baslnh          = <expneg       ; BASIC search line pointer high  byte
001003  2               
001003  2               Fvar_l          = <numdpf       ; find/found variable pointer low byte
001003  2               Fvar_h          = <expneg       ; find/found variable pointer high  byte
001003  2               
001003  2               Ostrtl          = <numdpf       ; old block start pointer low byte
001003  2               Ostrth          = <expneg       ; old block start pointer high  byte
001003  2               
001003  2               Vrschl          = <numdpf       ; variable search pointer low byte
001003  2               Vrschh          = <expneg       ; variable search pointer high  byte
001003  2               
001003  2               FAC1_e          = $AC           ; FAC1 exponent
001003  2               FAC1_1          = <FAC1_e+1     ; FAC1 mantissa1
001003  2               FAC1_2          = <FAC1_e+2     ; FAC1 mantissa2
001003  2               FAC1_3          = <FAC1_e+3     ; FAC1 mantissa3
001003  2               FAC1_s          = <FAC1_e+4     ; FAC1 sign (b7)
001003  2               
001003  2               str_ln          = <FAC1_e       ; string length
001003  2               str_pl          = <FAC1_1       ; string pointer low byte
001003  2               str_ph          = <FAC1_2       ; string pointer high byte
001003  2               
001003  2               des_pl          = <FAC1_2       ; string descriptor pointer low byte
001003  2               des_ph          = <FAC1_3       ; string descriptor pointer high byte
001003  2               
001003  2               mids_l          = <FAC1_3       ; MID$ string temp length byte
001003  2               
001003  2               negnum          = $B1           ; string to float eval -ve flag
001003  2               numcon          = $B1           ; series evaluation constant count
001003  2               
001003  2               FAC1_o          = $B2           ; FAC1 overflow byte
001003  2               
001003  2               FAC2_e          = $B3           ; FAC2 exponent
001003  2               FAC2_1          = <FAC2_e+1     ; FAC2 mantissa1
001003  2               FAC2_2          = <FAC2_e+2     ; FAC2 mantissa2
001003  2               FAC2_3          = <FAC2_e+3     ; FAC2 mantissa3
001003  2               FAC2_s          = <FAC2_e+4     ; FAC2 sign (b7)
001003  2               
001003  2               FAC_sc          = $B8           ; FAC sign comparison, Acc#1 vs #2
001003  2               FAC1_r          = $B9           ; FAC1 rounding byte
001003  2               
001003  2               ssptr_l         = <FAC_sc       ; string start pointer low byte
001003  2               ssptr_h         = <FAC1_r       ; string start pointer high byte
001003  2               
001003  2               sdescr          = <FAC_sc       ; string descriptor pointer
001003  2               
001003  2               csidx           = $BA           ; line crunch save index
001003  2               Asptl           = <csidx        ; array size/pointer low byte
001003  2               Aspth           = $BB           ; array size/pointer high byte
001003  2               
001003  2               Btmpl           = <Asptl        ; BASIC pointer temp low byte
001003  2               Btmph           = <Aspth        ; BASIC pointer temp low byte
001003  2               
001003  2               Cptrl           = <Asptl        ; BASIC pointer temp low byte
001003  2               Cptrh           = <Aspth        ; BASIC pointer temp low byte
001003  2               
001003  2               Sendl           = <Asptl        ; BASIC pointer temp low byte
001003  2               Sendh           = <Aspth        ; BASIC pointer temp low byte
001003  2               
001003  2               LAB_IGBY        = $BC           ; get next BASIC byte subroutine
001003  2               
001003  2               LAB_GBYT        = $C2           ; get current BASIC byte subroutine
001003  2               Bpntrl          = $C3           ; BASIC execute (get byte) pointer low byte
001003  2               Bpntrh          = <Bpntrl+1     ; BASIC execute (get byte) pointer high byte
001003  2               Bpntrp          = <Bpntrl+2     ; BASIC execute (get byte) pointer PAGE byte
001003  2               
001003  2               ;			= $E0		; end of get BASIC char subroutine
001003  2               
001003  2               Rbyte4          = $E1           ; extra PRNG byte
001003  2               Rbyte1          = <Rbyte4+1     ; most significant PRNG byte
001003  2               Rbyte2          = <Rbyte4+2     ; middle PRNG byte
001003  2               Rbyte3          = <Rbyte4+3     ; least significant PRNG byte
001003  2               
001003  2               NmiBase         = $E5           ; NMI handler enabled/setup/triggered flags
001003  2               ; bit	function
001003  2               ; ===	========
001003  2               ; 7	interrupt enabled
001003  2               ; 6	interrupt setup
001003  2               ; 5	interrupt happened
001003  2               ;			= $E6		; NMI handler addr low byte
001003  2               ;			= $E7		; NMI handler addr high byte
001003  2               IrqBase         = $E8           ; IRQ handler enabled/setup/triggered flags
001003  2               ;			= $E9		; IRQ handler addr low byte
001003  2               ;			= $EA		; IRQ handler addr high byte
001003  2               FCBPTR          = $EB           ; POINTER TO FCB FOR FILE OPS
001003  2               
001003  2               Decss           = $EF           ; number to decimal string start
001003  2               Decssp1         = Decss+1       ; number to decimal string start
001003  2               
001003  2               TEMPW           = $FD
001003  2               ;			= $FF		; decimal string end
001003  2               
001003  2               
001003  2               ;____________________________________________________________________________________________
001003  2               ;
001003  2               ; character get subroutine for zero page
001003  2               
001003  2               ; For a 1.8432MHz 6502 including the JSR and RTS
001003  2               ; fastest (>=":")	=  29 cycles =  15.7uS
001003  2               ; slowest (<":")	=  40 cycles =  21.7uS
001003  2               ; space skip	= +21 cycles = +11.4uS
001003  2               ; inc across page	=  +4 cycles =  +2.2uS
001003  2               
001003  2               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
001003  2               ; block is copied to it's destination, any non zero page address will do at assembly
001003  2               ; time, to assemble a three byte instruction.
001003  2               
001003  2               ; page 0 initialisation table from $BC
001003  2               ; increment and scan memory
001003  2               ;____________________________________________________________________________________________
001003  2               
001003  2               LAB_2CEE:
001003  2  E6 C3                INC     <Bpntrl         ; increment BASIC execute pointer low byte
001005  2  D0 02                BNE     LAB_2CF4        ; branch if no carry
001007  2               ; else
001007  2  E6 C4                INC     <Bpntrh         ; increment BASIC execute pointer high byte
001009  2               
001009  2               ; page 0 initialisation table from $C2
001009  2               ; scan memory
001009  2               LAB_2CF4:
001009  2  AF FF FF FF          LDA     $FFFFFF         ; get byte to scan (addr set by call routine)
00100D  2  C9 C1                CMP     #TK_ELSE        ; compare with the token for ELSE
00100F  2  F0 0E                BEQ     LAB_2D05        ; exit if ELSE, not numeric, carry set
001011  2               
001011  2  C9 3A                CMP     #':'            ; compare with ":"
001013  2  B0 0A                BCS     LAB_2D05        ; exit if >= ":", not numeric, carry set
001015  2               
001015  2  C9 20                CMP     #' '            ; compare with " "
001017  2  F0 EA                BEQ     LAB_2CEE        ; if " " go do next
001019  2               
001019  2  38                   SEC                     ; set carry for SBC
00101A  2  E9 30                SBC     #'0'            ; subtract "0"
00101C  2  38                   SEC                     ; set carry for SBC
00101D  2  E9 D0                SBC     #$D0            ; subtract -"0"
00101F  2               ; clear carry if byte = "0"-"9"
00101F  2               LAB_2D05:
00101F  2  6B                   RTL
001020  2               LAB_2CEE_END:
001020  2               ;____________________________________________________________________________________________
001020  2               ;
001020  2               ; page zero initialisation table $00-$12 inclusive
001020  2               ;____________________________________________________________________________________________
001020  2               
001020  2               StrTab:
001020  2  4C                   .BYTE   $4C             ; JMP opcode
001021  2  9B 26                .WORD   LAB_COLD        ; initial warm start vector (cold start)
001023  2               
001023  2  00                   .BYTE   $00             ; these bytes are not used by BASIC
001024  2  00 00                .WORD   $0000           ;
001026  2  00 00                .WORD   $0000           ;
001028  2  00 00                .WORD   $0000           ;
00102A  2               
00102A  2  4C                   .BYTE   $4C             ; JMP opcode
00102B  2  C7 37                .WORD   LAB_FCER        ; initial user function vector ("Function call" error)
00102D  2  00                   .BYTE   $00             ; default NULL count
00102E  2  00                   .BYTE   $00             ; clear terminal position
00102F  2  00                   .BYTE   $00             ; default terminal width byte
001030  2  F2                   .BYTE   $F2             ; default limit for TAB = 14
001031  2  00 22                .WORD   Ram_base        ; start of user RAM
001033  2               EndTab:
001033  2               
001033  2               ;  BASIC start-up code
001033  2               
001033  2               PG2_TABS:
001033  2  00                   .BYTE   $00             ; ctrl-c flag		-	$00 = enabled
001034  2  03                   .BYTE   $03             ; ctrl-c byte		-	GET needs this
001035  2  00                   .BYTE   $00             ; ctrl-c byte timeout	-	GET needs this
001036  2  76 4C                .WORD   CTRLC           ; ctrl c check vector
001038  2               PG2_TABE:
001038  2               
001038  1               
001038  1               ; BASIC TOKENS
001038  1                       .INCLUDE "tokens.asm"
001038  2               ; token values needed for BASIC
001038  2               
001038  2               ; primary command tokens (can start a statement)
001038  2               
001038  2               TK_END          = $80           ; END
001038  2               TK_FOR          = TK_END+1      ; FOR token
001038  2               TK_NEXT         = TK_FOR+1      ; NEXT token
001038  2               TK_DATA         = TK_NEXT+1     ; DATA token
001038  2               TK_DIRECTORY    = TK_DATA+1     ; DISKSTATUS token
001038  2               TK_DISKSTATUS   = TK_DIRECTORY+1; DIRECTORY token
001038  2               TK_INPUT        = TK_DISKSTATUS+1; INPUT token
001038  2               TK_DIM          = TK_INPUT+1    ; DIM token
001038  2               TK_READ         = TK_DIM+1      ; READ token
001038  2               TK_LET          = TK_READ+1     ; LET token
001038  2               TK_DEC          = TK_LET+1      ; DEC token
001038  2               TK_GOTO         = TK_DEC+1      ; GOTO token
001038  2               TK_RUN          = TK_GOTO+1     ; RUN token
001038  2               TK_IF           = TK_RUN+1      ; IF token
001038  2               TK_RESTORE      = TK_IF+1       ; RESTORE token
001038  2               TK_GOSUB        = TK_RESTORE+1  ; GOSUB token
001038  2               TK_RETURN       = TK_GOSUB+1    ; RETURN token
001038  2               TK_REM          = TK_RETURN+1   ; REM token
001038  2               TK_STOP         = TK_REM+1      ; STOP token
001038  2               TK_ON           = TK_STOP+1     ; ON token
001038  2               TK_NULL         = TK_ON+1       ; NULL token
001038  2               TK_INC          = TK_NULL+1     ; INC token
001038  2               TK_WAIT         = TK_INC+1      ; WAIT token
001038  2               TK_LOAD         = TK_WAIT+1     ; LOAD token
001038  2               TK_SAVE         = TK_LOAD+1     ; SAVE token
001038  2               TK_DEF          = TK_SAVE+1     ; DEF token
001038  2               TK_POKE         = TK_DEF+1      ; POKE token
001038  2               TK_CALL         = TK_POKE+1     ; CALL token
001038  2               TK_DO           = TK_CALL+1     ; DO token
001038  2               TK_LOOP         = TK_DO+1       ; LOOP token
001038  2               TK_PRINT        = TK_LOOP+1     ; PRINT token
001038  2               TK_CONT         = TK_PRINT+1    ; CONT token
001038  2               TK_LIST         = TK_CONT+1     ; LIST token
001038  2               TK_CLEAR        = TK_LIST+1     ; CLEAR token
001038  2               TK_NEW          = TK_CLEAR+1    ; NEW token
001038  2               TK_WIDTH        = TK_NEW+1      ; WIDTH token
001038  2               TK_GET          = TK_WIDTH+1    ; GET token
001038  2               TK_SWAP         = TK_GET+1      ; SWAP token
001038  2               TK_BITSET       = TK_SWAP+1     ; BITSET token
001038  2               TK_BITCLR       = TK_BITSET+1   ; BITCLR token
001038  2               TK_MONITOR      = TK_BITCLR+1   ; MONITOR token
001038  2               TK_OPEN         = TK_MONITOR+1  ; OPEN token
001038  2               TK_CLOSE        = TK_OPEN+1     ; CLOSE token
001038  2               TK_IECINPUT     = TK_CLOSE+1    ; IECINPUT token
001038  2               TK_IECOUTPUT    = TK_IECINPUT+1 ; IECOUTPUT token
001038  2               TK_PUTN         = TK_IECOUTPUT+1; PUTN token
001038  2               TK_GETN         = TK_PUTN+1     ; GETN token
001038  2               TK_DISKCMD      = TK_GETN+1     ; DISKCMD token
001038  2               TK_SCNCLR       = TK_DISKCMD+1  ;SCNCLR token
001038  2               TK_LOCATE       = TK_SCNCLR+1   ;LOCATE token
001038  2               TK_COLOR        = TK_LOCATE+1   ;COLOR token
001038  2               TK_SPOKE        = TK_COLOR+1    ;SPOKE token
001038  2               TK_SCREEN       = TK_SPOKE+1    ;SCREEN token
001038  2               TK_SPRITE       = TK_SCREEN+1   ;SPRITE token
001038  2               TK_SPRDEF       = TK_SPRITE+1   ;SPRDEF token
001038  2               TK_SPRSIZE      = TK_SPRDEF+1   ;SPRSIZE token
001038  2               TK_PLOT         = TK_SPRSIZE+1  ;PLOT token
001038  2               TK_PATTERN      = TK_PLOT+1     ;PATTERN token
001038  2               TK_SYS          = TK_PATTERN+1  ;SYS token
001038  2               TK_SOUND        = TK_SYS+1      ;SOUND token
001038  2               TK_NOISE        = TK_SOUND+1    ;NOISE token
001038  2               TK_TONE         = TK_NOISE+1    ;TONE token
001038  2               TK_VOLUME       = TK_TONE+1     ;VOLUME token
001038  2               TK_VOICE        = TK_VOLUME+1   ;VOICE token
001038  2               
001038  2               ; secondary command tokens, can't start a statement
001038  2               
001038  2               TK_TAB          = TK_VOICE+1    ; TAB token
001038  2               TK_ELSE         = TK_TAB+1      ; ELSE token
001038  2               TK_TO           = TK_ELSE+1     ; TO token
001038  2               TK_FN           = TK_TO+1       ; FN token
001038  2               TK_SPC          = TK_FN+1       ; SPC token
001038  2               TK_THEN         = TK_SPC+1      ; THEN token
001038  2               TK_NOT          = TK_THEN+1     ; NOT token
001038  2               TK_STEP         = TK_NOT+1      ; STEP token
001038  2               TK_UNTIL        = TK_STEP+1     ; UNTIL token
001038  2               TK_WHILE        = TK_UNTIL+1    ; WHILE token
001038  2               TK_OFF          = TK_WHILE+1    ; OFF token
001038  2               
001038  2               ; opperator tokens
001038  2               
001038  2               TK_PLUS         = TK_OFF+1      ; + token
001038  2               TK_MINUS        = TK_PLUS+1     ; - token
001038  2               TK_MUL          = TK_MINUS+1    ; * token
001038  2               TK_DIV          = TK_MUL+1      ; / token
001038  2               TK_POWER        = TK_DIV+1      ; ^ token
001038  2               TK_AND          = TK_POWER+1    ; AND token
001038  2               TK_EOR          = TK_AND+1      ; EOR token
001038  2               TK_OR           = TK_EOR+1      ; OR token
001038  2               TK_RSHIFT       = TK_OR+1       ; RSHIFT token
001038  2               TK_LSHIFT       = TK_RSHIFT+1   ; LSHIFT token
001038  2               TK_GT           = TK_LSHIFT+1   ; > token
001038  2               TK_EQUAL        = TK_GT+1       ; = token
001038  2               TK_LT           = TK_EQUAL+1    ; < token
001038  2               
001038  2               ; functions tokens
001038  2               
001038  2               TK_SGN          = TK_LT+1       ; SGN token
001038  2               TK_INT          = TK_SGN+1      ; INT token
001038  2               TK_ABS          = TK_INT+1      ; ABS token
001038  2               TK_USR          = TK_ABS+1      ; USR token
001038  2               TK_FRE          = TK_USR+1      ; FRE token
001038  2               TK_POS          = TK_FRE+1      ; POS token
001038  2               TK_SQR          = TK_POS+1      ; SQR token
001038  2               TK_RND          = TK_SQR+1      ; RND token
001038  2               TK_LOG          = TK_RND+1      ; LOG token
001038  2               TK_EXP          = TK_LOG+1      ; EXP token
001038  2               TK_COS          = TK_EXP+1      ; COS token
001038  2               TK_SIN          = TK_COS+1      ; SIN token
001038  2               TK_TAN          = TK_SIN+1      ; TAN token
001038  2               TK_ATN          = TK_TAN+1      ; ATN token
001038  2               TK_PEEK         = TK_ATN+1      ; PEEK token
001038  2               TK_SPEEK        = TK_PEEK+1     ;SPEEK token
001038  2               TK_SADD         = TK_SPEEK+1    ; SADD token
001038  2               TK_LEN          = TK_SADD+1     ; LEN token
001038  2               TK_STRS         = TK_LEN+1      ; STR$ token
001038  2               TK_VAL          = TK_STRS+1     ; VAL token
001038  2               TK_ASC          = TK_VAL+1      ; ASC token
001038  2               TK_UCASES       = TK_ASC+1      ; UCASE$ token
001038  2               TK_LCASES       = TK_UCASES+1   ; LCASE$ token
001038  2               TK_CHRS         = TK_LCASES+1   ; CHR$ token
001038  2               TK_HEXS         = TK_CHRS+1     ; HEX$ token
001038  2               TK_BINS         = TK_HEXS+1     ; BIN$ token
001038  2               TK_BITTST       = TK_BINS+1     ; BITTST token
001038  2               TK_MAX          = TK_BITTST+1   ; MAX token
001038  2               TK_MIN          = TK_MAX+1      ; MIN token
001038  2               TK_PI           = TK_MIN+1      ; PI token
001038  2               TK_IECST        = TK_PI+1       ; IECST token
001038  2               TK_VIDST        = TK_IECST+1    ; VIDST token
001038  2               TK_VPTR         = TK_VIDST+1    ; VARPTR token
001038  2               TK_LEFTS        = TK_VPTR+1     ; LEFT$ token
001038  2               TK_RIGHTS       = TK_LEFTS+1    ; RIGHT$ token
001038  2               TK_MIDS         = TK_RIGHTS+1   ; MID$ token
001038  2               TK_CON          = TK_MIDS+1     ; CON token
001038  2               
001038  2               
001038  2               
001038  2               
001038  2               LAB_CTBL:
001038  2  1C 2C                .WORD   LAB_END-1       ; END
00103A  2  54 2B                .WORD   LAB_FOR-1       ; FOR
00103C  2  AC 32                .WORD   LAB_NEXT-1      ; NEXT
00103E  2  9F 2D                .WORD   LAB_DATA-1      ; DATA
001040  2  6D 1A                .WORD   V_DIR-1         ; DIRECTORY
001042  2  F6 19                .WORD   V_ERR-1         ; DISKSTATUS
001044  2  51 31                .WORD   LAB_INPUT-1     ; INPUT
001046  2  F2 35                .WORD   LAB_DIM-1       ; DIM
001048  2  6A 31                .WORD   LAB_READ-1      ; READ
00104A  2  C4 2E                .WORD   LAB_LET-1       ; LET
00104C  2  94 2E                .WORD   LAB_DEC-1       ; DEC			new command
00104E  2  F9 2C                .WORD   LAB_GOTO-1      ; GOTO
001050  2  B6 2C                .WORD   LAB_RUN-1       ; RUN
001052  2  CD 2D                .WORD   LAB_IF-1        ; IF
001054  2  4E 2C                .WORD   LAB_RESTORE-1   ; RESTORE		modified command
001056  2  DB 2C                .WORD   LAB_GOSUB-1     ; GOSUB
001058  2  8A 2D                .WORD   LAB_RETURN-1    ; RETURN
00105A  2  38 2E                .WORD   LAB_REM-1       ; REM
00105C  2  1A 2C                .WORD   LAB_STOP-1      ; STOP
00105E  2  41 2E                .WORD   LAB_ON-1        ; ON			modified command
001060  2  8C 2C                .WORD   LAB_NULL-1      ; NULL		modified command
001062  2  97 2E                .WORD   LAB_INC-1       ; INC			new command
001064  2  5C 41                .WORD   LAB_WAIT-1      ; WAIT
001066  2  6D 19                .WORD   V_LOAD-1        ; LOAD
001068  2  E4 18                .WORD   V_SAVE-1        ; SAVE
00106A  2  1A 39                .WORD   LAB_DEF-1       ; DEF
00106C  2  AC 40                .WORD   LAB_POKE-1      ; POKE
00106E  2  48 41                .WORD   LAB_CALL-1      ; CALL		new command
001070  2  C0 2C                .WORD   LAB_DO-1        ; DO			new command
001072  2  2B 2D                .WORD   LAB_LOOP-1      ; LOOP		new command
001074  2  2E 30                .WORD   LAB_PRINT-1     ; PRINT
001076  2  92 2C                .WORD   LAB_CONT-1      ; CONT
001078  2  94 2A                .WORD   LAB_LIST-1      ; LIST
00107A  2  91 2A                .WORD   LAB_CLEAR-1     ; CLEAR
00107C  2  41 2A                .WORD   LAB_NEW-1       ; NEW
00107E  2  74 4D                .WORD   LAB_WDTH-1      ; WIDTH		new command
001080  2  E8 2F                .WORD   LAB_GET-1       ; GET			new command
001082  2  D0 40                .WORD   LAB_SWAP-1      ; SWAP		new command
001084  2  0D 4B                .WORD   LAB_BITSET-1    ; BITSET		new command
001086  2  21 4B                .WORD   LAB_BITCLR-1    ; BITCLR		new command
001088  2  66 26                .WORD   LAB_MONITOR-1   ; MONITOR		MONITOR command
00108A  2  FA 1B                .WORD   V_OPEN-1        ; OPEN			OPEN command
00108C  2  79 1C                .WORD   V_CLOSE-1       ; CLOSE			CLOSE command
00108E  2  8A 1C                .WORD   V_IECINPUT-1    ; IECINPUT		IECINPUT command
001090  2  A0 1C                .WORD   V_IECOUTPUT-1   ; IECOUTPUT		IECOUTPUT command
001092  2  B6 1C                .WORD   V_PUTN-1        ; PUTN			PUTN command
001094  2  20 1D                .WORD   V_GETN-1        ; GETN			GETN command
001096  2  3E 1B                .WORD   V_DISKCMD-1     ; DISKCMD		DISKCMD COMMAND
001098  2  6D 1D                .WORD   V_SCNCLR-1      ; SCNCLR		SCNCLR COMMAND
00109A  2  7A 1D                .WORD   V_LOCATE-1      ; LOCATE		LOCATE COMMAND
00109C  2  92 1D                .WORD   V_COLOR-1       ; COLOR			COLOR COMMAND
00109E  2  F6 1D                .WORD   V_SPOKE-1       ; SPOKE			SPOKE COMMAND
0010A0  2  1B 1E                .WORD   V_SCREEN-1      ; SCREEN		SCREEN COMMAND
0010A2  2  02 20                .WORD   V_SPRITE-1      ; SPRITE		SPRITE COMMAND
0010A4  2  76 20                .WORD   V_SPRDEF-1      ; SPRDEF		SPRDEF COMMAND
0010A6  2  DF 20                .WORD   V_SPRSIZE-1     ; SPRSIZE		SPRSIZE COMMAND
0010A8  2  0E 21                .WORD   V_PLOT-1        ; PLOT			PLOT COMMAND
0010AA  2  DF 22                .WORD   V_PATTERN-1     ; PATTERN		PATTERN COMMAND
0010AC  2  BD 40                .WORD   LAB_SYS-1       ; SYS			SYS COMMAND
0010AE  2  AB 23                .WORD   V_SOUND-1       ; SOUND			SOUND COMMAND
0010B0  2  02 24                .WORD   V_NOISE-1       ; NOISE			NOISE COMMAND
0010B2  2  41 24                .WORD   V_TONE-1        ; TONE			TONE COMMAND
0010B4  2  CB 23                .WORD   V_VOLUME-1      ; VOLUME		VOLUME COMMAND
0010B6  2  E0 23                .WORD   V_VOICE-1       ; VOICE			VOICE COMMAND
0010B8  2               ; function pre process routine table
0010B8  2               
0010B8  2               LAB_FTPL:
0010B8  2               LAB_FTPM        = LAB_FTPL+$01
0010B8  2  CA 34                .WORD   LAB_PPFN-1      ; SGN(n)	process numeric expression in ()
0010BA  2  CA 34                .WORD   LAB_PPFN-1      ; INT(n)		"
0010BC  2  CA 34                .WORD   LAB_PPFN-1      ; ABS(n)		"
0010BE  2  49 33                .WORD   LAB_EVEZ-1      ; USR(x)	process any expression
0010C0  2  4F 34                .WORD   LAB_1BF7-1      ; FRE(x)		"
0010C2  2  4F 34                .WORD   LAB_1BF7-1      ; POS(x)		"
0010C4  2  CA 34                .WORD   LAB_PPFN-1      ; SQR(n)	process numeric expression in ()
0010C6  2  CA 34                .WORD   LAB_PPFN-1      ; RND(n)		"
0010C8  2  CA 34                .WORD   LAB_PPFN-1      ; LOG(n)		"
0010CA  2  CA 34                .WORD   LAB_PPFN-1      ; EXP(n)		"
0010CC  2  CA 34                .WORD   LAB_PPFN-1      ; COS(n)		"
0010CE  2  CA 34                .WORD   LAB_PPFN-1      ; SIN(n)		"
0010D0  2  CA 34                .WORD   LAB_PPFN-1      ; TAN(n)		"
0010D2  2  CA 34                .WORD   LAB_PPFN-1      ; ATN(n)		"
0010D4  2  CA 34                .WORD   LAB_PPFN-1      ; PEEK(n)		"
0010D6  2  CA 34                .WORD   LAB_PPFN-1      ; SPEEK(N)		"
0010D8  2  00 00                .WORD   $0000           ; SADD()	none
0010DA  2  C4 34                .WORD   LAB_PPFS-1      ; LEN($)	process string expression in ()
0010DC  2  CA 34                .WORD   LAB_PPFN-1      ; STR$(n)	process numeric expression in ()
0010DE  2  C4 34                .WORD   LAB_PPFS-1      ; VAL($)	process string expression in ()
0010E0  2  C4 34                .WORD   LAB_PPFS-1      ; ASC($)		"
0010E2  2  C4 34                .WORD   LAB_PPFS-1      ; UCASE$($)		"
0010E4  2  C4 34                .WORD   LAB_PPFS-1      ; LCASE$($)		"
0010E6  2  CA 34                .WORD   LAB_PPFN-1      ; CHR$(n)	process numeric expression in ()
0010E8  2  F3 34                .WORD   LAB_BHSS-1      ; HEX$(n)		"
0010EA  2  F3 34                .WORD   LAB_BHSS-1      ; BIN$(n)		"
0010EC  2  00 00                .WORD   $0000           ; BITTST()	none
0010EE  2  07 4D                .WORD   LAB_MMPP-1      ; MAX()	process numeric expression
0010F0  2  07 4D                .WORD   LAB_MMPP-1      ; MIN()		"
0010F2  2  D0 34                .WORD   LAB_PPBI-1      ; PI		advance pointer
0010F4  2  19 1D                .WORD   LAB_PIECST-1    ; IECST		"
0010F6  2  D8 20                .WORD   LAB_PVIDST-1    ; VIDST		"
0010F8  2  00 00                .WORD   $0000           ; VARPTR()	none
0010FA  2  D7 34                .WORD   LAB_LRMS-1      ; LEFT$()	process string expression
0010FC  2  D7 34                .WORD   LAB_LRMS-1      ; RIGHT$()		"
0010FE  2  D7 34                .WORD   LAB_LRMS-1      ; MID$()		"
001100  2  CA 34                .WORD   LAB_PPFN-1      ; CON()		"
001102  2               
001102  2               ; action addresses for functions
001102  2               
001102  2               LAB_FTBL:
001102  2               LAB_FTBM        = LAB_FTBL+$01
001102  2  D5 45                .WORD   LAB_SGN-1       ; SGN()
001104  2  C3 46                .WORD   LAB_INT-1       ; INT()
001106  2  F2 45                .WORD   LAB_ABS-1       ; ABS()
001108  2  D8 4A                .WORD   LAB_USR-1       ; USR()
00110A  2  E8 38                .WORD   LAB_FRE-1       ; FRE()
00110C  2  07 39                .WORD   LAB_POS-1       ; POS()
00110E  2  CB 4D                .WORD   LAB_SQR-1       ; SQR()
001110  2  28 4A                .WORD   LAB_RND-1       ; RND()		modified function
001112  2  E9 42                .WORD   LAB_LOG-1       ; LOG()
001114  2  76 49                .WORD   LAB_EXP-1       ; EXP()
001116  2  5C 4A                .WORD   LAB_COS-1       ; COS()
001118  2  63 4A                .WORD   LAB_SIN-1       ; SIN()
00111A  2  AC 4A                .WORD   LAB_TAN-1       ; TAN()
00111C  2  DE 4A                .WORD   LAB_ATN-1       ; ATN()
00111E  2  99 40                .WORD   LAB_PEEK-1      ; PEEK()
001120  2  B9 1D                .WORD   V_SPEEK-1       ; SPEEK()
001122  2  68 3F                .WORD   LAB_SADD-1      ; SADD()		new function
001124  2  AA 3F                .WORD   LAB_LENS-1      ; LEN()
001126  2  59 3A                .WORD   LAB_STRS-1      ; STR$()
001128  2  EE 3F                .WORD   LAB_VAL-1       ; VAL()
00112A  2  B5 3F                .WORD   LAB_ASC-1       ; ASC()
00112C  2  1E 3F                .WORD   LAB_UCASE-1     ; UCASE$()		new function
00112E  2  D2 3E                .WORD   LAB_LCASE-1     ; LCASE$()		new function
001130  2  D6 3D                .WORD   LAB_CHRS-1      ; CHR$()
001132  2  DA 4B                .WORD   LAB_HEXS-1      ; HEX$()		new function
001134  2  62 4B                .WORD   LAB_BINS-1      ; BIN$()		new function
001136  2  37 4B                .WORD   LAB_BTST-1      ; BITTST()		new function
001138  2  0D 4D                .WORD   LAB_MAX-1       ; MAX()		new function
00113A  2  1D 4D                .WORD   LAB_MIN-1       ; MIN()		new function
00113C  2  69 4E                .WORD   LAB_PI-1        ; PI			new function
00113E  2  0E 1D                .WORD   LAB_IECST-1     ; IECST		new function
001140  2  BF 20                .WORD   LAB_VIDST-1     ; VIDST		new function
001142  2  58 4E                .WORD   LAB_VARPTR-1    ; VARPTR()		new function
001144  2  FC 3D                .WORD   LAB_LEFT-1      ; LEFT$()
001146  2  1B 3E                .WORD   LAB_RIGHT-1     ; RIGHT$()
001148  2  74 3E                .WORD   LAB_MIDS-1      ; MID$()
00114A  2  6F 24                .WORD   LAB_CON-1       ; CON()
00114C  2               
00114C  2               ; hierarchy and action addresses for operator
00114C  2               
00114C  2               LAB_OPPT:
00114C  2  79                   .BYTE   $79             ; +
00114D  2  A9 41                .WORD   LAB_ADD-1
00114F  2  79                   .BYTE   $79             ; -
001150  2  8E 41                .WORD   LAB_SUBTRACT-1
001152  2  7B                   .BYTE   $7B             ; *
001153  2  2A 43                .WORD   LAB_MULTIPLY-1
001155  2  7B                   .BYTE   $7B             ; /
001156  2  42 44                .WORD   LAB_DIVIDE-1
001158  2  7F                   .BYTE   $7F             ; ^
001159  2  32 49                .WORD   LAB_POWER-1
00115B  2  50                   .BYTE   $50             ; AND
00115C  2  3E 35                .WORD   LAB_AND-1
00115E  2  46                   .BYTE   $46             ; EOR			new operator
00115F  2  24 35                .WORD   LAB_EOR-1
001161  2  46                   .BYTE   $46             ; OR
001162  2  31 35                .WORD   LAB_OR-1
001164  2  56                   .BYTE   $56             ; >>			new operator
001165  2  15 36                .WORD   LAB_RSHIFT-1
001167  2  56                   .BYTE   $56             ; <<			new operator
001168  2  FD 35                .WORD   LAB_LSHIFT-1
00116A  2  7D                   .BYTE   $7D             ; >
00116B  2  6B 49                .WORD   LAB_GTHAN-1
00116D  2  5A                   .BYTE   $5A             ; =
00116E  2  7C 34                .WORD   LAB_EQUAL-1
001170  2  64                   .BYTE   $64             ; <
001171  2  5F 35                .WORD   LAB_LTHAN-1
001173  2               
001173  2               ; keywords start with ..
001173  2               ; this is the first character table and must be in alphabetic order
001173  2               
001173  2               TAB_1STC:
001173  2  2A                   .BYTE   "*"
001174  2  2B                   .BYTE   "+"
001175  2  2D                   .BYTE   "-"
001176  2  2F                   .BYTE   "/"
001177  2  3C                   .BYTE   "<"
001178  2  3D                   .BYTE   "="
001179  2  3E                   .BYTE   ">"
00117A  2  3F                   .BYTE   "?"
00117B  2  41                   .BYTE   "A"
00117C  2  42                   .BYTE   "B"
00117D  2  43                   .BYTE   "C"
00117E  2  44                   .BYTE   "D"
00117F  2  45                   .BYTE   "E"
001180  2  46                   .BYTE   "F"
001181  2  47                   .BYTE   "G"
001182  2  48                   .BYTE   "H"
001183  2  49                   .BYTE   "I"
001184  2  4B                   .BYTE   "K"
001185  2  4C                   .BYTE   "L"
001186  2  4D                   .BYTE   "M"
001187  2  4E                   .BYTE   "N"
001188  2  4F                   .BYTE   "O"
001189  2  50                   .BYTE   "P"
00118A  2  52                   .BYTE   "R"
00118B  2  53                   .BYTE   "S"
00118C  2  54                   .BYTE   "T"
00118D  2  55                   .BYTE   "U"
00118E  2  56                   .BYTE   "V"
00118F  2  57                   .BYTE   "W"
001190  2  5E                   .BYTE   "^"
001191  2  00                   .BYTE   $00             ; table terminator
001192  2               
001192  2               ; pointers to keyword tables
001192  2               
001192  2               TAB_CHRT:
001192  2  CE 11                .WORD   TAB_STAR        ; table for "*"
001194  2  D0 11                .WORD   TAB_PLUS        ; table for "+"
001196  2  D2 11                .WORD   TAB_MNUS        ; table for "-"
001198  2  D4 11                .WORD   TAB_SLAS        ; table for "/"
00119A  2  D6 11                .WORD   TAB_LESS        ; table for "<"
00119C  2  DA 11                .WORD   TAB_EQUL        ; table for "="
00119E  2  DC 11                .WORD   TAB_MORE        ; table for ">"
0011A0  2  E0 11                .WORD   TAB_QEST        ; table for "?"
0011A2  2  E2 11                .WORD   TAB_ASCA        ; table for "A"
0011A4  2  F2 11                .WORD   TAB_ASCB        ; table for "B"
0011A6  2  0B 12                .WORD   TAB_ASCC        ; table for "C"
0011A8  2  30 12                .WORD   TAB_ASCD        ; table for "D"
0011AA  2  5A 12                .WORD   TAB_ASCE        ; table for "E"
0011AC  2  69 12                .WORD   TAB_ASCF        ; table for "F"
0011AE  2  73 12                .WORD   TAB_ASCG        ; table for "G"
0011B0  2  84 12                .WORD   TAB_ASCH        ; table for "H"
0011B2  2  8A 12                .WORD   TAB_ASCI        ; table for "I"
0011B4  2  AF 12                .WORD   TAB_ASCK        ; table for "K"
0011B6  2  AF 12                .WORD   TAB_ASCL        ; table for "L"
0011B8  2  DA 12                .WORD   TAB_ASCM        ; table for "M"
0011BA  2  EF 12                .WORD   TAB_ASCN        ; table for "N"
0011BC  2  03 13                .WORD   TAB_ASCO        ; table for "O"
0011BE  2  0F 13                .WORD   TAB_ASCP        ; table for "P"
0011C0  2  33 13                .WORD   TAB_ASCR        ; table for "R"
0011C2  2  56 13                .WORD   TAB_ASCS        ; table for "S"
0011C4  2  B3 13                .WORD   TAB_ASCT        ; table for "T"
0011C6  2  C6 13                .WORD   TAB_ASCU        ; table for "U"
0011C8  2  D7 13                .WORD   TAB_ASCV        ; table for "V"
0011CA  2  F3 13                .WORD   TAB_ASCW        ; table for "W"
0011CC  2  02 14                .WORD   TAB_POWR        ; table for "^"
0011CE  2               
0011CE  2               ; tables for each start character, note if a longer keyword with the same start
0011CE  2               ; letters as a shorter one exists then it must come first, else the list is in
0011CE  2               ; alphabetical order as follows ..
0011CE  2               
0011CE  2               ; [keyword,token
0011CE  2               ; [keyword,token]]
0011CE  2               ; end marker (#$00)
0011CE  2               
0011CE  2               TAB_STAR:
0011CE  2  CD 00                .BYTE   TK_MUL,$00      ; *
0011D0  2               TAB_PLUS:
0011D0  2  CB 00                .BYTE   TK_PLUS,$00     ; +
0011D2  2               TAB_MNUS:
0011D2  2  CC 00                .BYTE   TK_MINUS,$00    ; -
0011D4  2               TAB_SLAS:
0011D4  2  CE 00                .BYTE   TK_DIV,$00      ; /
0011D6  2               TAB_LESS:
0011D6  2               LBB_LSHIFT:
0011D6  2  3C D4                .BYTE   "<",TK_LSHIFT   ; <<	note - "<<" must come before "<"
0011D8  2  D7                   .BYTE   TK_LT           ; <
0011D9  2  00                   .BYTE   $00
0011DA  2               TAB_EQUL:
0011DA  2  D6 00                .BYTE   TK_EQUAL,$00    ; =
0011DC  2               TAB_MORE:
0011DC  2               LBB_RSHIFT:
0011DC  2  3E D3                .BYTE   ">",TK_RSHIFT   ; >>	note - ">>" must come before ">"
0011DE  2  D5                   .BYTE   TK_GT           ; >
0011DF  2  00                   .BYTE   $00
0011E0  2               TAB_QEST:
0011E0  2  9E 00                .BYTE   TK_PRINT,$00    ; ?
0011E2  2               TAB_ASCA:
0011E2  2               LBB_ABS:
0011E2  2  42 53 28 DA          .BYTE   "BS(",TK_ABS    ; ABS(
0011E6  2               LBB_AND:
0011E6  2  4E 44 D0             .BYTE   "ND",TK_AND     ; AND
0011E9  2               LBB_ASC:
0011E9  2  53 43 28 EC          .BYTE   "SC(",TK_ASC    ; ASC(
0011ED  2               LBB_ATN:
0011ED  2  54 4E 28 E5          .BYTE   "TN(",TK_ATN    ; ATN(
0011F1  2  00                   .BYTE   $00
0011F2  2               TAB_ASCB:
0011F2  2               LBB_BINS:
0011F2  2  49 4E 24 28          .BYTE   "IN$(",TK_BINS  ; BIN$(
0011F6  2  F1           
0011F7  2               LBB_BITCLR:
0011F7  2  49 54 43 4C          .BYTE   "ITCLR",TK_BITCLR; BITCLR
0011FB  2  52 A7        
0011FD  2               LBB_BITSET:
0011FD  2  49 54 53 45          .BYTE   "ITSET",TK_BITSET; BITSET
001201  2  54 A6        
001203  2               LBB_BITTST:
001203  2  49 54 54 53          .BYTE   "ITTST(",TK_BITTST
001207  2  54 28 F2     
00120A  2               ; BITTST(
00120A  2  00                   .BYTE   $00
00120B  2               TAB_ASCC:
00120B  2               LBB_CALL:
00120B  2  41 4C 4C 9B          .BYTE   "ALL",TK_CALL   ; CALL
00120F  2               LBB_CHRS:
00120F  2  48 52 24 28          .BYTE   "HR$(",TK_CHRS  ; CHR$(
001213  2  EF           
001214  2               LBB_CLEAR:
001214  2  4C 45 41 52          .BYTE   "LEAR",TK_CLEAR ; CLEAR
001218  2  A1           
001219  2               LBB_CLOSE:
001219  2  4C 4F 53 45          .BYTE   "LOSE",TK_CLOSE ; CLOSE
00121D  2  AA           
00121E  2               LBB_COLOR:
00121E  2  4F 4C 4F 52          .BYTE   "OLOR",TK_COLOR ; COLOR
001222  2  B2           
001223  2               LBB_CON:
001223  2  4F 4E 28 FC          .BYTE   "ON(",TK_CON    ;CON
001227  2               LBB_CONT:
001227  2  4F 4E 54 9F          .BYTE   "ONT",TK_CONT   ; CONT
00122B  2               LBB_COS:
00122B  2  4F 53 28 E2          .BYTE   "OS(",TK_COS    ; COS(
00122F  2  00                   .BYTE   $00
001230  2               TAB_ASCD:
001230  2               LBB_DATA:
001230  2  41 54 41 83          .BYTE   "ATA",TK_DATA   ; DATA
001234  2               LBB_DEC:
001234  2  45 43 8A             .BYTE   "EC",TK_DEC     ; DEC
001237  2               LBB_DEF:
001237  2  45 46 99             .BYTE   "EF",TK_DEF     ; DEF
00123A  2               LBB_DIM:
00123A  2  49 4D 87             .BYTE   "IM",TK_DIM     ; DIM
00123D  2               LBB_DIRECTORY:
00123D  2  49 52 45 43          .BYTE   "IRECTORY",TK_DIRECTORY; DIRECTORY
001241  2  54 4F 52 59  
001245  2  84           
001246  2               LBB_DISKCMD:
001246  2  49 53 4B 43          .BYTE   "ISKCMD",TK_DISKCMD; DISKCMD
00124A  2  4D 44 AF     
00124D  2               LBB_DISKSTATUS:
00124D  2  49 53 4B 53          .BYTE   "ISKSTATUS",TK_DISKSTATUS; DISKSTATUS
001251  2  54 41 54 55  
001255  2  53 85        
001257  2               LBB_DO:
001257  2  4F 9C                .BYTE   "O",TK_DO       ; DO
001259  2  00                   .BYTE   $00
00125A  2               TAB_ASCE:
00125A  2               LBB_ELSE:
00125A  2  4C 53 45 C1          .BYTE   "LSE",TK_ELSE   ; ELSE
00125E  2               LBB_END:
00125E  2  4E 44 80             .BYTE   "ND",TK_END     ; END
001261  2               LBB_EOR:
001261  2  4F 52 D1             .BYTE   "OR",TK_EOR     ; EOR
001264  2               LBB_EXP:
001264  2  58 50 28 E1          .BYTE   "XP(",TK_EXP    ; EXP(
001268  2  00                   .BYTE   $00
001269  2               TAB_ASCF:
001269  2               LBB_FN:
001269  2  4E C3                .BYTE   "N",TK_FN       ; FN
00126B  2               LBB_FOR:
00126B  2  4F 52 81             .BYTE   "OR",TK_FOR     ; FOR
00126E  2               LBB_FRE:
00126E  2  52 45 28 DC          .BYTE   "RE(",TK_FRE    ; FRE(
001272  2  00                   .BYTE   $00
001273  2               TAB_ASCG:
001273  2               LBB_GETN:
001273  2  45 54 23 AE          .BYTE   "ET#",TK_GETN   ; GETN
001277  2               LBB_GET:
001277  2  45 54 A4             .BYTE   "ET",TK_GET     ; GET
00127A  2               LBB_GOSUB:
00127A  2  4F 53 55 42          .BYTE   "OSUB",TK_GOSUB ; GOSUB
00127E  2  8F           
00127F  2               LBB_GOTO:
00127F  2  4F 54 4F 8B          .BYTE   "OTO",TK_GOTO   ; GOTO
001283  2  00                   .BYTE   $00
001284  2               TAB_ASCH:
001284  2               LBB_HEXS:
001284  2  45 58 24 28          .BYTE   "EX$(",TK_HEXS  ; HEX$(
001288  2  F0           
001289  2  00                   .BYTE   $00
00128A  2               TAB_ASCI:
00128A  2               LBB_IECINPUT:
00128A  2  45 43 49 4E          .BYTE   "ECINPUT",TK_IECINPUT; IECINPUT
00128E  2  50 55 54 AB  
001292  2               LBB_IECOUTPUT:
001292  2  45 43 4F 55          .BYTE   "ECOUTPUT",TK_IECOUTPUT; IECOUTPUT
001296  2  54 50 55 54  
00129A  2  AC           
00129B  2               LBB_IECST:
00129B  2  45 43 53 54          .BYTE   "ECST",TK_IECST ; IECST
00129F  2  F6           
0012A0  2               LBB_IF:
0012A0  2  46 8D                .BYTE   "F",TK_IF       ; IF
0012A2  2               LBB_INC:
0012A2  2  4E 43 95             .BYTE   "NC",TK_INC     ; INC
0012A5  2               LBB_INPUT:
0012A5  2  4E 50 55 54          .BYTE   "NPUT",TK_INPUT ; INPUT
0012A9  2  86           
0012AA  2               LBB_INT:
0012AA  2  4E 54 28 D9          .BYTE   "NT(",TK_INT    ; INT(
0012AE  2  00                   .BYTE   $00
0012AF  2               TAB_ASCK:
0012AF  2               TAB_ASCL:
0012AF  2               LBB_LCASES:
0012AF  2  43 41 53 45          .BYTE   "CASE$(",TK_LCASES
0012B3  2  24 28 EE     
0012B6  2               ; LCASE$(
0012B6  2               LBB_LEFTS:
0012B6  2  45 46 54 24          .BYTE   "EFT$(",TK_LEFTS; LEFT$(
0012BA  2  28 F9        
0012BC  2               LBB_LEN:
0012BC  2  45 4E 28 E9          .BYTE   "EN(",TK_LEN    ; LEN(
0012C0  2               LBB_LET:
0012C0  2  45 54 89             .BYTE   "ET",TK_LET     ; LET
0012C3  2               LBB_LIST:
0012C3  2  49 53 54 A0          .BYTE   "IST",TK_LIST   ; LIST
0012C7  2               LBB_LOAD:
0012C7  2  4F 41 44 97          .BYTE   "OAD",TK_LOAD   ; LOAD
0012CB  2               LBB_LOCATE:
0012CB  2  4F 43 41 54          .BYTE   "OCATE",TK_LOCATE; LOCATE
0012CF  2  45 B1        
0012D1  2               LBB_LOG:
0012D1  2  4F 47 28 E0          .BYTE   "OG(",TK_LOG    ; LOG(
0012D5  2               LBB_LOOP:
0012D5  2  4F 4F 50 9D          .BYTE   "OOP",TK_LOOP   ; LOOP
0012D9  2  00                   .BYTE   $00
0012DA  2               TAB_ASCM:
0012DA  2               LBB_MAX:
0012DA  2  41 58 28 F3          .BYTE   "AX(",TK_MAX    ; MAX(
0012DE  2               LBB_MIDS:
0012DE  2  49 44 24 28          .BYTE   "ID$(",TK_MIDS  ; MID$(
0012E2  2  FB           
0012E3  2               LBB_MIN:
0012E3  2  49 4E 28 F4          .BYTE   "IN(",TK_MIN    ; MIN(
0012E7  2               LBB_MONITOR:
0012E7  2  4F 4E 49 54          .BYTE   "ONITOR",TK_MONITOR; MONITOR(
0012EB  2  4F 52 A8     
0012EE  2  00                   .BYTE   $00
0012EF  2               TAB_ASCN:
0012EF  2               LBB_NEW:
0012EF  2  45 57 A2             .BYTE   "EW",TK_NEW     ; NEW
0012F2  2               LBB_NEXT:
0012F2  2  45 58 54 82          .BYTE   "EXT",TK_NEXT   ; NEXT
0012F6  2               LBB_NOISE:
0012F6  2  4F 49 53 45          .BYTE   "OISE",TK_NOISE ; NOISE
0012FA  2  BC           
0012FB  2               LBB_NOT:
0012FB  2  4F 54 C6             .BYTE   "OT",TK_NOT     ; NOT
0012FE  2               LBB_NULL:
0012FE  2  55 4C 4C 94          .BYTE   "ULL",TK_NULL   ; NULL
001302  2  00                   .BYTE   $00
001303  2               TAB_ASCO:
001303  2               LBB_OFF:
001303  2  46 46 CA             .BYTE   "FF",TK_OFF     ; OFF
001306  2               LBB_ON:
001306  2  4E 93                .BYTE   "N",TK_ON       ; ON
001308  2               LBB_OPEN:
001308  2  50 45 4E A9          .BYTE   "PEN",TK_OPEN   ; OPEN
00130C  2               LBB_OR:
00130C  2  52 D2                .BYTE   "R",TK_OR       ; OR
00130E  2  00                   .BYTE   $00
00130F  2               TAB_ASCP:
00130F  2               LBB_PATTERN:
00130F  2  41 54 54 45          .BYTE   "ATTERN",TK_PATTERN; PATTERN
001313  2  52 4E B9     
001316  2               LBB_PEEK:
001316  2  45 45 4B 28          .BYTE   "EEK(",TK_PEEK  ; PEEK(
00131A  2  E6           
00131B  2               LBB_PI:
00131B  2  49 F5                .BYTE   "I",TK_PI       ; PI
00131D  2               LBB_PLOT:
00131D  2  4C 4F 54 B8          .BYTE   "LOT",TK_PLOT   ; PLOT
001321  2               LBB_POKE:
001321  2  4F 4B 45 9A          .BYTE   "OKE",TK_POKE   ; POKE
001325  2               LBB_POS:
001325  2  4F 53 28 DD          .BYTE   "OS(",TK_POS    ; POS(
001329  2               LBB_PRINT:
001329  2  52 49 4E 54          .BYTE   "RINT",TK_PRINT ; PRINT
00132D  2  9E           
00132E  2               LBB_PUTN:
00132E  2  55 54 23 AD          .BYTE   "UT#",TK_PUTN   ; PUTN
001332  2  00                   .BYTE   $00
001333  2               TAB_ASCR:
001333  2               LBB_READ:
001333  2  45 41 44 88          .BYTE   "EAD",TK_READ   ; READ
001337  2               LBB_REM:
001337  2  45 4D 91             .BYTE   "EM",TK_REM     ; REM
00133A  2               LBB_RESTORE:
00133A  2  45 53 54 4F          .BYTE   "ESTORE",TK_RESTORE
00133E  2  52 45 8E     
001341  2               ; RESTORE
001341  2               LBB_RETURN:
001341  2  45 54 55 52          .BYTE   "ETURN",TK_RETURN; RETURN
001345  2  4E 90        
001347  2               LBB_RIGHTS:
001347  2  49 47 48 54          .BYTE   "IGHT$(",TK_RIGHTS
00134B  2  24 28 FA     
00134E  2               ; RIGHT$(
00134E  2               LBB_RND:
00134E  2  4E 44 28 DF          .BYTE   "ND(",TK_RND    ; RND(
001352  2               LBB_RUN:
001352  2  55 4E 8C             .BYTE   "UN",TK_RUN     ; RUN
001355  2  00                   .BYTE   $00
001356  2               TAB_ASCS:
001356  2               LBB_SADD:
001356  2  41 44 44 28          .BYTE   "ADD(",TK_SADD  ; SADD(
00135A  2  E8           
00135B  2               LBB_SAVE:
00135B  2  41 56 45 98          .BYTE   "AVE",TK_SAVE   ; SAVE
00135F  2               LBB_SCNCLR:
00135F  2  43 4E 43 4C          .BYTE   "CNCLR",TK_SCNCLR; SCNCLR
001363  2  52 B0        
001365  2               LBB_SCREEN:
001365  2  43 52 45 45          .BYTE   "CREEN",TK_SCREEN; SCREEN
001369  2  4E B4        
00136B  2               LBB_SGN:
00136B  2  47 4E 28 D8          .BYTE   "GN(",TK_SGN    ; SGN(
00136F  2               LBB_SIN:
00136F  2  49 4E 28 E3          .BYTE   "IN(",TK_SIN    ; SIN(
001373  2               LBB_SOUND:
001373  2  4F 55 4E 44          .BYTE   "OUND",TK_SOUND ; SOUND
001377  2  BB           
001378  2               LBB_SPC:
001378  2  50 43 28 C4          .BYTE   "PC(",TK_SPC    ; SPC(
00137C  2               LBB_SPEEK:
00137C  2  50 45 45 4B          .BYTE   "PEEK(",TK_SPEEK; SPEEK
001380  2  28 E7        
001382  2               LBB_SPOKE:
001382  2  50 4F 4B 45          .BYTE   "POKE",TK_SPOKE ; SPOKE
001386  2  B3           
001387  2               LBB_SPRDEF:
001387  2  50 52 44 45          .BYTE   "PRDEF",TK_SPRDEF; SPRDEF
00138B  2  46 B6        
00138D  2               LBB_SPRITE:
00138D  2  50 52 49 54          .BYTE   "PRITE",TK_SPRITE; SPRITE
001391  2  45 B5        
001393  2               LBB_SPRSIZE:
001393  2  50 52 53 49          .BYTE   "PRSIZE",TK_SPRSIZE; SPRSIZE
001397  2  5A 45 B7     
00139A  2               LBB_SQR:
00139A  2  51 52 28 DE          .BYTE   "QR(",TK_SQR    ; SQR(
00139E  2               LBB_STEP:
00139E  2  54 45 50 C7          .BYTE   "TEP",TK_STEP   ; STEP
0013A2  2               LBB_STOP:
0013A2  2  54 4F 50 92          .BYTE   "TOP",TK_STOP   ; STOP
0013A6  2               LBB_STRS:
0013A6  2  54 52 24 28          .BYTE   "TR$(",TK_STRS  ; STR$(
0013AA  2  EA           
0013AB  2               LBB_SWAP:
0013AB  2  57 41 50 A5          .BYTE   "WAP",TK_SWAP   ; SWAP
0013AF  2               LBB_SYS:
0013AF  2  59 53 BA             .BYTE   "YS",TK_SYS     ; SYS
0013B2  2  00                   .BYTE   $00
0013B3  2               TAB_ASCT:
0013B3  2               LBB_TAB:
0013B3  2  41 42 28 C0          .BYTE   "AB(",TK_TAB    ; TAB(
0013B7  2               LBB_TAN:
0013B7  2  41 4E 28 E4          .BYTE   "AN(",TK_TAN    ; TAN(
0013BB  2               LBB_THEN:
0013BB  2  48 45 4E C5          .BYTE   "HEN",TK_THEN   ; THEN
0013BF  2               LBB_TONE:
0013BF  2  4F 4E 45 BD          .BYTE   "ONE",TK_TONE   ; TONE
0013C3  2               LBB_TO:
0013C3  2  4F C2                .BYTE   "O",TK_TO       ; TO
0013C5  2  00                   .BYTE   $00
0013C6  2               TAB_ASCU:
0013C6  2               LBB_UCASES:
0013C6  2  43 41 53 45          .BYTE   "CASE$(",TK_UCASES
0013CA  2  24 28 ED     
0013CD  2               ; UCASE$(
0013CD  2               LBB_UNTIL:
0013CD  2  4E 54 49 4C          .BYTE   "NTIL",TK_UNTIL ; UNTIL
0013D1  2  C8           
0013D2  2               LBB_USR:
0013D2  2  53 52 28 DB          .BYTE   "SR(",TK_USR    ; USR(
0013D6  2  00                   .BYTE   $00
0013D7  2               TAB_ASCV:
0013D7  2               LBB_VAL:
0013D7  2  41 4C 28 EB          .BYTE   "AL(",TK_VAL    ; VAL(
0013DB  2               LBB_VPTR:
0013DB  2  41 52 50 54          .BYTE   "ARPTR(",TK_VPTR; VARPTR(
0013DF  2  52 28 F8     
0013E2  2               LBB_VIDST:
0013E2  2  49 44 53 54          .BYTE   "IDST",TK_VIDST ; VIDST
0013E6  2  F7           
0013E7  2               LBB_VOICE:
0013E7  2  4F 49 43 45          .BYTE   "OICE",TK_VOICE ; VOICE
0013EB  2  BF           
0013EC  2               LBB_VOLUME:
0013EC  2  4F 4C 55 4D          .BYTE   "OLUME",TK_VOLUME; VOLUME
0013F0  2  45 BE        
0013F2  2               
0013F2  2  00                   .BYTE   $00
0013F3  2               TAB_ASCW:
0013F3  2               LBB_WAIT:
0013F3  2  41 49 54 96          .BYTE   "AIT",TK_WAIT   ; WAIT
0013F7  2               LBB_WHILE:
0013F7  2  48 49 4C 45          .BYTE   "HILE",TK_WHILE ; WHILE
0013FB  2  C9           
0013FC  2               LBB_WIDTH:
0013FC  2  49 44 54 48          .BYTE   "IDTH",TK_WIDTH ; WIDTH
001400  2  A3           
001401  2  00                   .BYTE   $00
001402  2               TAB_POWR:
001402  2  CF 00                .BYTE   TK_POWER,$00    ; ^
001404  2               
001404  2               ; new decode table for LIST
001404  2               ; Table is ..
001404  2               ; byte - keyword length, keyword first character
001404  2               ; word - pointer to rest of keyword from dictionary
001404  2               
001404  2               ; note if length is 1 then the pointer is ignored
001404  2               
001404  2               LAB_KEYT:
001404  2  03 45                .BYTE   3,'E'
001406  2  5E 12                .WORD   LBB_END         ; END
001408  2  03 46                .BYTE   3,'F'
00140A  2  6B 12                .WORD   LBB_FOR         ; FOR
00140C  2  04 4E                .BYTE   4,'N'
00140E  2  F2 12                .WORD   LBB_NEXT        ; NEXT
001410  2  04 44                .BYTE   4,'D'
001412  2  30 12                .WORD   LBB_DATA        ; DATA
001414  2  09 44                .BYTE   9,'D'
001416  2  3D 12                .WORD   LBB_DIRECTORY   ; DIRECTORY
001418  2  0A 44                .BYTE   10,'D'
00141A  2  4D 12                .WORD   LBB_DISKSTATUS  ; DISKSTATUS
00141C  2  05 49                .BYTE   5,'I'
00141E  2  A5 12                .WORD   LBB_INPUT       ; INPUT
001420  2  03 44                .BYTE   3,'D'
001422  2  3A 12                .WORD   LBB_DIM         ; DIM
001424  2  04 52                .BYTE   4,'R'
001426  2  33 13                .WORD   LBB_READ        ; READ
001428  2  03 4C                .BYTE   3,'L'
00142A  2  C0 12                .WORD   LBB_LET         ; LET
00142C  2  03 44                .BYTE   3,'D'
00142E  2  34 12                .WORD   LBB_DEC         ; DEC
001430  2  04 47                .BYTE   4,'G'
001432  2  7F 12                .WORD   LBB_GOTO        ; GOTO
001434  2  03 52                .BYTE   3,'R'
001436  2  52 13                .WORD   LBB_RUN         ; RUN
001438  2  02 49                .BYTE   2,'I'
00143A  2  A0 12                .WORD   LBB_IF          ; IF
00143C  2  07 52                .BYTE   7,'R'
00143E  2  3A 13                .WORD   LBB_RESTORE     ; RESTORE
001440  2  05 47                .BYTE   5,'G'
001442  2  7A 12                .WORD   LBB_GOSUB       ; GOSUB
001444  2  06 52                .BYTE   6,'R'
001446  2  41 13                .WORD   LBB_RETURN      ; RETURN
001448  2  03 52                .BYTE   3,'R'
00144A  2  37 13                .WORD   LBB_REM         ; REM
00144C  2  04 53                .BYTE   4,'S'
00144E  2  A2 13                .WORD   LBB_STOP        ; STOP
001450  2  02 4F                .BYTE   2,'O'
001452  2  06 13                .WORD   LBB_ON          ; ON
001454  2  04 4E                .BYTE   4,'N'
001456  2  FE 12                .WORD   LBB_NULL        ; NULL
001458  2  03 49                .BYTE   3,'I'
00145A  2  A2 12                .WORD   LBB_INC         ; INC
00145C  2  04 57                .BYTE   4,'W'
00145E  2  F3 13                .WORD   LBB_WAIT        ; WAIT
001460  2  04 4C                .BYTE   4,'L'
001462  2  C7 12                .WORD   LBB_LOAD        ; LOAD
001464  2  04 53                .BYTE   4,'S'
001466  2  5B 13                .WORD   LBB_SAVE        ; SAVE
001468  2  03 44                .BYTE   3,'D'
00146A  2  37 12                .WORD   LBB_DEF         ; DEF
00146C  2  04 50                .BYTE   4,'P'
00146E  2  21 13                .WORD   LBB_POKE        ; POKE
001470  2  04 43                .BYTE   4,'C'
001472  2  0B 12                .WORD   LBB_CALL        ; CALL
001474  2  02 44                .BYTE   2,'D'
001476  2  57 12                .WORD   LBB_DO          ; DO
001478  2  04 4C                .BYTE   4,'L'
00147A  2  D5 12                .WORD   LBB_LOOP        ; LOOP
00147C  2  05 50                .BYTE   5,'P'
00147E  2  29 13                .WORD   LBB_PRINT       ; PRINT
001480  2  04 43                .BYTE   4,'C'
001482  2  27 12                .WORD   LBB_CONT        ; CONT
001484  2  04 4C                .BYTE   4,'L'
001486  2  C3 12                .WORD   LBB_LIST        ; LIST
001488  2  05 43                .BYTE   5,'C'
00148A  2  14 12                .WORD   LBB_CLEAR       ; CLEAR
00148C  2  03 4E                .BYTE   3,'N'
00148E  2  EF 12                .WORD   LBB_NEW         ; NEW
001490  2  05 57                .BYTE   5,'W'
001492  2  FC 13                .WORD   LBB_WIDTH       ; WIDTH
001494  2  03 47                .BYTE   3,'G'
001496  2  77 12                .WORD   LBB_GET         ; GET
001498  2  04 53                .BYTE   4,'S'
00149A  2  AB 13                .WORD   LBB_SWAP        ; SWAP
00149C  2  06 42                .BYTE   6,'B'
00149E  2  FD 11                .WORD   LBB_BITSET      ; BITSET
0014A0  2  06 42                .BYTE   6,'B'
0014A2  2  F7 11                .WORD   LBB_BITCLR      ; BITCLR
0014A4  2  07 4D                .BYTE   7,'M'
0014A6  2  E7 12                .WORD   LBB_MONITOR     ; MONITOR
0014A8  2  04 4F                .BYTE   4,'O'
0014AA  2  08 13                .WORD   LBB_OPEN        ; OPEN
0014AC  2  05 43                .BYTE   5,'C'
0014AE  2  19 12                .WORD   LBB_CLOSE       ; CLOSE
0014B0  2  08 49                .BYTE   8,'I'
0014B2  2  8A 12                .WORD   LBB_IECINPUT    ; IECINPUT
0014B4  2  09 49                .BYTE   9,'I'
0014B6  2  92 12                .WORD   LBB_IECOUTPUT   ; IECOUTPUT
0014B8  2  04 50                .BYTE   4,'P'
0014BA  2  2E 13                .WORD   LBB_PUTN        ; PUTN
0014BC  2  04 47                .BYTE   4,'G'
0014BE  2  73 12                .WORD   LBB_GETN        ; GETN
0014C0  2  07 44                .BYTE   7,'D'
0014C2  2  46 12                .WORD   LBB_DISKCMD     ; DISKCMD
0014C4  2  06 53                .BYTE   6,'S'
0014C6  2  5F 13                .WORD   LBB_SCNCLR      ; SCNCLR
0014C8  2  06 4C                .BYTE   6,'L'
0014CA  2  CB 12                .WORD   LBB_LOCATE      ; LOCATE
0014CC  2  05 43                .BYTE   5,'C'
0014CE  2  1E 12                .WORD   LBB_COLOR       ; COLOR
0014D0  2  05 53                .BYTE   5,'S'
0014D2  2  82 13                .WORD   LBB_SPOKE       ; SPOKE
0014D4  2  06 53                .BYTE   6,'S'
0014D6  2  65 13                .WORD   LBB_SCREEN      ; SCREEN
0014D8  2  06 53                .BYTE   6,'S'
0014DA  2  8D 13                .WORD   LBB_SPRITE      ; SPRITE
0014DC  2  06 53                .BYTE   6,'S'
0014DE  2  87 13                .WORD   LBB_SPRDEF      ; SPRDEF
0014E0  2  07 53                .BYTE   7,'S'
0014E2  2  93 13                .WORD   LBB_SPRSIZE     ; SPRSIZE
0014E4  2  04 50                .BYTE   4,'P'
0014E6  2  1D 13                .WORD   LBB_PLOT        ; PLOT
0014E8  2  07 50                .BYTE   7,'P'
0014EA  2  0F 13                .WORD   LBB_PATTERN     ; PATTERN
0014EC  2  03 53                .BYTE   3,'S'
0014EE  2  AF 13                .WORD   LBB_SYS         ; SYS
0014F0  2  05 53                .BYTE   5,'S'
0014F2  2  73 13                .WORD   LBB_SOUND       ; SOUND
0014F4  2  05 4E                .BYTE   5,'N'
0014F6  2  F6 12                .WORD   LBB_NOISE       ; NOISE
0014F8  2  04 54                .BYTE   4,'T'
0014FA  2  BF 13                .WORD   LBB_TONE        ; TONE
0014FC  2  06 56                .BYTE   6,'V'
0014FE  2  EC 13                .WORD   LBB_VOLUME      ; VOLUME
001500  2  05 56                .BYTE   5,'V'
001502  2  E7 13                .WORD   LBB_VOICE       ; VOICE
001504  2               
001504  2               ; secondary commands (can't start a statement)
001504  2               
001504  2  04 54                .BYTE   4,'T'
001506  2  B3 13                .WORD   LBB_TAB         ; TAB
001508  2  04 45                .BYTE   4,'E'
00150A  2  5A 12                .WORD   LBB_ELSE        ; ELSE
00150C  2  02 54                .BYTE   2,'T'
00150E  2  C3 13                .WORD   LBB_TO          ; TO
001510  2  02 46                .BYTE   2,'F'
001512  2  69 12                .WORD   LBB_FN          ; FN
001514  2  04 53                .BYTE   4,'S'
001516  2  78 13                .WORD   LBB_SPC         ; SPC
001518  2  04 54                .BYTE   4,'T'
00151A  2  BB 13                .WORD   LBB_THEN        ; THEN
00151C  2  03 4E                .BYTE   3,'N'
00151E  2  FB 12                .WORD   LBB_NOT         ; NOT
001520  2  04 53                .BYTE   4,'S'
001522  2  9E 13                .WORD   LBB_STEP        ; STEP
001524  2  05 55                .BYTE   5,'U'
001526  2  CD 13                .WORD   LBB_UNTIL       ; UNTIL
001528  2  05 57                .BYTE   5,'W'
00152A  2  F7 13                .WORD   LBB_WHILE       ; WHILE
00152C  2  03 4F                .BYTE   3,'O'
00152E  2  03 13                .WORD   LBB_OFF         ; OFF
001530  2               
001530  2               ; opperators
001530  2               
001530  2  01 2B                .BYTE   1,'+'
001532  2  00 00                .WORD   $0000           ; +
001534  2  01 2D                .BYTE   1,'-'
001536  2  00 00                .WORD   $0000           ; -
001538  2  01 2A                .BYTE   1,'*'
00153A  2  00 00                .WORD   $0000           ; *
00153C  2  01 2F                .BYTE   1,'/'
00153E  2  00 00                .WORD   $0000           ; /
001540  2  01 5E                .BYTE   1,'^'
001542  2  00 00                .WORD   $0000           ; ^
001544  2  03 41                .BYTE   3,'A'
001546  2  E6 11                .WORD   LBB_AND         ; AND
001548  2  03 45                .BYTE   3,'E'
00154A  2  61 12                .WORD   LBB_EOR         ; EOR
00154C  2  02 4F                .BYTE   2,'O'
00154E  2  0C 13                .WORD   LBB_OR          ; OR
001550  2  02 3E                .BYTE   2,'>'
001552  2  DC 11                .WORD   LBB_RSHIFT      ; >>
001554  2  02 3C                .BYTE   2,'<'
001556  2  D6 11                .WORD   LBB_LSHIFT      ; <<
001558  2  01 3E                .BYTE   1,'>'
00155A  2  00 00                .WORD   $0000           ; >
00155C  2  01 3D                .BYTE   1,'='
00155E  2  00 00                .WORD   $0000           ; =
001560  2  01 3C                .BYTE   1,'<'
001562  2  00 00                .WORD   $0000           ; <
001564  2               
001564  2               ; functions
001564  2               
001564  2  04 53                .BYTE   4,'S'           ;
001566  2  6B 13                .WORD   LBB_SGN         ; SGN
001568  2  04 49                .BYTE   4,'I'           ;
00156A  2  AA 12                .WORD   LBB_INT         ; INT
00156C  2  04 41                .BYTE   4,'A'           ;
00156E  2  E2 11                .WORD   LBB_ABS         ; ABS
001570  2  04 55                .BYTE   4,'U'           ;
001572  2  D2 13                .WORD   LBB_USR         ; USR
001574  2  04 46                .BYTE   4,'F'           ;
001576  2  6E 12                .WORD   LBB_FRE         ; FRE
001578  2  04 50                .BYTE   4,'P'           ;
00157A  2  25 13                .WORD   LBB_POS         ; POS
00157C  2  04 53                .BYTE   4,'S'           ;
00157E  2  9A 13                .WORD   LBB_SQR         ; SQR
001580  2  04 52                .BYTE   4,'R'           ;
001582  2  4E 13                .WORD   LBB_RND         ; RND
001584  2  04 4C                .BYTE   4,'L'           ;
001586  2  D1 12                .WORD   LBB_LOG         ; LOG
001588  2  04 45                .BYTE   4,'E'           ;
00158A  2  64 12                .WORD   LBB_EXP         ; EXP
00158C  2  04 43                .BYTE   4,'C'           ;
00158E  2  2B 12                .WORD   LBB_COS         ; COS
001590  2  04 53                .BYTE   4,'S'           ;
001592  2  6F 13                .WORD   LBB_SIN         ; SIN
001594  2  04 54                .BYTE   4,'T'           ;
001596  2  B7 13                .WORD   LBB_TAN         ; TAN
001598  2  04 41                .BYTE   4,'A'           ;
00159A  2  ED 11                .WORD   LBB_ATN         ; ATN
00159C  2  05 50                .BYTE   5,'P'           ;
00159E  2  16 13                .WORD   LBB_PEEK        ; PEEK
0015A0  2  06 53                .BYTE   6,'S'
0015A2  2  7C 13                .WORD   LBB_SPEEK       ; SPEEK
0015A4  2  05 53                .BYTE   5,'S'           ;
0015A6  2  56 13                .WORD   LBB_SADD        ; SADD
0015A8  2  04 4C                .BYTE   4,'L'           ;
0015AA  2  BC 12                .WORD   LBB_LEN         ; LEN
0015AC  2  05 53                .BYTE   5,'S'           ;
0015AE  2  A6 13                .WORD   LBB_STRS        ; STR$
0015B0  2  04 56                .BYTE   4,'V'           ;
0015B2  2  D7 13                .WORD   LBB_VAL         ; VAL
0015B4  2  04 41                .BYTE   4,'A'           ;
0015B6  2  E9 11                .WORD   LBB_ASC         ; ASC
0015B8  2  07 55                .BYTE   7,'U'           ;
0015BA  2  C6 13                .WORD   LBB_UCASES      ; UCASE$
0015BC  2  07 4C                .BYTE   7,'L'           ;
0015BE  2  AF 12                .WORD   LBB_LCASES      ; LCASE$
0015C0  2  05 43                .BYTE   5,'C'           ;
0015C2  2  0F 12                .WORD   LBB_CHRS        ; CHR$
0015C4  2  05 48                .BYTE   5,'H'           ;
0015C6  2  84 12                .WORD   LBB_HEXS        ; HEX$
0015C8  2  05 42                .BYTE   5,'B'           ;
0015CA  2  F2 11                .WORD   LBB_BINS        ; BIN$
0015CC  2  07 42                .BYTE   7,'B'           ;
0015CE  2  03 12                .WORD   LBB_BITTST      ; BITTST
0015D0  2  04 4D                .BYTE   4,'M'           ;
0015D2  2  DA 12                .WORD   LBB_MAX         ; MAX
0015D4  2  04 4D                .BYTE   4,'M'           ;
0015D6  2  E3 12                .WORD   LBB_MIN         ; MIN
0015D8  2  02 50                .BYTE   2,'P'           ;
0015DA  2  1B 13                .WORD   LBB_PI          ; PI
0015DC  2  05 49                .BYTE   5,'I'           ;
0015DE  2  9B 12                .WORD   LBB_IECST       ; IECST
0015E0  2  07 56                .BYTE   7,'V'           ;
0015E2  2  E2 13                .WORD   LBB_VIDST       ; VIDST
0015E4  2  05 56                .BYTE   5,'V'           ;
0015E6  2  DB 13                .WORD   LBB_VPTR        ; VARPTR
0015E8  2  06 4C                .BYTE   6,'L'           ;
0015EA  2  B6 12                .WORD   LBB_LEFTS       ; LEFT$
0015EC  2  07 52                .BYTE   7,'R'           ;
0015EE  2  47 13                .WORD   LBB_RIGHTS      ; RIGHT$
0015F0  2  05 4D                .BYTE   5,'M'           ;
0015F2  2  DE 12                .WORD   LBB_MIDS        ; MID$
0015F4  2  04 43                .BYTE   4,'C'           ;
0015F6  2  23 12                .WORD   LBB_CON         ; CON
0015F8  2               
0015F8  1               
0015F8  1               ; DEFINITIONS
0015F8  1                       .INCLUDE "definitions.asm"
0015F8  2               PROGRAMBANK     = $FF           ; BANK THAT THE INTREPRETER LIVES IN
0015F8  2               DATABANK        = $02           ; BANK THAT THE DATA LIVES IN
0015F8  2               
0015F8  2               FNBUFFER        = $000F00       ; FILE NAME BUFFER, MUST BE IN ZERO BANK!
0015F8  2               
0015F8  2               
0015F8  2               
0015F8  2               ; offsets from a base of X or Y
0015F8  2               
0015F8  2               PLUS_0          = $00           ; X or Y plus 0
0015F8  2               PLUS_1          = $01           ; X or Y plus 1
0015F8  2               PLUS_2          = $02           ; X or Y plus 2
0015F8  2               PLUS_3          = $03           ; X or Y plus 3
0015F8  2               
0015F8  2               STACK_BOTTOM    = $D000         ; stack bottom, no offset
0015F8  2               STACK           = $DFFF         ; stack top, no offset
0015F8  2               
0015F8  2               ccflag          = $000200       ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
0015F8  2               ccbyte          = ccflag+1      ; BASIC CTRL-C byte
0015F8  2               ccnull          = ccbyte+1      ; BASIC CTRL-C byte timeout
0015F8  2               
0015F8  2               VEC_CC          = ccnull+1      ; ctrl c check vector
0015F8  2               
0015F8  2               
0015F8  2               ; Ibuffs can now be anywhere in RAM AS LONG AS IT IS BEFORE RAM_BASE AND IS NOT PAGE ALIGNED!, ensure that the max length is < $80
0015F8  2               
0015F8  2                       .IF     PROGRAMBANK=DATABANK
0015F8  2               Ibuffs              = (ENDOFBASIC&$FF00)+$181
0015F8  2                       .ELSE
0015F8  2               Ibuffs              = $2000+$181
0015F8  2               LIbuffs             = (DATABANK*$10000)+$2000+$181
0015F8  2                       .ENDIF
0015F8  2               Ibuffe          = Ibuffs+80     ; end of input buffer
0015F8  2               
0015F8  2               Ram_base        = ((Ibuffe+1)&$FF00)+$100; start of user RAM (set as needed, should be page aligned)
0015F8  2               Ram_top         = $FF00         ; end of user RAM+1 (set as needed, should be page aligned)
0015F8  2               
0015F8  1               
0015F8  1               ; MESSAGES
0015F8  1                       .INCLUDE "messages.asm"
0015F8  2               
0015F8  2               LAB_CONMSG:
0015F8  2  80 80 80 83          .BYTE   $80,$80,$80,$83,$84,$85,"  Werner Engineering 816",$0D
0015FC  2  84 85 20 20  
001600  2  57 65 72 6E  
001617  2  81 81 81 83          .BYTE   $81,$81,$81,$83,$84,$85,"  Enhanced BASIC 65816 2.3",$0D
00161B  2  84 85 20 20  
00161F  2  45 6E 68 61  
001638  2  82 82 82 83          .BYTE   $82,$82,$82,$83,$84,$85,00
00163C  2  84 85 00     
00163F  2               
00163F  2               LAB_SMSG:
00163F  2  20 42 79 74          .BYTE   " Bytes free",$00
001643  2  65 73 20 66  
001647  2  72 65 65 00  
00164B  2               LAB_SMSG1:
00164B  2  0D 0A 45 6E          .BYTE   $0D,$0A,"Enhanced BASIC 65816 2.3",$00
00164F  2  68 61 6E 63  
001653  2  65 64 20 42  
001666  2  0D 0A 44 45          .BYTE   $0D,$0A,"DERIVED FROM ehBASIC BY LEE DAVIDSON",$00
00166A  2  52 49 56 45  
00166E  2  44 20 46 52  
00168D  2               
00168D  2               ; BASIC messages, mostly error messages
00168D  2               
00168D  2               LAB_BAER:
00168D  2  B1 16                .WORD   ERR_NF          ;$00 NEXT without FOR
00168F  2  C2 16                .WORD   ERR_SN          ;$02 syntax
001691  2  C9 16                .WORD   ERR_RG          ;$04 RETURN without GOSUB
001693  2  DE 16                .WORD   ERR_OD          ;$06 out of data
001695  2  EA 16                .WORD   ERR_FC          ;$08 function call
001697  2  F8 16                .WORD   ERR_OV          ;$0A overflow
001699  2  01 17                .WORD   ERR_OM          ;$0C out of memory
00169B  2  0F 17                .WORD   ERR_US          ;$0E undefined statement
00169D  2  23 17                .WORD   ERR_BS          ;$10 array bounds
00169F  2  30 17                .WORD   ERR_DD          ;$12 double dimension array
0016A1  2  41 17                .WORD   ERR_D0          ;$14 divide by 0
0016A3  2  50 17                .WORD   ERR_ID          ;$16 illegal direct
0016A5  2  5F 17                .WORD   ERR_TM          ;$18 type mismatch
0016A7  2  6D 17                .WORD   ERR_LS          ;$1A long string
0016A9  2  7D 17                .WORD   ERR_ST          ;$1C string too complex
0016AB  2  90 17                .WORD   ERR_CN          ;$1E continue error
0016AD  2  9F 17                .WORD   ERR_UF          ;$20 undefined function
0016AF  2  B2 17                .WORD   ERR_LD          ;$22 LOOP without DO
0016B1  2               
0016B1  2               ERR_NF:
0016B1  2  4E 45 58 54          .BYTE   "NEXT without FOR",$00
0016B5  2  20 77 69 74  
0016B9  2  68 6F 75 74  
0016C2  2               ERR_SN:
0016C2  2  53 79 6E 74          .BYTE   "Syntax",$00
0016C6  2  61 78 00     
0016C9  2               ERR_RG:
0016C9  2  52 45 54 55          .BYTE   "RETURN without GOSUB",$00
0016CD  2  52 4E 20 77  
0016D1  2  69 74 68 6F  
0016DE  2               ERR_OD:
0016DE  2  4F 75 74 20          .BYTE   "Out of DATA",$00
0016E2  2  6F 66 20 44  
0016E6  2  41 54 41 00  
0016EA  2               ERR_FC:
0016EA  2  46 75 6E 63          .BYTE   "Function call",$00
0016EE  2  74 69 6F 6E  
0016F2  2  20 63 61 6C  
0016F8  2               ERR_OV:
0016F8  2  4F 76 65 72          .BYTE   "Overflow",$00
0016FC  2  66 6C 6F 77  
001700  2  00           
001701  2               ERR_OM:
001701  2  4F 75 74 20          .BYTE   "Out of memory",$00
001705  2  6F 66 20 6D  
001709  2  65 6D 6F 72  
00170F  2               ERR_US:
00170F  2  55 6E 64 65          .BYTE   "Undefined statement",$00
001713  2  66 69 6E 65  
001717  2  64 20 73 74  
001723  2               ERR_BS:
001723  2  41 72 72 61          .BYTE   "Array bounds",$00
001727  2  79 20 62 6F  
00172B  2  75 6E 64 73  
001730  2               ERR_DD:
001730  2  44 6F 75 62          .BYTE   "Double dimension",$00
001734  2  6C 65 20 64  
001738  2  69 6D 65 6E  
001741  2               ERR_D0:
001741  2  44 69 76 69          .BYTE   "Divide by zero",$00
001745  2  64 65 20 62  
001749  2  79 20 7A 65  
001750  2               ERR_ID:
001750  2  49 6C 6C 65          .BYTE   "Illegal direct",$00
001754  2  67 61 6C 20  
001758  2  64 69 72 65  
00175F  2               ERR_TM:
00175F  2  54 79 70 65          .BYTE   "Type mismatch",$00
001763  2  20 6D 69 73  
001767  2  6D 61 74 63  
00176D  2               ERR_LS:
00176D  2  53 74 72 69          .BYTE   "String too long",$00
001771  2  6E 67 20 74  
001775  2  6F 6F 20 6C  
00177D  2               ERR_ST:
00177D  2  53 74 72 69          .BYTE   "String too complex",$00
001781  2  6E 67 20 74  
001785  2  6F 6F 20 63  
001790  2               ERR_CN:
001790  2  43 61 6E 27          .BYTE   "Can't continue",$00
001794  2  74 20 63 6F  
001798  2  6E 74 69 6E  
00179F  2               ERR_UF:
00179F  2  55 6E 64 65          .BYTE   "Undefined function",$00
0017A3  2  66 69 6E 65  
0017A7  2  64 20 66 75  
0017B2  2               ERR_LD:
0017B2  2  4C 4F 4F 50          .BYTE   "LOOP without DO",$00
0017B6  2  20 77 69 74  
0017BA  2  68 6F 75 74  
0017C2  2               
0017C2  2               LAB_BMSG:
0017C2  2  0D 0A 42 72          .BYTE   $0D,$0A,"Break",$00
0017C6  2  65 61 6B 00  
0017CA  2               LAB_EMSG:
0017CA  2  20 45 72 72          .BYTE   " Error",$00
0017CE  2  6F 72 00     
0017D1  2               LAB_LMSG:
0017D1  2  20 69 6E 20          .BYTE   " in line ",$00
0017D5  2  6C 69 6E 65  
0017D9  2  20 00        
0017DB  2               LAB_RMSG:
0017DB  2  0D 0A 52 65          .BYTE   $0D,$0A,"Ready",$0D,$0A,$00
0017DF  2  61 64 79 0D  
0017E3  2  0A 00        
0017E5  2               
0017E5  2               LAB_IMSG:
0017E5  2  20 45 78 74          .BYTE   " Extra ignored",$0D,$0A,$00
0017E9  2  72 61 20 69  
0017ED  2  67 6E 6F 72  
0017F6  2               LAB_REDO:
0017F6  2  20 52 65 64          .BYTE   " Redo from start",$0D,$0A,$00
0017FA  2  6F 20 66 72  
0017FE  2  6F 6D 20 73  
001809  2               LAB_IOER:
001809  2  20 49 2F 4F          .BYTE   " I/O Error",$0D,$0A,$00
00180D  2  20 45 72 72  
001811  2  6F 72 0D 0A  
001816  2               
001816  1               
001816  1               ; NUMERIC CONSTANTS
001816  1                       .INCLUDE "numconst.asm"
001816  2               ; numeric constants and series
001816  2               ; constants and series for LOG(n)
001816  2               LAB_25A0:
001816  2  02                   .BYTE   $02             ; counter
001817  2  80 19 56 62          .BYTE   $80,$19,$56,$62 ; 0.59898
00181B  2  80 76 22 F3          .BYTE   $80,$76,$22,$F3 ; 0.96147
00181F  2  82 38 AA 40          .BYTE   $82,$38,$AA,$40 ; 2.88539
001823  2               
001823  2               LAB_25AD:
001823  2  80 35 04 F3          .BYTE   $80,$35,$04,$F3 ; 0.70711	1/root 2
001827  2               LAB_25B1:
001827  2  81 35 04 F3          .BYTE   $81,$35,$04,$F3 ; 1.41421	root 2
00182B  2               LAB_25B5:
00182B  2  80 80 00 00          .BYTE   $80,$80,$00,$00 ; -0.5
00182F  2               LAB_25B9:
00182F  2  80 31 72 18          .BYTE   $80,$31,$72,$18 ; 0.69315	LOG(2)
001833  2               
001833  2               ; numeric PRINT constants
001833  2               LAB_2947:
001833  2  91 43 4F F8          .BYTE   $91,$43,$4F,$F8 ; 99999.9375 (max value with at least one decimal)
001837  2               LAB_294B:
001837  2  94 74 23 F7          .BYTE   $94,$74,$23,$F7 ; 999999.4375 (max value before scientific notation)
00183B  2               LAB_294F:
00183B  2  94 74 24 00          .BYTE   $94,$74,$24,$00 ; 1000000
00183F  2               
00183F  2               ; EXP(n) constants and series
00183F  2               LAB_2AFA:
00183F  2  81 38 AA 3B          .BYTE   $81,$38,$AA,$3B ; 1.4427	(1/LOG base 2 e)
001843  2               LAB_2AFE:
001843  2  06                   .BYTE   $06             ; counter
001844  2  74 63 90 8C          .BYTE   $74,$63,$90,$8C ; 2.17023e-4
001848  2  77 23 0C AB          .BYTE   $77,$23,$0C,$AB ; 0.00124
00184C  2  7A 1E 94 00          .BYTE   $7A,$1E,$94,$00 ; 0.00968
001850  2  7C 63 42 80          .BYTE   $7C,$63,$42,$80 ; 0.05548
001854  2  7E 75 FE D0          .BYTE   $7E,$75,$FE,$D0 ; 0.24023
001858  2  80 31 72 15          .BYTE   $80,$31,$72,$15 ; 0.69315
00185C  2  81 00 00 00          .BYTE   $81,$00,$00,$00 ; 1.00000
001860  2               
001860  2               ; trigonometric constants and series
001860  2               LAB_2C78:
001860  2  81 49 0F DB          .BYTE   $81,$49,$0F,$DB ; 1.570796371 (pi/2) as floating #
001864  2               LAB_2C84:
001864  2  04                   .BYTE   $04             ; counter
001865  2  86 1E D7 FB          .BYTE   $86,$1E,$D7,$FB ; 39.7109
001869  2  87 99 26 65          .BYTE   $87,$99,$26,$65 ;-76.575
00186D  2  87 23 34 58          .BYTE   $87,$23,$34,$58 ; 81.6022
001871  2  86 A5 5D E1          .BYTE   $86,$A5,$5D,$E1 ;-41.3417
001875  2               LAB_2C7C:
001875  2  83 49 0F DB          .BYTE   $83,$49,$0F,$DB ; 6.28319 (2*pi) as floating #
001879  2               
001879  2               LAB_2CC9:
001879  2  08                   .BYTE   $08             ; counter
00187A  2  78 3A C5 37          .BYTE   $78,$3A,$C5,$37 ; 0.00285
00187E  2  7B 83 A2 5C          .BYTE   $7B,$83,$A2,$5C ;-0.0160686
001882  2  7C 2E DD 4D          .BYTE   $7C,$2E,$DD,$4D ; 0.0426915
001886  2  7D 99 B0 1E          .BYTE   $7D,$99,$B0,$1E ;-0.0750429
00188A  2  7D 59 ED 24          .BYTE   $7D,$59,$ED,$24 ; 0.106409
00188E  2  7E 91 72 00          .BYTE   $7E,$91,$72,$00 ;-0.142036
001892  2  7E 4C B9 73          .BYTE   $7E,$4C,$B9,$73 ; 0.199926
001896  2  7F AA AA 53          .BYTE   $7F,$AA,$AA,$53 ;-0.333331
00189A  2               
00189A  2               LAB_1D96        = *+1           ; $00,$00 used for undefined variables
00189A  2               LAB_259C:
00189A  2  81 00 00 00          .BYTE   $81,$00,$00,$00 ; 1.000000, used for INC
00189E  2               LAB_2AFD:
00189E  2  81 80 00 00          .BYTE   $81,$80,$00,$00 ; -1.00000, used for DEC. must be on the same page as +1.00
0018A2  2               
0018A2  2               ; misc constants
0018A2  2               LAB_1DF7:
0018A2  2  90                   .BYTE   $90             ;-32768 (uses first three bytes from 0.5)
0018A3  2               LAB_2A96:
0018A3  2  80 00 00 00          .BYTE   $80,$00,$00,$00 ; 0.5
0018A7  2               LAB_2C80:
0018A7  2  7F 00 00 00          .BYTE   $7F,$00,$00,$00 ; 0.25
0018AB  2               LAB_26B5:
0018AB  2  84 20 00 00          .BYTE   $84,$20,$00,$00 ; 10.0000 divide by 10 constant
0018AF  2               
0018AF  2               ; This table is used in converting numbers to ASCII.
0018AF  2               
0018AF  2               LAB_2A9A:
0018AF  2               LAB_2A9B        = LAB_2A9A+1
0018AF  2               LAB_2A9C        = LAB_2A9B+1
0018AF  2  FE 79 60             .BYTE   $FE,$79,$60     ; -100000
0018B2  2  00 27 10             .BYTE   $00,$27,$10     ; 10000
0018B5  2  FF FC 18             .BYTE   $FF,$FC,$18     ; -1000
0018B8  2  00 00 64             .BYTE   $00,$00,$64     ; 100
0018BB  2  FF FF F6             .BYTE   $FF,$FF,$F6     ; -10
0018BE  2  00 00 01             .BYTE   $00,$00,$01     ; 1
0018C1  2               
0018C1  1               
0018C1  1               ; I/O VECTORS
0018C1  1                       .INCLUDE "iovect.asm"
0018C1  2               ;__________________________________________________________
0018C1  2               ;
0018C1  2               ; BIOS JUMP TABLE (NATIVE)
0018C1  2               ;__________________________________________________________
0018C1  2               LPRINTVEC       = $00FD00
0018C1  2               LINPVEC         = $00FD04
0018C1  2               LINPWVEC        = $00FD08
0018C1  2               LSetXYVEC       = $00FD0C
0018C1  2               LCPYVVEC        = $00FD10
0018C1  2               LSrlUpVEC       = $00FD14
0018C1  2               LSetColorVEC    = $00FD18
0018C1  2               LCURSORVEC      = $00FD1C
0018C1  2               LUNCURSORVEC    = $00FD20
0018C1  2               LWRITERTC       = $00FD24
0018C1  2               LREADRTC        = $00FD28
0018C1  2               LIECIN          = $00FD2C
0018C1  2               LIECOUT         = $00FD30
0018C1  2               LUNTALK         = $00FD34
0018C1  2               LUNLSTN         = $00FD38
0018C1  2               LLISTEN         = $00FD3C
0018C1  2               LTALK           = $00FD40
0018C1  2               LSETLFS         = $00FD44
0018C1  2               LSETNAM         = $00FD48
0018C1  2               LLOAD           = $00FD4C
0018C1  2               LSAVE           = $00FD50
0018C1  2               LIECINIT        = $00FD54
0018C1  2               LIECCLCH        = $00FD58       ; close input and output channels
0018C1  2               LIECOUTC        = $00FD5C       ; open a channel for output
0018C1  2               LIECINPC        = $00FD60       ; open a channel for input
0018C1  2               LIECOPNLF       = $00FD64       ; open a logical file
0018C1  2               LIECCLSLF       = $00FD68       ; close a specified logical file
0018C1  2               LClearScrVec    = $00FD6C       ; clear the 9918 Screen
0018C1  2               LLOADFONTVec    = $00FD70       ; load the 9918 font
0018C1  2               
0018C1  2               
0018C1  2               CSRX            = $0330         ; CURRENT X POSITION
0018C1  2               CSRY            = $0331         ; CURRENT Y POSITION
0018C1  2               ConsoleDevice   = $0341         ; Current Console Device
0018C1  2               VIDEOWIDTH      = $0343
0018C1  2               SpriteAttrs     = $0344
0018C1  2               SpritePatterns  = $0345
0018C1  2               IECSTW          = $000317
0018C1  2               IECMSGM         = $00031F       ; message mode flag,
0018C1  2               ; $C0 = both control and kernal messages,
0018C1  2               ; $80 = control messages only,
0018C1  2               ; $40 = kernal messages only,
0018C1  2               ; $00 = neither control or kernal messages
0018C1  2               LOADBUFL        = $000322       ; IEC buffer Pointer
0018C1  2               LOADBUFH        = LOADBUFL+1
0018C1  2               LOADBANK        = LOADBUFL+2    ; BANK buffer Pointer
0018C1  2               IECSTRTL        = $00031D       ; IEC Start Address Pointer
0018C1  2               IECSTRTH        = IECSTRTL+1
0018C1  2               LINEFLGS        = $03D0         ; 24 BYTES OF LINE POINTERS (3D0 - 3E9 , one extra for scrolling)
0018C1  2               
0018C1  2               CMDP            = $FE0B         ; 	VDP COMMAND port
0018C1  2               DATAP           = $FE0A         ; 	VDP Data port
0018C1  2               
0018C1  2               ;__________________________________________________________
0018C1  2               
0018C1  2               
0018C1  2               
0018C1  2               
0018C1  2               ;___V_INPT_________________________________________________
0018C1  2               ;
0018C1  2               ; MAKE A BIOS CALL TO GET NON-BLOCKING CHARACTER INPUT
0018C1  2               ; THIS COULD BE SERIAL OR KEYBOARD DEPENDING ON BIOS SETTING
0018C1  2               ; RETURNS
0018C1  2               ;   A: CHARACTER
0018C1  2               ;      CARRY SET IF NO CHARACTER
0018C1  2               ;
0018C1  2               ;
0018C1  2               ;   NOTE THAT BIOS IS IN BANK 0, SO A LONG BRANCH IS REQUIRED
0018C1  2               ;__________________________________________________________
0018C1  2               V_INPT:
0018C1  2  8B                   PHB
0018C2  2  0B                   PHD
0018C3  2  DA                   PHX
0018C4  2  A2 00                LDX     #$00
0018C6  2  DA                   PHX
0018C7  2  AB                   PLB
0018C8  2  22 04 FD 00          JSL     LINPVEC         ; INCHAR
0018CC  2  FA                   PLX
0018CD  2  2B                   PLD
0018CE  2  AB                   PLB
0018CF  2  60                   RTS
0018D0  2               
0018D0  2               ;___V_OUTP_________________________________________________
0018D0  2               ;
0018D0  2               ; MAKE A BIOS CALL TO SEND CHARACTER TO OUTPUT
0018D0  2               ; THIS COULD BE SERIAL OR TMS9918 CHARACTER DISPLAY
0018D0  2               ;
0018D0  2               ;   A: CHARACTER
0018D0  2               ;
0018D0  2               ;
0018D0  2               ;   NOTE THAT BIOS IS IN BANK 0, SO A LONG BRANCH IS REQUIRED
0018D0  2               ;__________________________________________________________
0018D0  2               
0018D0  2               V_OUTP: ; send byte to output device
0018D0  2  8B                   PHB
0018D1  2  0B                   PHD
0018D2  2  DA                   PHX
0018D3  2  A6 06                LDX     <VIDEOMODE
0018D5  2  E0 02                CPX     #2
0018D7  2  D0 08                BNE     V_OUTP1
0018D9  2  A2 00                LDX     #$00
0018DB  2  DA                   PHX
0018DC  2  AB                   PLB
0018DD  2  22 00 FD 00          JSL     LPRINTVEC       ; OUTCHAR
0018E1  2               V_OUTP1:
0018E1  2  FA                   PLX
0018E2  2  2B                   PLD
0018E3  2  AB                   PLB
0018E4  2  60                   RTS
0018E5  2               
0018E5  2               
0018E5  2                       .INCLUDE "diskcmds.asm"
0018E5  3               ;___V_SAVE_________________________________________________
0018E5  3               ;
0018E5  3               ; UTILIZE BIOS TO SAVE BASIC RAM
0018E5  3               ;
0018E5  3               ; STORE CONTENTS IN RAM FROM "Smeml/h" TO "Svarl/h"-1 IN BANK "DATABANK"
0018E5  3               ;
0018E5  3               ; BASIC COMMAND EXPECTS ONE STRING VAR (FILENAME) AND ONE NUMERIC VAR (DEVICE)
0018E5  3               ; THIS IS NATIVE '816 CODE
0018E5  3               ;__________________________________________________________
0018E5  3               V_SAVE: ; save BASIC program
0018E5  3  20 42 33             JSR     LAB_EVEX        ; GET THE FIRST PARAMETER
0018E8  3  A5 5F                LDA     <Dtypef         ; IS IT A STRING?
0018EA  3  D0 08                BNE     V_SAVE_GO       ; YES, CONTINUE ON
0018EC  3               V_SAVE_ERR:
0018EC  3  A2 02                LDX     #$02            ; NOPE, SYNTAX ERROR
0018EE  3  20 08 28             JSR     LAB_XERR
0018F1  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
0018F4  3               V_SAVE_GO:
0018F4  3  22 54 FD 00          JSL     LIECINIT        ; INIT IEC BUS
0018F8  3  A9 C0                LDA     #$C0
0018FA  3  85 03                STA     >IECMSGM
0018FC  3  A0 00                LDY     #$00
0018FE  3               V_SAVE_1:
0018FE  3  8B DA A2 01          LDAINDIRECTY ssptr_l
001902  3  B5 B8 C9 00  
001906  3  D0 04 A2 00  
001914  3  BB                   TYX
001915  3  95 0F                STA     >FNBUFFER,X
001917  3  C9 00                CMP     #$00
001919  3  F0 07                BEQ     V_SAVE_2
00191B  3  C9 22                CMP     #'"'
00191D  3  F0 03                BEQ     V_SAVE_2
00191F  3  C8                   INY
001920  3  D0 DC                BNE     V_SAVE_1
001922  3               V_SAVE_2:
001922  3  98                   TYA                     ; fn length
001923  3  A2 00                LDX     #<FNBUFFER
001925  3  A0 0F                LDY     #>FNBUFFER
001927  3  8B                   PHB
001928  3  DA A2 00 DA          SETBANK 0
00192C  3  AB FA        
00192E  3  22 48 FD 00          JSL     LSETNAM         ; setnam
001932  3  AB                   PLB
001933  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
001936  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X
001939  3  A0 01                LDY#1                   ; secondary address
00193B  3  8B                   PHB
00193C  3  DA A2 00 DA          SETBANK 0
001940  3  AB FA        
001942  3  22 44 FD 00          JSL     LSETLFS
001946  3  A5 7A                LDA     <Smemh
001948  3  8D 1E 03             STA     IECSTRTH
00194B  3  A5 79                LDA     <Smeml
00194D  3  8D 1D 03             STA     IECSTRTL
001950  3  A5 7B                LDA     <Svarl
001952  3  8D 22 03             STA     LOADBUFL
001955  3  A5 7C                LDA     <Svarh
001957  3  8D 23 03             STA     LOADBUFH
00195A  3  A9 02                LDA     #DATABANK
00195C  3  8D 24 03             STA     LOADBANK
00195F  3  22 50 FD 00          JSL     LSAVE
001963  3  AB                   PLB
001964  3  A9 DB                LDA     #<LAB_RMSG      ; point to "Ready" message low byte
001966  3  A0 17                LDY     #>LAB_RMSG      ; point to "Ready" message high byte
001968  3  20 CA 30             JSR     LAB_18C3
00196B  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
00196E  3               
00196E  3               
00196E  3               
00196E  3               
00196E  3               ;___V_LOAD_________________________________________________
00196E  3               ;
00196E  3               ; UTILIZE BIOS TO LOAD BASIC RAM
00196E  3               ;
00196E  3               ; LOAD CONTENTS TO RAM "Smeml/h" BANK "DATABANK"
00196E  3               ;
00196E  3               ; BASIC COMMAND EXPECTS ONE STRING VAR (FILENAME) AND ONE NUMERIC VAR (DEVICE)
00196E  3               ; THIS IS NATIVE '816 CODE
00196E  3               ;__________________________________________________________
00196E  3               V_LOAD: ; load BASIC program
00196E  3  20 42 33             JSR     LAB_EVEX        ; GET THE FIRST PARAMETER
001971  3  A5 5F                LDA     <Dtypef         ; IS IT A STRING?
001973  3  D0 08                BNE     V_LOAD_GO       ; YES, CONTINUE ON
001975  3               V_LOAD_ERR:
001975  3  A2 02                LDX     #$02            ; NOPE, SYNTAX ERROR
001977  3  20 08 28             JSR     LAB_XERR
00197A  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
00197D  3               V_LOAD_GO:
00197D  3  22 54 FD 00          JSL     LIECINIT        ; INIT IEC BUS
001981  3  A9 C0                LDA     #$C0
001983  3  85 1F                STA     <IECMSGM
001985  3  A0 00                LDY     #$00
001987  3               V_LOAD_1:
001987  3  8B DA A2 01          LDAINDIRECTY ssptr_l
00198B  3  B5 B8 C9 00  
00198F  3  D0 04 A2 00  
00199D  3  BB                   TYX
00199E  3  95 0F                STA     >FNBUFFER,X
0019A0  3  C9 00                CMP     #$00
0019A2  3  F0 07                BEQ     V_LOAD_2
0019A4  3  C9 22                CMP     #'"'
0019A6  3  F0 03                BEQ     V_LOAD_2
0019A8  3  C8                   INY
0019A9  3  D0 DC                BNE     V_LOAD_1
0019AB  3               V_LOAD_2:
0019AB  3  98                   TYA                     ; fn length
0019AC  3  A2 00                LDX     #<FNBUFFER
0019AE  3  A0 0F                LDY     #>FNBUFFER
0019B0  3  8B                   PHB
0019B1  3  DA A2 00 DA          SETBANK 0
0019B5  3  AB FA        
0019B7  3  22 48 FD 00          JSL     LSETNAM         ; setnam
0019BB  3  AB                   PLB
0019BC  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
0019BF  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X
0019C2  3  A0 01                LDY#1                   ; secondary address
0019C4  3  8B                   PHB
0019C5  3  DA A2 00 DA          SETBANK 0
0019C9  3  AB FA        
0019CB  3  22 44 FD 00          JSL     LSETLFS
0019CF  3  A5 7A                LDA     <Smemh
0019D1  3  8D 23 03             STA     LOADBUFH
0019D4  3  A5 79                LDA     <Smeml
0019D6  3  8D 22 03             STA     LOADBUFL
0019D9  3  A9 02                LDA     #DATABANK
0019DB  3  8D 24 03             STA     LOADBANK
0019DE  3  22 4C FD 00          JSL     LLOAD
0019E2  3  AD 23 03             LDA     LOADBUFH
0019E5  3  85 7C                STA     <Svarh
0019E7  3  AD 22 03             LDA     LOADBUFL
0019EA  3  85 7B                STA     <Svarl
0019EC  3  AB                   PLB
0019ED  3  A9 DB                LDA     #<LAB_RMSG      ; point to "Ready" message low byte
0019EF  3  A0 17                LDY     #>LAB_RMSG      ; point to "Ready" message high byte
0019F1  3  20 CA 30             JSR     LAB_18C3
0019F4  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
0019F7  3               
0019F7  3               
0019F7  3               ;___V_ERR___________________________________________________
0019F7  3               ;
0019F7  3               ; UTILIZE BIOS TO REPORT IEC IO CHANNEL STATUS
0019F7  3               ;
0019F7  3               ;
0019F7  3               ; BASIC COMMAND EXPECTS ONE NUMERIC VAR (DEVICE)
0019F7  3               ; THIS IS NATIVE '816 CODE
0019F7  3               ;__________________________________________________________
0019F7  3               V_ERR:
0019F7  3  22 54 FD 00          JSL     LIECINIT        ; INIT IEC BUS
0019FB  3  A9 C0                LDA     #$C0
0019FD  3  85 03                STA     >IECMSGM
0019FF  3  A0 00                LDY     #$00
001A01  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X
001A04  3               GETIECSTATUS:
001A04  3  8B                   PHB
001A05  3  DA                   PHX
001A06  3  DA A2 00 DA          SETBANK 0
001A0A  3  AB FA        
001A0C  3  A9 0D                LDA     #13
001A0E  3  22 00 FD 00          JSL     LPRINTVEC       ; OUTCHAR
001A12  3  A9 0A                LDA     #10
001A14  3  22 00 FD 00          JSL     LPRINTVEC       ; OUTCHAR
001A18  3  A9 00                LDA     #0              ; fn length
001A1A  3  A2 00                LDX     #0
001A1C  3  A0 00                LDY     #0
001A1E  3  22 48 FD 00          JSL     LSETNAM         ; setnam
001A22  3  FA                   PLX                     ; Device Number
001A23  3  A0 0F                LDY     #15             ; secondary address
001A25  3  A9 0F                LDA     #15             ; LFN NUMBER
001A27  3  22 44 FD 00          JSL     LSETLFS         ;setlfs
001A2B  3  22 64 FD 00          JSL     LIECOPNLF
001A2F  3  B0 1C                BCS     IECERROR
001A31  3  A2 0F                LDX     #15
001A33  3  22 60 FD 00          JSL     LIECINPC
001A37  3  B0 14                BCS     IECERROR
001A39  3               GETIECSTATUS_1:
001A39  3  22 2C FD 00          JSL     LIECIN          ; input a byte from the serial bus
001A3D  3  B0 0E                BCS     IECERROR
001A3F  3  C9 0D                CMP     #13
001A41  3  F0 0A                BEQ     IECERROR
001A43  3  22 00 FD 00          JSL     LPRINTVEC       ; OUTCHAR
001A47  3  A5 03                LDA     >IECSTW         ; get serial status byte
001A49  3  4A                   LSR                     ; shift time out read ..
001A4A  3  4A                   LSR                     ; .. into carry bit
001A4B  3  90 EC                BCC     GETIECSTATUS_1  ; all ok, do another
001A4D  3               IECERROR:
001A4D  3  22 58 FD 00          JSL     LIECCLCH        ; close input and output channels
001A51  3  A9 0F                LDA     #15
001A53  3  22 68 FD 00          JSL     LIECCLSLF       ; close a specified logical file
001A57  3  A9 0D                LDA     #13
001A59  3  22 00 FD 00          JSL     LPRINTVEC       ; OUTCHAR
001A5D  3  A9 0A                LDA     #10
001A5F  3  22 00 FD 00          JSL     LPRINTVEC       ; OUTCHAR
001A63  3  AB                   PLB
001A64  3  A9 DB                LDA     #<LAB_RMSG      ; point to "Ready" message low byte
001A66  3  A0 17                LDY     #>LAB_RMSG      ; point to "Ready" message high byte
001A68  3  20 CA 30             JSR     LAB_18C3
001A6B  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
001A6E  3               
001A6E  3               
001A6E  3               
001A6E  3               ;___V_DIR___________________________________________________
001A6E  3               ;
001A6E  3               ; UTILIZE BIOS TO DISPLAY DISK DIRECTORY
001A6E  3               ;
001A6E  3               ;
001A6E  3               ; BASIC COMMAND EXPECTS ONE NUMERIC VAR (DEVICE)
001A6E  3               ; THIS IS NATIVE '816 CODE
001A6E  3               ;__________________________________________________________
001A6E  3               V_DIR:
001A6E  3  22 54 FD 00          JSL     LIECINIT        ; INIT IEC BUS
001A72  3  A9 C0                LDA     #$C0
001A74  3  85 03                STA     >IECMSGM
001A76  3  A0 00                LDY     #$00
001A78  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X
001A7B  3  8B                   PHB
001A7C  3  DA                   PHX
001A7D  3  A9 24                LDA     #'$'
001A7F  3  85 0F                STA     >FNBUFFER
001A81  3  DA A2 00 DA          SETBANK 0
001A85  3  AB FA        
001A87  3  A9 0D                LDA     #13
001A89  3  22 00 FD 00          JSL     LPRINTVEC
001A8D  3  A9 0A                LDA     #10
001A8F  3  22 00 FD 00          JSL     LPRINTVEC
001A93  3  A9 01                LDA     #1              ; fn length
001A95  3  A2 00                LDX     #<FNBUFFER
001A97  3  A0 0F                LDY     #>FNBUFFER
001A99  3  22 48 FD 00          JSL     LSETNAM         ; setnam
001A9D  3  FA                   PLX                     ; Device Number
001A9E  3  A0 00                LDY     #0              ; secondary address
001AA0  3  A9 0F                LDA     #15             ; LFN NUMBER
001AA2  3  22 44 FD 00          JSL     LSETLFS         ;setlfs
001AA6  3  22 64 FD 00          JSL     LIECOPNLF
001AAA  3  B0 A1                BCS     IECERROR
001AAC  3  A2 0F                LDX     #15
001AAE  3  22 60 FD 00          JSL     LIECINPC
001AB2  3  B0 99                BCS     IECERROR
001AB4  3  22 2C FD 00          JSL     LIECIN          ; input a byte from the serial bus
001AB8  3               GETIECDIRECTORY_1:
001AB8  3  22 2C FD 00          JSL     LIECIN          ; input a byte from the serial bus
001ABC  3  22 2C FD 00          JSL     LIECIN          ; input a byte from the serial bus
001AC0  3  48                   PHA
001AC1  3  22 2C FD 00          JSL     LIECIN          ; input a byte from the serial bus
001AC5  3  FA                   PLX
001AC6  3  AB                   PLB
001AC7  3  8B                   PHB
001AC8  3  20 E3 47             JSR     LAB_295E        ; print XA as unsigned integer (bytes free)
001ACB  3  DA A2 00 DA          SETBANK 0
001ACF  3  AB FA        
001AD1  3  A9 20                LDA     #' '
001AD3  3  22 00 FD 00          JSL     LPRINTVEC
001AD7  3  A9 20                LDA     #' '
001AD9  3  22 00 FD 00          JSL     LPRINTVEC
001ADD  3  22 2C FD 00          JSL     LIECIN
001AE1  3  C9 00                CMP     #$00
001AE3  3  F0 04                BEQ     GETIECDIRECTORY_2A
001AE5  3  22 00 FD 00          JSL     LPRINTVEC
001AE9  3               GETIECDIRECTORY_2A:
001AE9  3  22 2C FD 00          JSL     LIECIN
001AED  3  C9 00                CMP     #$00
001AEF  3  F0 04                BEQ     GETIECDIRECTORY_2
001AF1  3  22 00 FD 00          JSL     LPRINTVEC
001AF5  3               GETIECDIRECTORY_2:
001AF5  3  22 2C FD 00          JSL     LIECIN          ; input ENTRY TEXT byte from the serial bus
001AF9  3  22 00 FD 00          JSL     LPRINTVEC
001AFD  3  C9 00                CMP     #$00
001AFF  3  F0 27                BEQ     GETIECDIRECTORY_3; END ENTRY
001B01  3               
001B01  3  A5 03                LDA     >IECSTW         ; get serial status byte
001B03  3  4A                   LSR                     ; shift time out read ..
001B04  3  4A                   LSR                     ; .. into carry bit
001B05  3  90 EE                BCC     GETIECDIRECTORY_2; all ok, do another
001B07  3               GETIECDIRECTORY_END:
001B07  3  22 58 FD 00          JSL     LIECCLCH        ; close input and output channels
001B0B  3  A9 0F                LDA     #15
001B0D  3  22 68 FD 00          JSL     LIECCLSLF       ; close a specified logical file
001B11  3  A9 0D                LDA     #13
001B13  3  22 00 FD 00          JSL     LPRINTVEC
001B17  3  A9 0A                LDA     #10
001B19  3  22 00 FD 00          JSL     LPRINTVEC
001B1D  3  AB                   PLB
001B1E  3  A9 DB                LDA     #<LAB_RMSG      ; point to "Ready" message low byte
001B20  3  A0 17                LDY     #>LAB_RMSG      ; point to "Ready" message high byte
001B22  3  20 CA 30             JSR     LAB_18C3
001B25  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
001B28  3               
001B28  3               GETIECDIRECTORY_3:
001B28  3  A9 0D                LDA     #13
001B2A  3  22 00 FD 00          JSL     LPRINTVEC
001B2E  3  A9 0A                LDA     #10
001B30  3  22 00 FD 00          JSL     LPRINTVEC
001B34  3  22 2C FD 00          JSL     LIECIN          ; input a byte from the serial bus
001B38  3  C9 01                CMP     #$01
001B3A  3  D0 CB                BNE     GETIECDIRECTORY_END
001B3C  3  4C B8 1A             JMP     GETIECDIRECTORY_1
001B3F  3               
001B3F  3               
001B3F  3               ;___V_DISKCMD______________________________________________
001B3F  3               ;
001B3F  3               ; UTILIZE BIOS TO SEND A DISK COMMAND
001B3F  3               ;
001B3F  3               ;
001B3F  3               ; BASIC COMMAND EXPECTS ONE STRING VAR (COMMAND) AND ONE NUMERIC VAR (DEVICE)
001B3F  3               ; THIS IS NATIVE '816 CODE
001B3F  3               ;__________________________________________________________
001B3F  3               V_DISKCMD:                      ; save BASIC program
001B3F  3  20 42 33             JSR     LAB_EVEX        ; GET THE FIRST PARAMETER
001B42  3  A5 5F                LDA     <Dtypef         ; IS IT A STRING?
001B44  3  D0 08                BNE     V_DISKCMD_GO    ; YES, CONTINUE ON
001B46  3               V_DISKCMD_ERR:
001B46  3  A2 02                LDX     #$02            ; NOPE, SYNTAX ERROR
001B48  3  20 08 28             JSR     LAB_XERR
001B4B  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
001B4E  3               V_DISKCMD_GO:
001B4E  3  22 54 FD 00          JSL     LIECINIT        ; INIT IEC BUS
001B52  3  A9 C0                LDA     #$C0
001B54  3  85 03                STA     >IECMSGM
001B56  3  20 55 3D             JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
001B59  3               ; space returns with A = length, X=$71=pointer low byte,
001B59  3               ; Y=$72=pointer high byte
001B59  3  86 B8                STX     <ssptr_l
001B5B  3  84 B9                STY     <ssptr_h
001B5D  3  AA                   TAX
001B5E  3  A0 00                LDY     #$00
001B60  3               V_DISKCMD_1:
001B60  3  8B DA A2 01          LDAINDIRECTY ssptr_l
001B64  3  B5 B8 C9 00  
001B68  3  D0 04 A2 00  
001B76  3  DA                   PHX
001B77  3  BB                   TYX
001B78  3  95 0F                STA     >FNBUFFER,X
001B7A  3  FA                   PLX
001B7B  3  CA                   DEX
001B7C  3  E0 00                CPX     #$00
001B7E  3  F0 03                BEQ     V_DISKCMD_2
001B80  3  C8                   INY
001B81  3  D0 DD                BNE     V_DISKCMD_1
001B83  3               V_DISKCMD_2:
001B83  3  BB                   TYX
001B84  3  A9 00                LDA     #0
001B86  3  95 10                STA     >FNBUFFER+1,X
001B88  3  8B                   PHB
001B89  3  DA A2 00 DA          SETBANK 0
001B8D  3  AB FA        
001B8F  3  A9 00                LDA     #0              ; fn length
001B91  3  A2 00                LDX     #0
001B93  3  A0 00                LDY     #0
001B95  3  22 48 FD 00          JSL     LSETNAM         ; setnam
001B99  3  AB                   PLB
001B9A  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
001B9D  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER (DEVICE NUMBER), RETURN IN X
001BA0  3  8B                   PHB
001BA1  3  DA A2 00 DA          SETBANK 0
001BA5  3  AB FA        
001BA7  3  A0 0F                LDY     #15             ; secondary address
001BA9  3  A9 0F                LDA     #15             ; LFN NUMBER
001BAB  3  22 44 FD 00          JSL     LSETLFS         ;setlfs
001BAF  3  22 64 FD 00          JSL     LIECOPNLF
001BB3  3  B0 25                BCS     V_DISKCMD_ERR1
001BB5  3  A2 0F                LDX     #15
001BB7  3  22 5C FD 00          JSL     LIECOUTC
001BBB  3  A2 00                LDX     #$00
001BBD  3               V_DISKCMD_3:
001BBD  3  B5 0F                LDA     >FNBUFFER,X
001BBF  3  C9 00                CMP     #$00
001BC1  3  F0 09                BEQ     V_DISKCMD_4
001BC3  3  22 30 FD 00          JSL     LIECOUT         ; OUTPUT a byte To the serial bus
001BC7  3  B0 11                BCS     V_DISKCMD_ERR1
001BC9  3               
001BC9  3  E8                   INX
001BCA  3  80 F1                BRA     V_DISKCMD_3
001BCC  3               V_DISKCMD_4:
001BCC  3  A9 0F                LDA     #15
001BCE  3  22 38 FD 00          JSL     LUNLSTN
001BD2  3  A9 0F                LDA     #15
001BD4  3  22 68 FD 00          JSL     LIECCLSLF       ; close a specified logical file
001BD8  3  AB                   PLB
001BD9  3  60                   RTS
001BDA  3               V_DISKCMD_ERR1:
001BDA  3  22 58 FD 00          JSL     LIECCLCH        ; close input and output channels
001BDE  3  A9 0F                LDA     #15
001BE0  3  22 68 FD 00          JSL     LIECCLSLF       ; close a specified logical file
001BE4  3  A9 0D                LDA     #13
001BE6  3  22 00 FD 00          JSL     LPRINTVEC       ; OUTCHAR
001BEA  3  A9 0A                LDA     #10
001BEC  3  22 00 FD 00          JSL     LPRINTVEC       ; OUTCHAR
001BF0  3  AB                   PLB
001BF1  3  A9 DB                LDA     #<LAB_RMSG      ; point to "Ready" message low byte
001BF3  3  A0 17                LDY     #>LAB_RMSG      ; point to "Ready" message high byte
001BF5  3  20 CA 30             JSR     LAB_18C3
001BF8  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
001BFB  3               
001BFB  3               
001BFB  3               
001BFB  3               ;___V_OPEN__________________________________________________
001BFB  3               ;
001BFB  3               ; UTILIZE BIOS TO OPEN AN IEC IO CHANNEL
001BFB  3               ;
001BFB  3               ;
001BFB  3               ; BASIC COMMAND EXPECTS THREE NUMERIC VARS, AND ONE STRING
001BFB  3               ; VAR
001BFB  3               ; FILE#, DEVICE, SECONDARY ADDRESS, FILENAME
001BFB  3               ; THIS IS NATIVE '816 CODE
001BFB  3               ;__________________________________________________________
001BFB  3               V_OPEN:
001BFB  3  8B                   PHB
001BFC  3  22 54 FD 00          JSL     LIECINIT        ; INIT IEC BUS
001C00  3  A9 C0                LDA     #$C0
001C02  3  85 03                STA     >IECMSGM
001C04  3  A0 00                LDY     #$00
001C06  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
001C09  3  DA                   PHX
001C0A  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
001C0D  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (DEVICE)
001C10  3  DA                   PHX
001C11  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
001C14  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE THIRD PARAMETER, RETURN IN X (SECONDARY ADDRESS)
001C17  3  DA                   PHX
001C18  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
001C1B  3  20 42 33             JSR     LAB_EVEX        ; GET THE FOURTH PARAMETER
001C1E  3  A5 5F                LDA     <Dtypef         ; IS IT A STRING?
001C20  3  D0 08                BNE     V_OPEN_GO       ; YES, CONTINUE ON
001C22  3  A2 02                LDX     #$02            ; NOPE, SYNTAX ERROR
001C24  3  20 08 28             JSR     LAB_XERR
001C27  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
001C2A  3               V_OPEN_GO:
001C2A  3  20 55 3D             JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
001C2D  3               ; space returns with A = length, X=$71=pointer low byte,
001C2D  3               ; Y=$72=pointer high byte
001C2D  3  86 B8                STX     <ssptr_l
001C2F  3  84 B9                STY     <ssptr_h
001C31  3  AA                   TAX
001C32  3  A0 00                LDY     #$00
001C34  3               V_OPEN_1:
001C34  3  8B DA A2 01          LDAINDIRECTY ssptr_l
001C38  3  B5 B8 C9 00  
001C3C  3  D0 04 A2 00  
001C4A  3  DA                   PHX
001C4B  3  BB                   TYX
001C4C  3  95 0F                STA     >FNBUFFER,X
001C4E  3  FA                   PLX
001C4F  3  CA                   DEX
001C50  3  E0 00                CPX     #$00
001C52  3  F0 03                BEQ     V_OPEN_2
001C54  3  C8                   INY
001C55  3  D0 DD                BNE     V_OPEN_1
001C57  3               V_OPEN_2:
001C57  3  C8                   INY
001C58  3  98                   TYA                     ; fn length
001C59  3  A2 00                LDX     #<FNBUFFER
001C5B  3  A0 0F                LDY     #>FNBUFFER
001C5D  3  DA A2 00 DA          SETBANK 0
001C61  3  AB FA        
001C63  3  22 48 FD 00          JSL     LSETNAM         ; setnam
001C67  3  FA                   PLX
001C68  3  9B                   TXY                     ; secondary address
001C69  3  FA                   PLX                     ; DEVICE NUMBER
001C6A  3  68                   PLA                     ; LFN NUMBER
001C6B  3  22 44 FD 00          JSL     LSETLFS         ;setlfs
001C6F  3  22 64 FD 00          JSL     LIECOPNLF
001C73  3  B0 02                BCS     V_OPEN_IECERROR
001C75  3  AB                   PLB
001C76  3  60                   RTS
001C77  3                       V_OPEN_IECERROR:
001C77  3  4C 4D 1A             JMP     IECERROR
001C7A  3               
001C7A  3               ;___V_CLOSE________________________________________________
001C7A  3               ;
001C7A  3               ; UTILIZE BIOS TO CLOSE AN IEC IO CHANNEL
001C7A  3               ;
001C7A  3               ;
001C7A  3               ; THIS IS NATIVE '816 CODE
001C7A  3               ;__________________________________________________________
001C7A  3               V_CLOSE:
001C7A  3  8B                   PHB
001C7B  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
001C7E  3  DA A2 00 DA          SETBANK 0
001C82  3  AB FA        
001C84  3  8A                   TXA
001C85  3  22 68 FD 00          JSL     LIECCLSLF       ; close a specified logical file
001C89  3  AB                   PLB
001C8A  3  60                   RTS
001C8B  3               
001C8B  3               ;___V_IECINPUT_______________________________________________
001C8B  3               ;
001C8B  3               ; UTILIZE BIOS TO USE OPEN AN IEC CHANNEL AS INPUT
001C8B  3               ;
001C8B  3               ;
001C8B  3               ; BASIC COMMAND EXPECTS ONE NUMERIC VARS, FILE#
001C8B  3               ; THIS IS NATIVE '816 CODE
001C8B  3               ;__________________________________________________________
001C8B  3               V_IECINPUT:
001C8B  3  8B                   PHB
001C8C  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
001C8F  3  DA A2 00 DA          SETBANK 0
001C93  3  AB FA        
001C95  3  22 60 FD 00          JSL     LIECINPC
001C99  3  B0 02                BCS     V_IECINPUT_IECERROR
001C9B  3  AB                   PLB
001C9C  3  60                   RTS
001C9D  3                       V_IECINPUT_IECERROR:
001C9D  3  AB                   PLB
001C9E  3  4C 4D 1A             JMP     IECERROR
001CA1  3               
001CA1  3               ;___V_IECOUTPUT______________________________________________
001CA1  3               ;
001CA1  3               ; UTILIZE BIOS TO USE OPEN AN IEC CHANNEL AS OUTPUT
001CA1  3               ;
001CA1  3               ;
001CA1  3               ; BASIC COMMAND EXPECTS ONE NUMERIC VARS, FILE#
001CA1  3               ; THIS IS NATIVE '816 CODE
001CA1  3               ;__________________________________________________________
001CA1  3               V_IECOUTPUT:
001CA1  3  8B                   PHB
001CA2  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
001CA5  3  DA A2 00 DA          SETBANK 0
001CA9  3  AB FA        
001CAB  3  22 5C FD 00          JSL     LIECOUTC
001CAF  3  B0 02                BCS     V_IECOUTPUT_IECERROR
001CB1  3  AB                   PLB
001CB2  3  60                   RTS
001CB3  3                       V_IECOUTPUT_IECERROR:
001CB3  3  AB                   PLB
001CB4  3  4C 4D 1A             JMP     IECERROR
001CB7  3               
001CB7  3               
001CB7  3               ;___V_PUTN__________________________________________________
001CB7  3               ;
001CB7  3               ; UTILIZE BIOS TO PRINT TO AN IEC IO CHANNEL
001CB7  3               ;
001CB7  3               ; STARTING WITH FILE#, OUTPUT STRING
001CB7  3               ; THIS IS NATIVE '816 CODE
001CB7  3               ;__________________________________________________________
001CB7  3               V_PUTN:
001CB7  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
001CBA  3  86 04                STX     <TMPFLG
001CBC  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
001CBF  3               
001CBF  3  20 42 33             JSR     LAB_EVEX        ; GET THE FIRST PARAMETER
001CC2  3  A5 5F                LDA     <Dtypef         ; IS IT A STRING?
001CC4  3  D0 08                BNE     V_PUTN_GO       ; YES, CONTINUE ON
001CC6  3               V_PUTN_ERR:
001CC6  3  A2 02                LDX     #$02            ; NOPE, SYNTAX ERROR
001CC8  3  20 08 28             JSR     LAB_XERR
001CCB  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
001CCE  3               V_PUTN_GO:
001CCE  3  20 55 3D             JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
001CD1  3               ; space returns with A = length, X=$71=pointer low byte,
001CD1  3               ; Y=$72=pointer high byte
001CD1  3  86 B8                STX     <ssptr_l
001CD3  3  84 B9                STY     <ssptr_h
001CD5  3  AA                   TAX
001CD6  3  A0 00                LDY     #$00
001CD8  3               V_PUTN_1:
001CD8  3  8B DA A2 01          LDAINDIRECTY ssptr_l
001CDC  3  B5 B8 C9 00  
001CE0  3  D0 04 A2 00  
001CEE  3  DA                   PHX
001CEF  3  5A                   PHY
001CF0  3  8B                   PHB
001CF1  3  DA A2 00 DA          SETBANK 0
001CF5  3  AB FA        
001CF7  3  A6 04                LDX     <TMPFLG
001CF9  3  48                   PHA
001CFA  3  22 30 FD 00          JSL     LIECOUT
001CFE  3  68                   PLA
001CFF  3  22 00 FD 00          JSL     LPRINTVEC
001D03  3  AB                   PLB
001D04  3  7A                   PLY
001D05  3  FA                   PLX
001D06  3  CA                   DEX
001D07  3  E0 00                CPX     #00
001D09  3  F0 03                BEQ     V_PUTN_2
001D0B  3  C8                   INY
001D0C  3  D0 CA                BNE     V_PUTN_1
001D0E  3               V_PUTN_2:
001D0E  3  60                   RTS
001D0F  3               
001D0F  3               
001D0F  3               
001D0F  3               ;___LAB_IECST_______________________________________________
001D0F  3               ;
001D0F  3               ; RETURN IEC STATUS BYTE
001D0F  3               ;
001D0F  3               ; THIS IS NATIVE '816 CODE
001D0F  3               ;__________________________________________________________
001D0F  3               LAB_IECST:
001D0F  3  48                   PHA
001D10  3  A5 03                LDA     >IECSTW         ; get IECSTW into low byte
001D12  3  A8                   TAY
001D13  3  68                   PLA
001D14  3  A9 00                LDA     #0              ; NO high byte
001D16  3  20 FD 38             JSR     LAB_AYFC
001D19  3  60                   RTS
001D1A  3               LAB_PIECST:
001D1A  3  46 5F                LSR     <Dtypef         ; clear data type flag, $FF=string, $00=numeric
001D1C  3  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory then do function
001D20  3  60                   RTS
001D21  3               
001D21  3               ;___V_GETN_________________________________________________
001D21  3               ;
001D21  3               ; UTILIZE BIOS TO INPUT FROM AN IEC IO CHANNEL
001D21  3               ;
001D21  3               ; LOTS OF PARAMETERS :)  STARTING WITH FILE#
001D21  3               ; THIS IS NATIVE '816 CODE
001D21  3               ;__________________________________________________________
001D21  3               V_GETN:
001D21  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
001D24  3  DA                   PHX                     ; STORE DEVICE NUMBER
001D25  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
001D28  3  20 3F 36             JSR     LAB_GVAR        ; get var address
001D2B  3  85 97                STA     <Lvarpl         ; save var address low byte
001D2D  3  84 98                STY     <Lvarph         ; save var address high byte
001D2F  3  FA                   PLX
001D30  3  8B                   PHB
001D31  3  DA A2 00 DA          SETBANK 0
001D35  3  AB FA        
001D37  3  A6 04                LDX     <TMPFLG
001D39  3  22 2C FD 00          JSL     LIECIN          ; get input byte
001D3D  3  AB                   PLB
001D3E  3               
001D3E  3  A6 5F                LDX     <Dtypef         ; get data type flag, $FF=string, $00=numeric
001D40  3  30 07                BMI     LAB_GETNS       ; go get string character
001D42  3               ; was numeric get
001D42  3  A8                   TAY                     ; copy character to Y
001D43  3  20 0A 39             JSR     LAB_1FD0        ; convert Y to byte in FAC1
001D46  3  4C 32 45             JMP     LAB_PFAC        ; pack FAC1 into variable (<Lvarpl) and return
001D49  3               LAB_GETNS:
001D49  3  48                   PHA
001D4A  3  A9 01                LDA     #$01
001D4C  3  20 6E 3A             JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
001D4F  3               ; X=$AD=<Sutill=ptr low byte, Y=$AE=<Sutilh=ptr high byte
001D4F  3  68                   PLA                     ; get character back
001D50  3  A0 00                LDY     #$00            ; clear index
001D52  3  8B DA 48 A2          STAINDIRECTY str_pl     ; save byte in string (byte IS string!)
001D56  3  01 B5 AD C9  
001D5A  3  00 D0 04 A2  
001D68  3  20 D1 3A             JSR     LAB_RTST        ; check for space on descriptor stack then put address
001D6B  3               ; and length on descriptor stack and update stack pointers
001D6B  3  4C E1 2E             JMP     LAB_17D5        ; do string LET and return
001D6E  3               
001D6E  2                       .INCLUDE "screencmds.asm"
001D6E  3               ;___SCNCLR_________________________________________________
001D6E  3               ;
001D6E  3               ; UTILIZE BIOS TO CLEAR SCREEN
001D6E  3               ;
001D6E  3               ;
001D6E  3               ; THIS IS NATIVE '816 CODE
001D6E  3               ;__________________________________________________________
001D6E  3               V_SCNCLR:
001D6E  3  8B                   PHB
001D6F  3  DA A2 00 DA          SETBANK 0
001D73  3  AB FA        
001D75  3  22 6C FD 00          JSL     LClearScrVec
001D79  3  AB                   PLB
001D7A  3  60                   RTS
001D7B  3               
001D7B  3               ;___LOCATE_________________________________________________
001D7B  3               ;
001D7B  3               ; UTILIZE BIOS TO LOCATE CURSOR
001D7B  3               ;
001D7B  3               ;  TAKES TWO PARAMETERS X,Y
001D7B  3               ;
001D7B  3               ; THIS IS NATIVE '816 CODE
001D7B  3               ;__________________________________________________________
001D7B  3               V_LOCATE:
001D7B  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
001D7E  3  DA                   PHX
001D7F  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
001D82  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (DEVICE)
001D85  3  7A                   PLY
001D86  3  8B                   PHB
001D87  3  DA A2 00 DA          SETBANK 0
001D8B  3  AB FA        
001D8D  3  22 0C FD 00          JSL     LSetXYVEC
001D91  3  AB                   PLB
001D92  3  60                   RTS
001D93  3               
001D93  3               ;___COLOR_________________________________________________
001D93  3               ;
001D93  3               ; UTILIZE BIOS TO SET COLORS
001D93  3               ;
001D93  3               ;  TAKES TWO PARAMETERS BACKGROUND,FOREGROUND
001D93  3               ;
001D93  3               ; THIS IS NATIVE '816 CODE
001D93  3               ;__________________________________________________________
001D93  3               V_COLOR:
001D93  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
001D96  3  8A                   TXA
001D97  3  29 0F                AND     #$0F
001D99  3  48                   PHA
001D9A  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
001D9D  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (DEVICE)
001DA0  3  8A                   TXA
001DA1  3  29 0F                AND     #$0F
001DA3  3  18                   CLC
001DA4  3  0A                   ASL
001DA5  3  0A                   ASL
001DA6  3  0A                   ASL
001DA7  3  0A                   ASL
001DA8  3  85 04                STA     <TMPFLG
001DAA  3  68                   PLA
001DAB  3  05 04                ORA     <TMPFLG
001DAD  3  8B                   PHB
001DAE  3  DA A2 00 DA          SETBANK 0
001DB2  3  AB FA        
001DB4  3  22 18 FD 00          JSL     LSetColorVEC
001DB8  3  AB                   PLB
001DB9  3  60                   RTS
001DBA  3               
001DBA  3               ;___V_SPEEK()______________________________________________
001DBA  3               ;
001DBA  3               ; GET VALUE FROM SCREEN MEMORY
001DBA  3               ;
001DBA  3               ;  TAKES ONE PARAMETER (ADDRESS), RETURNS VALUE
001DBA  3               ;
001DBA  3               ; THIS IS NATIVE '816 CODE
001DBA  3               ;__________________________________________________________
001DBA  3               V_SPEEK:
001DBA  3  20 82 40             JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
001DBD  3               
001DBD  3  8B                   PHB
001DBE  3  DA A2 00 DA          SETBANK 0
001DC2  3  AB FA        
001DC4  3  A2 00                LDX     #$00            ; clear index
001DC6  3  20 CE 1D             JSR     SPEEK_1
001DC9  3  AB                   PLB
001DCA  3  A8                   TAY                     ; copy byte to Y
001DCB  3  4C 0A 39             JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return
001DCE  3               
001DCE  3               SPEEK_1:
001DCE  3  A5 11                LDA     <Itempl
001DD0  3  85 FE                STA     >CMDP
001DD2  3  20 CF 22             JSR     DELAY9918
001DD5  3  A5 12                LDA     <Itemph
001DD7  3  09 40                ORA     #$40
001DD9  3  29 7F                AND     #$7F
001DDB  3  85 FE                STA     >CMDP
001DDD  3  20 CF 22             JSR     DELAY9918
001DE0  3  A5 FE                LDA     >DATAP
001DE2  3               ;       REPEATING THE READ FOR RELIABILITY (SOMETIMES ONE READ DOES NOT WORK, IF THE 9918 IS EVER REPLACED WITH A v99x8 THIS CAN BE REMOVED)
001DE2  3  A5 11                LDA     <Itempl
001DE4  3  85 FE                STA     >CMDP
001DE6  3  20 CF 22             JSR     DELAY9918
001DE9  3  A5 12                LDA     <Itemph
001DEB  3  09 40                ORA     #$40
001DED  3  29 7F                AND     #$7F
001DEF  3  85 FE                STA     >CMDP
001DF1  3  20 CF 22             JSR     DELAY9918
001DF4  3  A5 FE                LDA     >DATAP
001DF6  3  60                   RTS
001DF7  3               
001DF7  3               ;___V_SPOKE_________________________________________________
001DF7  3               ;
001DF7  3               ; PUT VALUE IN SCREEN MEMORY
001DF7  3               ;
001DF7  3               ;  TAKES TWO PARAMETERS ADDRESS,VALUE
001DF7  3               ;
001DF7  3               ; THIS IS NATIVE '816 CODE
001DF7  3               ;__________________________________________________________
001DF7  3               V_SPOKE:
001DF7  3  20 69 40             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
001DFA  3  8B                   PHB
001DFB  3  DA                   PHX                     ; SAVE byte argument
001DFC  3  DA A2 00 DA          SETBANK 0
001E00  3  AB FA        
001E02  3                                               ; Let's set VDP write address to Itemp
001E02  3  A5 11                LDA     <Itempl
001E04  3  8D 0B FE             STA     CMDP
001E07  3  20 CF 22             JSR     DELAY9918
001E0A  3  A5 12                LDA     <Itemph
001E0C  3  29 7F                AND     #$7F
001E0E  3  09 40                ORA     #$40
001E10  3  8D 0B FE             STA     CMDP
001E13  3  20 CF 22             JSR     DELAY9918
001E16  3  68                   PLA
001E17  3  8D 0A FE             STA     DATAP
001E1A  3  AB                   PLB
001E1B  3  60                   RTS
001E1C  3               
001E1C  3               ;___V_SCREEN_________________________________________________
001E1C  3               ;
001E1C  3               ;  SET SCREEN MODE
001E1C  3               ;
001E1C  3               ;  TAKES ONE PARAMETER,  SCREEN MODE
001E1C  3               ;  0=GRAPHICS MODE (32X24)
001E1C  3               ;  1=MULTICOLOR (64X48 BLOCKS)
001E1C  3               ;  2=TEXT MODE (40X24)
001E1C  3               ;  4=GRAPHICS MODE 2 (32X24 MULTICOLOR)
001E1C  3               ; THIS IS NATIVE '816 CODE
001E1C  3               ;__________________________________________________________
001E1C  3               V_SCREEN:
001E1C  3  20 0E 39             JSR     LAB_CKRN        ; check not Direct, back here if ok
001E1F  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (MODE)
001E22  3               V_SCREEN1:
001E22  3  86 06                STX     <VIDEOMODE
001E24  3  E0 00                CPX     #00
001E26  3  D0 03                BNE     *+5
001E28  3  4C 50 1E             JMP     SETUPMODE0
001E2B  3  E0 01                CPX     #01
001E2D  3  D0 03                BNE     *+5
001E2F  3  4C 78 1E             JMP     SETUPMODE1
001E32  3  E0 02                CPX     #02
001E34  3  D0 03                BNE     *+5
001E36  3  4C F7 1E             JMP     SETUPMODE2
001E39  3  E0 03                CPX     #03
001E3B  3  D0 03                BNE     *+5
001E3D  3  4C 13 1F             JMP     SETUPMODE3
001E40  3  E0 04                CPX     #04
001E42  3  D0 03                BNE     *+5
001E44  3  4C 3B 1F             JMP     SETUPMODE4
001E47  3               
001E47  3  A2 02                LDX     #$02            ; SYNTAX ERROR
001E49  3  20 08 28             JSR     LAB_XERR
001E4C  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
001E4F  3               
001E4F  3  60                   RTS
001E50  3               
001E50  3               SETUPMODE0:
001E50  3  A9 8B                LDA     #<Mode0Parameters; point to Parameters for Mode 4
001E52  3  A0 1F                LDY     #>Mode0Parameters
001E54  3  20 BD 1F             JSR     Set9918Parms
001E57  3               ;       CLEAR RAM
001E57  3  C2 10                INDEX16
001E59  3  A2 00 00             LDX     #$0000
001E5C  3  86 07                STX     <LOCALWORK
001E5E  3  E2 10                INDEX8
001E60  3  20 F3 1F             JSR     SET9918ADDRESS
001E63  3  C2 10                INDEX16
001E65  3  A2 00 40             LDX     #$4000
001E68  3  A9 00                LDA     #$00
001E6A  3               SETUPMODE0_1:
001E6A  3  20 CF 22             JSR     DELAY9918
001E6D  3  85 FE                STA     >DATAP
001E6F  3  CA                   DEX
001E70  3  E0 00 00             CPX     #$0000
001E73  3  D0 F5                BNE     SETUPMODE0_1
001E75  3  E2 10                INDEX8
001E77  3  60                   RTS
001E78  3               SETUPMODE1:
001E78  3  A9 95                LDA     #<Mode1Parameters; point to Parameters for Mode 4
001E7A  3  A0 1F                LDY     #>Mode1Parameters
001E7C  3  20 BD 1F             JSR     Set9918Parms
001E7F  3  8B                   PHB
001E80  3  DA A2 00 DA          SETBANK 0
001E84  3  AB FA        
001E86  3  A0 00                LDY     #$00
001E88  3               SETUPMODE1_1:
001E88  3  C2 20                ACCUMULATOR16
001E8A  3  98                   TYA
001E8B  3  29 FF 00             AND     #$00FF
001E8E  3  18                   CLC
001E8F  3  0A                   ASL                     ; a=y*32
001E90  3  0A                   ASL
001E91  3  0A                   ASL
001E92  3  0A                   ASL
001E93  3  0A                   ASL
001E94  3  18                   CLC
001E95  3  69 00 04             ADC     #1024
001E98  3  85 07                STA     <LOCALWORK
001E9A  3  E2 20                ACCUMULATOR8
001E9C  3  A5 07                LDA     <LOCALWORK
001E9E  3  8D 0B FE             STA     CMDP
001EA1  3  20 CF 22             JSR     DELAY9918
001EA4  3  A5 08                LDA     <LOCALWORK+1
001EA6  3  09 40                ORA     #$40
001EA8  3  29 7F                AND     #$7F
001EAA  3  8D 0B FE             STA     CMDP
001EAD  3  98                   TYA
001EAE  3  29 FC                AND     #$FC
001EB0  3  18                   CLC
001EB1  3  0A                   ASL
001EB2  3  0A                   ASL
001EB3  3  0A                   ASL
001EB4  3  85 11                STA     <Itempl
001EB6  3  A2 00                LDX     #$00
001EB8  3               SETUPMODE1_2:
001EB8  3  A5 11                LDA     <Itempl
001EBA  3  8D 0A FE             STA     DATAP
001EBD  3  20 CF 22             JSR     DELAY9918
001EC0  3  E6 11                INC     <Itempl
001EC2  3  E8                   INX
001EC3  3  E0 20                CPX     #32
001EC5  3  D0 F1                BNE     SETUPMODE1_2
001EC7  3  C8                   INY
001EC8  3  C0 18                CPY     #24
001ECA  3  D0 BC                BNE     SETUPMODE1_1
001ECC  3               ; CLEAR SCREEN
001ECC  3  C2 10                INDEX16
001ECE  3  20 CF 22             JSR     DELAY9918
001ED1  3  A9 00                LDA     #$00
001ED3  3  8D 0B FE             STA     CMDP
001ED6  3  20 CF 22             JSR     DELAY9918
001ED9  3  A2 00 00             LDX     #$0000
001EDC  3  A9 08                LDA     #$08
001EDE  3  09 40                ORA     #$40
001EE0  3  29 7F                AND     #$7F
001EE2  3  8D 0B FE             STA     CMDP
001EE5  3  A9 00                LDA     #$00
001EE7  3               SETUPMODE1_3:
001EE7  3  20 CF 22             JSR     DELAY9918
001EEA  3  8D 0A FE             STA     DATAP
001EED  3  E8                   INX
001EEE  3  E0 01 06             CPX     #$0601
001EF1  3  D0 F4                BNE     SETUPMODE1_3
001EF3  3  E2 10                INDEX8
001EF5  3  AB                   PLB
001EF6  3  60                   RTS
001EF7  3               SETUPMODE2:
001EF7  3  A9 28                LDA     #40
001EF9  3  85 03                STA     >VIDEOWIDTH
001EFB  3  A9 9F                LDA     #<Mode2Parameters; point to Parameters for Mode 4
001EFD  3  A0 1F                LDY     #>Mode2Parameters
001EFF  3  20 BD 1F             JSR     Set9918Parms
001F02  3  8B                   PHB
001F03  3  DA A2 00 DA          SETBANK 0
001F07  3  AB FA        
001F09  3  22 70 FD 00          JSL     LLOADFONTVec
001F0D  3  22 6C FD 00          JSL     LClearScrVec
001F11  3  AB                   PLB
001F12  3  60                   RTS
001F13  3               SETUPMODE3:
001F13  3  A9 A9                LDA     #<Mode3Parameters; point to Parameters for Mode 4
001F15  3  A0 1F                LDY     #>Mode3Parameters
001F17  3  20 BD 1F             JSR     Set9918Parms
001F1A  3               ;       CLEAR RAM
001F1A  3  C2 10                INDEX16
001F1C  3  A2 00 00             LDX     #$0000
001F1F  3  86 07                STX     <LOCALWORK
001F21  3  E2 10                INDEX8
001F23  3  20 F3 1F             JSR     SET9918ADDRESS
001F26  3  C2 10                INDEX16
001F28  3  A2 00 40             LDX     #$4000
001F2B  3  A9 00                LDA     #$00
001F2D  3               SETUPMODE3_1:
001F2D  3  20 CF 22             JSR     DELAY9918
001F30  3  85 FE                STA     >DATAP
001F32  3  CA                   DEX
001F33  3  E0 00 00             CPX     #$0000
001F36  3  D0 F5                BNE     SETUPMODE3_1
001F38  3  E2 10                INDEX8
001F3A  3  60                   RTS
001F3B  3               
001F3B  3               SETUPMODE4:
001F3B  3  A9 B3                LDA     #<Mode4Parameters; point to Parameters for Mode 4
001F3D  3  A0 1F                LDY     #>Mode4Parameters
001F3F  3  20 BD 1F             JSR     Set9918Parms
001F42  3  8B                   PHB
001F43  3  DA A2 00 DA          SETBANK 0
001F47  3  AB FA        
001F49  3               ;       CLEAR RAM
001F49  3  C2 10                INDEX16
001F4B  3  A2 00 00             LDX     #$0000
001F4E  3  86 07                STX     <LOCALWORK
001F50  3  E2 10                INDEX8
001F52  3  20 F3 1F             JSR     SET9918ADDRESS
001F55  3  C2 10                INDEX16
001F57  3  A2 00 40             LDX     #$4000
001F5A  3  A9 00                LDA     #$00
001F5C  3               SETUPMODE4_1:
001F5C  3  20 CF 22             JSR     DELAY9918
001F5F  3  85 FE                STA     >DATAP
001F61  3  CA                   DEX
001F62  3  E0 00 00             CPX     #$0000
001F65  3  D0 F5                BNE     SETUPMODE4_1
001F67  3  20 CF 22             JSR     DELAY9918
001F6A  3               ;       POPULATE NAME TABLE
001F6A  3  A2 00 38             LDX     #$3800
001F6D  3  86 07                STX     <LOCALWORK
001F6F  3  E2 10                INDEX8
001F71  3  20 F3 1F             JSR     SET9918ADDRESS
001F74  3  C2 10                INDEX16
001F76  3  A2 00 03             LDX     #$0300
001F79  3  A9 00                LDA     #$00
001F7B  3               SETUPMODE4_2:
001F7B  3  20 CF 22             JSR     DELAY9918
001F7E  3  85 FE                STA     >DATAP
001F80  3  1A                   INC
001F81  3  CA                   DEX
001F82  3  E0 00 00             CPX     #$0000
001F85  3  D0 F4                BNE     SETUPMODE4_2
001F87  3  E2 10                INDEX8
001F89  3  AB                   PLB
001F8A  3  60                   RTS
001F8B  3               
001F8B  3               Mode0Parameters:
001F8B  3  00 C0 05 80          .BYTE   $00,$C0,$05,$80,$01,$20,$00,$01
001F8F  3  01 20 00 01  
001F93  3  10                   .BYTE   $10             ; Sprite attribute table
001F94  3  00                   .BYTE   $00             ; Sprite Pattern Table
001F95  3               
001F95  3               Mode1Parameters:
001F95  3  00 CB 01 80          .BYTE   $00,$CB,$01,$80,$01,$0E,$00,$F1
001F99  3  01 0E 00 F1  
001F9D  3  07                   .BYTE   $07             ; Sprite attribute table
001F9E  3  00                   .BYTE   $00             ; Sprite Pattern Table
001F9F  3               
001F9F  3               Mode2Parameters:
001F9F  3  00 D0 01 80          .BYTE   $00,$D0,$01,$80,$01,$0E,$00,$F4
001FA3  3  01 0E 00 F4  
001FA7  3  07                   .BYTE   $07             ; Sprite attribute table
001FA8  3  00                   .BYTE   $00             ; Sprite Pattern Table
001FA9  3               
001FA9  3               Mode3Parameters:
001FA9  3  02 C2 0E 9F          .BYTE   $02,$C2,$0E,$9F,$00,$76,$03,$F0
001FAD  3  00 76 03 F0  
001FB1  3  3B                   .BYTE   $3b             ; Sprite attribute table
001FB2  3  18                   .BYTE   $18             ; Sprite Pattern Table
001FB3  3               
001FB3  3               Mode4Parameters:
001FB3  3  02 C2 0E FF          .BYTE   $02,$C2,$0E,$FF,$03,$76,$03,$F0
001FB7  3  03 76 03 F0  
001FBB  3  3B                   .BYTE   $3b             ; Sprite attribute table
001FBC  3  18                   .BYTE   $18             ; Sprite Pattern Table
001FBD  3               
001FBD  3               Set9918Parms:
001FBD  3               ; copy parms and set sprite table vectors
001FBD  3  85 07                STA     <LOCALWORK
001FBF  3  84 08                STY     <LOCALWORK+1
001FC1  3  A0 00                LDY     #$00
001FC3  3               Set9918Parms1:
001FC3  3  8B                   PHB
001FC4  3  DA A2 FF DA          SETBANK PROGRAMBANK
001FC8  3  AB FA        
001FCA  3  B1 07                LDA     (<LOCALWORK),Y
001FCC  3  DA A2 00 DA          SETBANK 0
001FD0  3  AB FA        
001FD2  3  85 FE                STA     >CMDP
001FD4  3  98                   TYA
001FD5  3  18                   CLC
001FD6  3  69 80                ADC     #$80
001FD8  3  85 FE                STA     >CMDP
001FDA  3  AB                   PLB
001FDB  3  C8                   INY
001FDC  3  C0 08                CPY     #$08
001FDE  3  D0 E3                BNE     Set9918Parms1
001FE0  3  18                   CLC
001FE1  3  8B                   PHB
001FE2  3  DA A2 FF DA          SETBANK PROGRAMBANK
001FE6  3  AB FA        
001FE8  3  B1 07                LDA     (<LOCALWORK),Y
001FEA  3  85 03                STA     >SpriteAttrs
001FEC  3  C8                   INY
001FED  3  B1 07                LDA     (<LOCALWORK),Y
001FEF  3  85 03                STA     >SpritePatterns
001FF1  3  AB                   PLB
001FF2  3  60                   RTS
001FF3  3               
001FF3  3               SET9918ADDRESS:
001FF3  3  A5 07                LDA     <LOCALWORK
001FF5  3  85 FE                STA     >CMDP
001FF7  3  20 CF 22             JSR     DELAY9918
001FFA  3  A5 08                LDA     <LOCALWORK+1
001FFC  3  09 40                ORA     #$40
001FFE  3  29 7F                AND     #$7F
002000  3  85 FE                STA     >CMDP
002002  3  60                   RTS
002003  3               
002003  3               
002003  3               ;___V_SPRITE________________________________________________
002003  3               ;
002003  3               ;  SET SPRITE PARAMETERS
002003  3               ;
002003  3               ;  TAKES SIX PARAMETERS
002003  3               ;       SPRITE NUM (0-32)
002003  3               ;       SPRITE PATTERN (0-255)
002003  3               ;       X CORD (0-255)
002003  3               ;       Y CORD (0-255)
002003  3               ;       COLOR  (0-15)
002003  3               ;       LEFT SHIFT BIT (0/1)
002003  3               ; THIS IS NATIVE '816 CODE
002003  3               ;__________________________________________________________
002003  3               V_SPRITE:
002003  3  8B                   PHB
002004  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (SPRITE#)
002007  3  8A                   TXA
002008  3  29 1F                AND     #$1F
00200A  3  18                   CLC
00200B  3  0A                   ASL                     ; A=A*4
00200C  3  0A                   ASL
00200D  3  85 07                STA     <LOCALWORK
00200F  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
002012  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (PATTERN)
002015  3  DA                   PHX
002016  3  20 64 34             JSR     LAB_1C01        ; GET THE THIRD PARAMETER (AFTER ',') OR SYN ERR
002019  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE THIRD PARAMETER, RETURN IN X (X CORD)
00201C  3  DA                   PHX
00201D  3  20 64 34             JSR     LAB_1C01        ; GET THE FOURTH PARAMETER (AFTER ',') OR SYN ERR
002020  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FOURTH PARAMETER, RETURN IN X (Y CORD)
002023  3  DA                   PHX
002024  3  20 64 34             JSR     LAB_1C01        ; GET THE FIFTH PARAMETER (AFTER ',') OR SYN ERR
002027  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIFTH PARAMETER, RETURN IN X (COLOR)
00202A  3  8A                   TXA
00202B  3  29 0F                AND     #$0F
00202D  3  48                   PHA
00202E  3  20 64 34             JSR     LAB_1C01        ; GET THE SIXTH PARAMETER (AFTER ',') OR SYN ERR
002031  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SIXTH PARAMETER, RETURN IN X (EARLY CLOCK)
002034  3  8A                   TXA
002035  3  29 01                AND     #01
002037  3  C9 00                CMP     #$00
002039  3  F0 04                BEQ     NOSHIFT
00203B  3  68                   PLA
00203C  3  09 80                ORA     #$80
00203E  3  48                   PHA
00203F  3               NOSHIFT:
00203F  3  DA A2 00 DA          SETBANK 0
002043  3  AB FA        
002045  3  A5 07                LDA     <LOCALWORK
002047  3  8D 0B FE             STA     CMDP
00204A  3  20 CF 22             JSR     DELAY9918
00204D  3  AD 44 03             LDA     SpriteAttrs
002050  3  09 40                ORA     #$40
002052  3  8D 0B FE             STA     CMDP
002055  3  68                   PLA                     ; COLOR
002056  3  85 07                STA     <LOCALWORK
002058  3  7A                   PLY                     ; VERTICAL POSITION
002059  3  FA                   PLX                     ; HORIZONTAL POSITION
00205A  3  68                   PLA                     ; NAME TABLE LOCATION
00205B  3  20 CF 22             JSR     DELAY9918
00205E  3  8C 0A FE             STY     DATAP
002061  3  20 CF 22             JSR     DELAY9918
002064  3  8E 0A FE             STX     DATAP
002067  3  20 CF 22             JSR     DELAY9918
00206A  3  8D 0A FE             STA     DATAP
00206D  3  20 CF 22             JSR     DELAY9918
002070  3  A5 07                LDA     <LOCALWORK
002072  3  8D 0A FE             STA     DATAP
002075  3  AB                   PLB
002076  3  60                   RTS
002077  3               
002077  3               
002077  3               ;___V_SPRDEF________________________________________________
002077  3               ;
002077  3               ;  DEFINE SPRITE PATTERN
002077  3               ;
002077  3               ;  TAKES 9 OR 17 PARAMETERS
002077  3               ;       SPRITE NUM (0-32)
002077  3               ;       SPRITE PATTERN DATA (8 BYTES OR 16 BYTES)
002077  3               ; THIS IS NATIVE '816 CODE
002077  3               ;__________________________________________________________
002077  3               V_SPRDEF:
002077  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (SPRITE#)
00207A  3  8A                   TXA
00207B  3  C2 20                ACCUMULATOR16
00207D  3  29 1F 00             AND     #$001F
002080  3  18                   CLC
002081  3  0A                   ASL                     ; A=A*8
002082  3  0A                   ASL
002083  3  0A                   ASL
002084  3  85 07                STA     <LOCALWORK
002086  3  E2 20                ACCUMULATOR8
002088  3  8B                   PHB
002089  3  DA A2 00 DA          SETBANK 0
00208D  3  AB FA        
00208F  3  A5 07                LDA     <LOCALWORK
002091  3  8D 0B FE             STA     CMDP
002094  3  20 CF 22             JSR     DELAY9918
002097  3  AD 45 03             LDA     SpritePatterns
00209A  3  18                   CLC
00209B  3  65 08                ADC     <LOCALWORK+1
00209D  3  09 40                ORA     #$40
00209F  3  8D 0B FE             STA     CMDP
0020A2  3  AB                   PLB
0020A3  3               SPRDEF_PLOOP:
0020A3  3  A9 2C                LDA     #$2C            ; load A with ","
0020A5  3  A0 00                LDY     #$00            ; clear index
0020A7  3  D1 C3                CMP     (<Bpntrl),Y     ; check next byte is ','
0020A9  3  D0 14                BNE     SPRDEF_EXIT     ; if not EXIT
0020AB  3  22 BC 00 00          JSL     LAB_IGBY        ; increment
0020AF  3  20 DE 3F             JSR     LAB_GTBY        ; GET SPRITE DATA
0020B2  3  8B                   PHB
0020B3  3  DA A2 00 DA          SETBANK 0
0020B7  3  AB FA        
0020B9  3  8E 0A FE             STX     DATAP
0020BC  3  AB                   PLB
0020BD  3  80 E4                BRA     SPRDEF_PLOOP
0020BF  3               SPRDEF_EXIT:
0020BF  3  60                   RTS
0020C0  3               
0020C0  3               
0020C0  3               ;___LAB_VIDST_______________________________________________
0020C0  3               ;
0020C0  3               ; RETURN VIDEO STATUS BYTE
0020C0  3               ;
0020C0  3               ; THIS IS NATIVE '816 CODE
0020C0  3               ;__________________________________________________________
0020C0  3               LAB_VIDST:
0020C0  3  8B                   PHB
0020C1  3  DA A2 00 DA          SETBANK 0
0020C5  3  AB FA        
0020C7  3  AD 0B FE             LDA     CMDP            ; get VIDEO ST into low byte
0020CA  3  A8                   TAY
0020CB  3  AB                   PLB
0020CC  3  A9 00                LDA     #0              ; NO high byte
0020CE  3  20 FD 38             JSR     LAB_AYFC
0020D1  3  60                   RTS
0020D2  3  46 5F                LSR     <Dtypef         ; clear data type flag, $FF=string, $00=numeric
0020D4  3  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory then do function
0020D8  3  60                   RTS
0020D9  3               LAB_PVIDST:
0020D9  3  46 5F                LSR     <Dtypef         ; clear data type flag, $FF=string, $00=numeric
0020DB  3  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory then do function
0020DF  3  60                   RTS
0020E0  3               
0020E0  3               
0020E0  3               ;___SPRSIZE_________________________________________________
0020E0  3               ;
0020E0  3               ; SET SPRITE SIZE AND MAGNIFICATION
0020E0  3               ;
0020E0  3               ;  TAKES ONE PARAMETER
0020E0  3               ;
0020E0  3               ; 0= 8X8 SPRITES, 1x DISPLAY
0020E0  3               ; 1= 8X8 SPRITES, 2X DISPLAY
0020E0  3               ; 2= 16X16 SPRITES, 1X DISPLAY
0020E0  3               ; 3= 16X16 SPRITES, 2X DISPLAY
0020E0  3               ;
0020E0  3               ; THIS IS NATIVE '816 CODE
0020E0  3               ;__________________________________________________________
0020E0  3               V_SPRSIZE:
0020E0  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (MODE)
0020E3  3  DA                   PHX
0020E4  3  A6 06                LDX     <VIDEOMODE
0020E6  3  8A                   TXA
0020E7  3  29 03                AND     #$03
0020E9  3  18                   CLC
0020EA  3  0A                   ASL
0020EB  3  0A                   ASL
0020EC  3  0A                   ASL
0020ED  3  09 C0                ORA     #$C0
0020EF  3  29 D8                AND     #$D8
0020F1  3  85 04                STA     <TMPFLG
0020F3  3  68                   PLA
0020F4  3  29 03                AND     #$03
0020F6  3  18                   CLC
0020F7  3  65 04                ADC     <TMPFLG
0020F9  3  8B                   PHB
0020FA  3  48                   PHA
0020FB  3  DA A2 00 DA          SETBANK 0
0020FF  3  AB FA        
002101  3               ;       SET Register 1
002101  3  68                   PLA
002102  3  8D 0B FE             STA     CMDP
002105  3  20 CF 22             JSR     DELAY9918
002108  3  A9 81                LDA     #$81
00210A  3  8D 0B FE             STA     CMDP
00210D  3  AB                   PLB
00210E  3  60                   RTS
00210F  3               
00210F  3               
00210F  3               
00210F  3               ;___V_PLOT__________________________________________________
00210F  3               ;
00210F  3               ;  PLOT ON SCREEN
00210F  3               ;         VM= 1     TAKES THREE PARAMETERS,  X,Y,COLOR
00210F  3               ;         VM= 4     TAKES FOUR PARAMETERS,  X,Y,PRIORITY,COLOR
00210F  3               ;         VM= 0 AND 3     TAKES THREE PARAMETERS,  X,Y,PATTERN
00210F  3               ;
00210F  3               ;  0=GRAPHICS MODE (32X24)
00210F  3               ;  1=MULTICOLOR MODE (64X48 BLOCKS)
00210F  3               ;  2=TEXT MODE (40X24)
00210F  3               ;  3=GRAPHICS MODE 0, WITH MODE 2 COLOR (32X24 MULTICOLOR)
00210F  3               ;  4=GRAPHICS MODE 2 (32X24 MULTICOLOR)
00210F  3               ; THIS IS NATIVE '816 CODE
00210F  3               ;__________________________________________________________
00210F  3               V_PLOT:
00210F  3  A5 06                LDA     <VIDEOMODE
002111  3  C9 01                CMP     #01
002113  3  D0 03                BNE     *+5
002115  3  4C 35 21             JMP     PLOT_MULTICOLOR
002118  3  C9 04                CMP     #04
00211A  3  D0 03                BNE     *+5
00211C  3  4C BA 21             JMP     PLOT_GRII
00211F  3  C9 00                CMP     #00
002121  3  D0 03                BNE     *+5
002123  3  4C 7A 22             JMP     PLOT_GRI
002126  3  C9 03                CMP     #03
002128  3  D0 03                BNE     *+5
00212A  3  4C 7A 22             JMP     PLOT_GRI
00212D  3               
00212D  3               V_PLOT_ERR:
00212D  3  A2 02                LDX     #$02            ; SYNTAX ERROR
00212F  3  20 08 28             JSR     LAB_XERR
002132  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
002135  3               PLOT_MULTICOLOR:
002135  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (X)
002138  3  DA                   PHX
002139  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
00213C  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (Y)
00213F  3  DA                   PHX
002140  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
002143  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (COLOR)
002146  3  8A                   TXA                     ; GET COLOR
002147  3  7A                   PLY                     ; GET Y COORD
002148  3  FA                   PLX                     ; GET X COORD
002149  3  8B                   PHB                     ; STASH BANK
00214A  3  48                   PHA                     ; STASH COLOR
00214B  3  5A                   PHY                     ; STASH Y COORD
00214C  3  DA A2 00 DA          SETBANK 0
002150  3  AB FA        
002152  3  C2 20                ACCUMULATOR16
002154  3                                               ; SET Y CORD = Y/8 * 32
002154  3  98                   TYA
002155  3  29 F8 00             AND     #$00F8
002158  3  18                   CLC
002159  3  0A                   ASL
00215A  3  0A                   ASL
00215B  3  0A                   ASL
00215C  3  0A                   ASL
00215D  3  0A                   ASL
00215E  3  85 07                STA     <LOCALWORK
002160  3  7A                   PLY
002161  3  98                   TYA
002162  3  29 07 00             AND     #$0007          ; GET REMAINDER
002165  3  18                   CLC
002166  3  65 07                ADC     <LOCALWORK
002168  3  85 07                STA     <LOCALWORK      ; STASH Y PART OF ADDRESS
00216A  3  8A                   TXA
00216B  3  29 FE 00             AND     #$00FE          ;
00216E  3  18                   CLC
00216F  3  0A                   ASL
002170  3  0A                   ASL
002171  3  65 07                ADC     <LOCALWORK
002173  3  69 00 08             ADC     #2048
002176  3  85 07                STA     <LOCALWORK
002178  3  85 11                STA     <Itempl
00217A  3  E2 20                ACCUMULATOR8
00217C  3  20 CE 1D             JSR     SPEEK_1
00217F  3  20 CF 22             JSR     DELAY9918
002182  3  48                   PHA
002183  3  A5 07                LDA     <LOCALWORK
002185  3  8D 0B FE             STA     CMDP
002188  3  20 CF 22             JSR     DELAY9918
00218B  3  A5 08                LDA     <LOCALWORK+1
00218D  3  09 40                ORA     #$40
00218F  3  29 7F                AND     #$7F
002191  3  8D 0B FE             STA     CMDP
002194  3  8A                   TXA
002195  3  29 01                AND     #$01
002197  3  C9 01                CMP     #$01
002199  3  D0 0C                BNE     PLOTMODE2_HB
00219B  3  68                   PLA
00219C  3  29 F0                AND     #$F0
00219E  3  85 07                STA     <LOCALWORK
0021A0  3  68                   PLA
0021A1  3  29 0F                AND     #$0F
0021A3  3  05 07                ORA     <LOCALWORK
0021A5  3  80 0E                BRA     PLOTMODE2_GO
0021A7  3               PLOTMODE2_HB:
0021A7  3  68                   PLA
0021A8  3  29 0F                AND     #$0F
0021AA  3  85 07                STA     <LOCALWORK
0021AC  3  68                   PLA
0021AD  3  29 0F                AND     #$0F
0021AF  3  0A                   ASL
0021B0  3  0A                   ASL
0021B1  3  0A                   ASL
0021B2  3  0A                   ASL
0021B3  3  05 07                ORA     <LOCALWORK
0021B5  3               PLOTMODE2_GO:
0021B5  3  8D 0A FE             STA     DATAP
0021B8  3  AB                   PLB
0021B9  3  60                   RTS
0021BA  3               PLOT_GRII:
0021BA  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (X)
0021BD  3  DA                   PHX
0021BE  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
0021C1  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (Y)
0021C4  3  DA                   PHX
0021C5  3  20 64 34             JSR     LAB_1C01        ; GET THE THIRD PARAMETER (AFTER ',') OR SYN ERR
0021C8  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE THIRD PARAMETER, RETURN IN X (FG/BG)
0021CB  3  DA                   PHX
0021CC  3  20 64 34             JSR     LAB_1C01        ; GET THE THIRD PARAMETER (AFTER ',') OR SYN ERR
0021CF  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE THIRD PARAMETER, RETURN IN X (COLOR)
0021D2  3  86 11                STX     <Itempl         ; STASH COLOR INFO HERE
0021D4  3  FA                   PLX
0021D5  3  86 12                STX     <Itemph         ; STASH PRIORITY HERE
0021D7  3  7A                   PLY                     ; GET Y COORD
0021D8  3  FA                   PLX                     ; GET X COORD
0021D9  3  C2 20                ACCUMULATOR16
0021DB  3  98                   TYA
0021DC  3  29 F8 00             AND     #$00F8
0021DF  3  18                   CLC
0021E0  3  0A                   ASL                     ; Y COORD
0021E1  3  0A                   ASL
0021E2  3  0A                   ASL
0021E3  3  0A                   ASL
0021E4  3  0A                   ASL
0021E5  3  85 07                STA     <LOCALWORK
0021E7  3  98                   TYA
0021E8  3  29 07 00             AND     #$0007
0021EB  3  18                   CLC
0021EC  3  65 07                ADC     <LOCALWORK
0021EE  3  85 07                STA     <LOCALWORK
0021F0  3  8A                   TXA
0021F1  3  29 F8 00             AND     #$00F8
0021F4  3  18                   CLC
0021F5  3  65 07                ADC     <LOCALWORK
0021F7  3  85 07                STA     <LOCALWORK      ; BYTE OFFSET FOR COLOR AND PATTERN NOW IN LOCAL WORK
0021F9  3                                               ; FIND PATTERN
0021F9  3  8A                   TXA
0021FA  3  29 07 00             AND     #$0007
0021FD  3  18                   CLC
0021FE  3  69 72 22             ADC     #BITPATTERN
002201  3  8B                   PHB
002202  3  DA A2 FF DA          SETBANK PROGRAMBANK
002206  3  AB FA        
002208  3  C2 10                INDEX16
00220A  3  AA                   TAX
00220B  3  E2 20                ACCUMULATOR8
00220D  3  B5 00                LDA     0,x
00220F  3  AB                   PLB
002210  3  85 71                STA     <Temp_2         ; Temp_2 NOW CONTAINS THE MASK
002212  3  E2 10                INDEX8
002214  3                                               ; FIGURE PRIORITY - ZERO CLEARS BIT, NONZERO SETS BIT
002214  3  A5 11                LDA     <Itempl         ; PUT COLOR ON STACK
002216  3  48                   PHA
002217  3  A5 12                LDA     <Itemph         ; PUT PRIORITY ON STACK
002219  3  48                   PHA
00221A  3                                               ; GET EXISTING VALUE
00221A  3  C2 20                ACCUMULATOR16
00221C  3  A5 07                LDA     <LOCALWORK
00221E  3  85 11                STA     <Itempl
002220  3  E2 20                ACCUMULATOR8
002222  3  20 CE 1D             JSR     SPEEK_1
002225  3  85 11                STA     <Itempl         ; STASH VALUE HERE
002227  3  68                   PLA                     ; GET PRIORITY
002228  3  C9 00                CMP     #$00
00222A  3  D0 09                BNE     PLOT_GRII_SET
00222C  3               ; CLEAR BIT
00222C  3  A5 71                LDA     <Temp_2         ; GET MASK
00222E  3  49 FF                EOR     #$FF
002230  3  25 11                AND     <Itempl         ; VALUE TO STORE IS NOW IN A
002232  3  48                   PHA                     ; PLACE IT ON STACK
002233  3  80 05                BRA     PLOT_GRII_2
002235  3               ;SET BIT
002235  3               PLOT_GRII_SET:
002235  3  A5 71                LDA     <Temp_2         ; GET MASK
002237  3  05 11                ORA     <Itempl         ; VALUE TO STORE IS NOW IN A
002239  3  48                   PHA                     ; PLACE IT ON STACK
00223A  3               PLOT_GRII_2:
00223A  3  A5 07                LDA     <LOCALWORK      ; SET WRITE ADDRESS
00223C  3  85 FE                STA     >CMDP
00223E  3  20 CF 22             JSR     DELAY9918
002241  3  A5 08                LDA     <LOCALWORK+1
002243  3  09 40                ORA     #$40
002245  3  29 7F                AND     #$7F
002247  3  85 FE                STA     >CMDP
002249  3  20 CF 22             JSR     DELAY9918
00224C  3  68                   PLA                     ; GET MASK
00224D  3  85 FE                STA     >DATAP
00224F  3  20 CF 22             JSR     DELAY9918
002252  3               ;; NOW DO COLOR
002252  3  C2 20                ACCUMULATOR16
002254  3  A9 00 20             LDA     #$2000
002257  3  18                   CLC
002258  3  65 07                ADC     <LOCALWORK
00225A  3  85 07                STA     <LOCALWORK
00225C  3  E2 20                ACCUMULATOR8
00225E  3  A5 07                LDA     <LOCALWORK      ; SET WRITE ADDRESS
002260  3  85 FE                STA     >CMDP
002262  3  20 CF 22             JSR     DELAY9918
002265  3  A5 08                LDA     <LOCALWORK+1
002267  3  09 40                ORA     #$40
002269  3  85 FE                STA     >CMDP
00226B  3  20 CF 22             JSR     DELAY9918
00226E  3  68                   PLA                     ; GET COLOR
00226F  3  85 FE                STA     >DATAP          ; STORE COLOR
002271  3  60                   RTS
002272  3               BITPATTERN:
002272  3  80 40 20 10          .BYTE   $80,$40,$20,$10,$08,$04,$02,$01
002276  3  08 04 02 01  
00227A  3               ; GR-1 && 3 Plot
00227A  3               PLOT_GRI:
00227A  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (X)
00227D  3  DA                   PHX
00227E  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
002281  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (Y)
002284  3  DA                   PHX
002285  3  20 64 34             JSR     LAB_1C01        ; GET THE THIRD PARAMETER (AFTER ',') OR SYN ERR
002288  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE THIRD PARAMETER, RETURN IN X (PATTERN#)
00228B  3  86 12                STX     <Itemph         ; STASH PATTERN HERE
00228D  3  7A                   PLY                     ; GET Y COORD
00228E  3  FA                   PLX                     ; GET X COORD
00228F  3  C2 20                ACCUMULATOR16
002291  3  98                   TYA
002292  3  29 FF 00             AND     #$00FF
002295  3  18                   CLC
002296  3  0A                   ASL                     ; Y COORD *32
002297  3  0A                   ASL
002298  3  0A                   ASL
002299  3  0A                   ASL
00229A  3  0A                   ASL
00229B  3  85 07                STA     <LOCALWORK
00229D  3  8A                   TXA
00229E  3  29 FF 00             AND     #$00FF
0022A1  3  18                   CLC
0022A2  3  65 07                ADC     <LOCALWORK
0022A4  3  A6 06                LDX     <VIDEOMODE
0022A6  3  E0 00                CPX     #$00
0022A8  3  F0 06                BEQ     PLOT_GRI_A
0022AA  3  18                   CLC
0022AB  3  69 00 38             ADC     #$3800          ; LOCALWORK CONTAINS NAMETABLE ADDRESS VM=3
0022AE  3  80 04                BRA     PLOT_GRI_B
0022B0  3               PLOT_GRI_A:
0022B0  3  18                   CLC
0022B1  3  69 00 14             ADC     #$1400          ; LOCALWORK CONTAINS NAMETABLE ADDRESS VM=0
0022B4  3               PLOT_GRI_B:
0022B4  3  85 07                STA     <LOCALWORK
0022B6  3  E2 20                ACCUMULATOR8
0022B8  3  A5 07                LDA     <LOCALWORK      ; SET PATTERN WRITE ADDRESS
0022BA  3  85 FE                STA     >CMDP
0022BC  3  20 CF 22             JSR     DELAY9918
0022BF  3  A5 08                LDA     <LOCALWORK+1
0022C1  3  09 40                ORA     #$40
0022C3  3  29 7F                AND     #$7F
0022C5  3  85 FE                STA     >CMDP
0022C7  3  20 CF 22             JSR     DELAY9918
0022CA  3  A5 12                LDA     <Itemph         ; GET PATTERN
0022CC  3  85 FE                STA     >DATAP          ; STORE PATTERN
0022CE  3  60                   RTS
0022CF  3               
0022CF  3               DELAY9918:
0022CF  3  48                   PHA
0022D0  3  48                   PHA                     ; MIGHT BE POSSIBLE TO REDUCE DELAY
0022D1  3  68                   PLA
0022D2  3  48                   PHA
0022D3  3  68                   PLA
0022D4  3  48                   PHA
0022D5  3  68                   PLA
0022D6  3  48                   PHA
0022D7  3  68                   PLA
0022D8  3  48                   PHA
0022D9  3  68                   PLA
0022DA  3  48                   PHA
0022DB  3  68                   PLA
0022DC  3  48                   PHA
0022DD  3  68                   PLA
0022DE  3  68                   PLA
0022DF  3  60                   RTS
0022E0  3               
0022E0  3               ;___V_PATTERN________________________________________________
0022E0  3               ;
0022E0  3               ;  DEFINE GGRAPHICS PATTERN
0022E0  3               ;
0022E0  3               ;  TAKES 10 PARAMETERS
0022E0  3               ;       PATTERN NUM (0-255)
0022E0  3               ;       COLOR NUM (0-255)
0022E0  3               ;       PATTERN DATA (8 BYTES)
0022E0  3               ; THIS IS NATIVE '816 CODE
0022E0  3               ;__________________________________________________________
0022E0  3               V_PATTERN:
0022E0  3  A5 06                LDA     <VIDEOMODE
0022E2  3  C9 03                CMP     #03
0022E4  3  F0 6F                BEQ     V_PATTERN3GO
0022E6  3  C9 00                CMP     #00
0022E8  3  F0 08                BEQ     V_PATTERNGO
0022EA  3               ; IF NOT IN MODE 0 OR MODE 3, SYNTAX ERROR
0022EA  3  A2 02                LDX     #$02            ; SYNTAX ERROR
0022EC  3  20 08 28             JSR     LAB_XERR        ;
0022EF  3  4C F9 28             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
0022F2  3                                               ;
0022F2  3               V_PATTERNGO:
0022F2  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (PATTERN#)
0022F5  3  8A                   TXA
0022F6  3  C2 20                ACCUMULATOR16
0022F8  3  29 FF 00             AND     #$00FF
0022FB  3  48                   PHA
0022FC  3  18                   CLC
0022FD  3  0A                   ASL                     ; A=A*8
0022FE  3  0A                   ASL
0022FF  3  0A                   ASL
002300  3  18                   CLC
002301  3  69 00 08             ADC     #$0800
002304  3  85 07                STA     <LOCALWORK
002306  3  E2 20                ACCUMULATOR8
002308  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
00230B  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (COLOR)
00230E  3  DA                   PHX
00230F  3  A5 07                LDA     <LOCALWORK
002311  3  85 FE                STA     >CMDP
002313  3  20 CF 22             JSR     DELAY9918
002316  3  A5 08                LDA     <LOCALWORK+1
002318  3  09 40                ORA     #$40
00231A  3  85 FE                STA     >CMDP
00231C  3               V_PATTERN_PLOOP:
00231C  3  A9 2C                LDA     #$2C            ; load A with ","
00231E  3  A0 00                LDY     #$00            ; clear index
002320  3  D1 C3                CMP     (<Bpntrl),Y     ; check next byte is ','
002322  3  D0 0C                BNE     V_PATTERN_EXIT  ; if not EXIT
002324  3  22 BC 00 00          JSL     LAB_IGBY        ; increment
002328  3  20 DE 3F             JSR     LAB_GTBY        ; GET PATTERN DATA
00232B  3  8A                   TXA
00232C  3  85 FE                STA     >DATAP
00232E  3  80 EC                BRA     V_PATTERN_PLOOP
002330  3               V_PATTERN_EXIT:
002330  3               ; DO COLOR
002330  3  FA                   PLX
002331  3  C2 20                ACCUMULATOR16
002333  3  68                   PLA
002334  3  4A                   LSR
002335  3  4A                   LSR
002336  3  4A                   LSR
002337  3  4A                   LSR
002338  3  4A                   LSR
002339  3  18                   CLC
00233A  3  69 00 20             ADC     #$2000
00233D  3  85 07                STA     <LOCALWORK
00233F  3  E2 20                ACCUMULATOR8
002341  3  A5 07                LDA     <LOCALWORK
002343  3  85 FE                STA     >CMDP
002345  3  20 CF 22             JSR     DELAY9918
002348  3  A5 08                LDA     <LOCALWORK+1
00234A  3  09 40                ORA     #$40
00234C  3  85 FE                STA     >CMDP
00234E  3  20 CF 22             JSR     DELAY9918
002351  3  8A                   TXA
002352  3  85 FE                STA     >DATAP
002354  3  60                   RTS
002355  3               
002355  3               
002355  3               V_PATTERN3GO:
002355  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (PATTERN#)
002358  3  8A                   TXA
002359  3  C2 20                ACCUMULATOR16
00235B  3  29 FF 00             AND     #$00FF
00235E  3  18                   CLC
00235F  3  0A                   ASL                     ; A=A*8
002360  3  0A                   ASL
002361  3  0A                   ASL
002362  3  85 07                STA     <LOCALWORK
002364  3  E2 20                ACCUMULATOR8
002366  3  A5 07                LDA     <LOCALWORK
002368  3  85 FE                STA     >CMDP
00236A  3  20 CF 22             JSR     DELAY9918
00236D  3  A5 08                LDA     <LOCALWORK+1
00236F  3  09 40                ORA     #$40
002371  3  85 FE                STA     >CMDP
002373  3  A0 08                LDY     #$08
002375  3               V_PATTERN3_PLOOP:
002375  3  C0 00                CPY     #$00
002377  3  F0 0E                BEQ     V_PATTERN3_EXIT
002379  3  88                   DEY
00237A  3  5A                   PHY
00237B  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
00237E  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (PATTERN#)
002381  3  7A                   PLY
002382  3  8A                   TXA
002383  3  85 FE                STA     >DATAP
002385  3  80 EE                BRA     V_PATTERN3_PLOOP
002387  3               V_PATTERN3_EXIT:
002387  3               ; DO COLOR
002387  3  A5 07                LDA     <LOCALWORK
002389  3  85 FE                STA     >CMDP
00238B  3  20 CF 22             JSR     DELAY9918
00238E  3  A5 08                LDA     <LOCALWORK+1
002390  3  18                   CLC
002391  3  69 20                ADC     #$20
002393  3  09 40                ORA     #$40
002395  3  85 FE                STA     >CMDP
002397  3  A0 08                LDY     #$08
002399  3               V_PATTERN3a_PLOOP:
002399  3  C0 00                CPY     #$00
00239B  3  F0 0E                BEQ     V_PATTERN3a_EXIT
00239D  3  88                   DEY
00239E  3  5A                   PHY
00239F  3  20 64 34             JSR     LAB_1C01        ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
0023A2  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (PATTERN#)
0023A5  3  7A                   PLY
0023A6  3  8A                   TXA
0023A7  3  85 FE                STA     >DATAP
0023A9  3  80 EE                BRA     V_PATTERN3a_PLOOP
0023AB  3               V_PATTERN3a_EXIT:
0023AB  3  60                   RTS
0023AC  3               
0023AC  2                       .INCLUDE "ay38910.asm"
0023AC  3               via1regb        = $FE10         ; Register
0023AC  3               via1rega        = $FE11         ; Register
0023AC  3               via1ddrb        = $FE12         ; Register
0023AC  3               via1ddra        = $FE13         ; Register
0023AC  3               via1t1cl        = $FE14         ; Register
0023AC  3               via1t1ch        = $FE15         ; Register
0023AC  3               via1t1ll        = $FE16         ; Register
0023AC  3               via1t1lh        = $FE17         ; Register
0023AC  3               via1t2cl        = $FE18         ; Register
0023AC  3               via1t2ch        = $FE19         ; Register
0023AC  3               via1sr          = $FE1A         ; Register
0023AC  3               via1acr         = $FE1B         ; Register
0023AC  3               via1pcr         = $FE1C         ; Register
0023AC  3               via1ifr         = $FE1D         ; Register
0023AC  3               via1ier         = $FE1E         ; Register
0023AC  3               via1ora         = $FE1F         ; Register
0023AC  3               
0023AC  3               
0023AC  3               
0023AC  3               ;___SOUND__________________________________________________
0023AC  3               ;
0023AC  3               ; PLAY SOUND
0023AC  3               ;
0023AC  3               ;  TAKES TWO PARAMETERS CHANNEL,FREQUENCY
0023AC  3               ;
0023AC  3               ; THIS IS NATIVE '816 CODE
0023AC  3               ;__________________________________________________________
0023AC  3               V_SOUND:
0023AC  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
0023AF  3  DA                   PHX
0023B0  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
0023B3  3  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
0023B6  3               ; else do type mismatch
0023B6  3  20 82 40             JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
0023B9  3               
0023B9  3  68                   PLA                     ; LIMIT THE CHANNELS TO <3
0023BA  3  29 03                AND     #$03
0023BC  3  18                   CLC
0023BD  3  0A                   ASL                     ; = *2
0023BE  3  48                   PHA
0023BF  3  A4 11                LDY     <Itempl
0023C1  3  20 C4 24             JSR     psgwr           ; SET LOW BYTE
0023C4  3  68                   PLA
0023C5  3  1A                   INC     A
0023C6  3  A4 12                LDY     <Itemph
0023C8  3  20 C4 24             JSR     psgwr           ; SET HIGH BYTE
0023CB  3  60                   RTS
0023CC  3               
0023CC  3               ;___VOLUME__________________________________________________
0023CC  3               ;
0023CC  3               ; SET VOLUME
0023CC  3               ;
0023CC  3               ;  TAKES TWO PARAMETERS CHANNEL,VOLUME
0023CC  3               ;
0023CC  3               ; THIS IS NATIVE '816 CODE
0023CC  3               ;__________________________________________________________
0023CC  3               V_VOLUME:
0023CC  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
0023CF  3  DA                   PHX
0023D0  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
0023D3  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (VOLUME)
0023D6  3  9B                   TXY
0023D7  3  68                   PLA                     ; LIMIT THE CHANNELS TO <3
0023D8  3  29 03                AND     #$03
0023DA  3               
0023DA  3  18                   CLC
0023DB  3  69 08                ADC     #08
0023DD  3  20 C4 24             JSR     psgwr
0023E0  3  60                   RTS
0023E1  3               
0023E1  3               
0023E1  3               ;___VOICE__________________________________________________
0023E1  3               ;
0023E1  3               ; SET VOICE
0023E1  3               ;
0023E1  3               ;  TAKES TWO PARAMETERS VOICE, ENVELOPE
0023E1  3               ;
0023E1  3               ; THIS IS NATIVE '816 CODE
0023E1  3               ;__________________________________________________________
0023E1  3               V_VOICE:
0023E1  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
0023E4  3  DA                   PHX
0023E5  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
0023E8  3  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
0023EB  3               ; else do type mismatch
0023EB  3  20 82 40             JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
0023EE  3  7A                   PLY
0023EF  3  A9 0D                LDA     #13
0023F1  3  20 C4 24             JSR     psgwr
0023F4  3               
0023F4  3  A9 0B                LDA     #11
0023F6  3  A4 11                LDY     <Itempl
0023F8  3  20 C4 24             JSR     psgwr           ; SET LOW BYTE
0023FB  3  A9 0C                LDA     #12
0023FD  3  A4 12                LDY     <Itemph         ; SET HIGH BYTE
0023FF  3  20 C4 24             JSR     psgwr
002402  3               
002402  3  60                   RTS
002403  3               
002403  3               
002403  3               
002403  3               
002403  3               
002403  3               ;___NOISE__________________________________________________
002403  3               ;
002403  3               ; SELECT NOISE CHANNEL
002403  3               ;
002403  3               ;  TAKES TWO PARAMETERS CHANNEL,FREQUENCY
002403  3               ;
002403  3               ; THIS IS NATIVE '816 CODE
002403  3               ;__________________________________________________________
002403  3               V_NOISE:
002403  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
002406  3  DA                   PHX
002407  3  20 64 34             JSR     LAB_1C01        ; (AFTER ',') OR SYN ERR
00240A  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE SECOND PARAMETER, RETURN IN X (FREQ)
00240D  3  68                   PLA                     ; LIMIT THE CHANNELS TO <3
00240E  3  DA                   PHX
00240F  3  AA                   TAX
002410  3               
002410  3  29 1F                AND     #%00011111
002412  3  A8                   TAY
002413  3  A9 06                LDA     #$06
002415  3  20 C4 24             JSR     psgwr           ; SET NOISE FREQ
002418  3               
002418  3  A9 07                LDA     #$07
00241A  3  20 9C 24             JSR     psgrd           ; GET CONFIG
00241D  3  68                   PLA
00241E  3  5A                   PHY
00241F  3  29 03                AND     #$03
002421  3  AA                   TAX                     ; A=CONFIG, X=CHANNEL
002422  3  68                   PLA
002423  3  E0 00                CPX     #$00
002425  3  D0 06                BNE     NOISE_1
002427  3  29 37                AND     #%00110111
002429  3  09 01                ORA     #%00000001
00242B  3  80 0E                BRA     NOISE_3
00242D  3               NOISE_1:
00242D  3  E0 01                CPX     #$01
00242F  3  D0 06                BNE     NOISE_2
002431  3  29 2F                AND     #%00101111
002433  3  09 02                ORA     #%00000010
002435  3  80 04                BRA     NOISE_3
002437  3               NOISE_2:
002437  3  29 1F                AND     #%00011111
002439  3  09 04                ORA     #%00000100
00243B  3               NOISE_3:
00243B  3  A8                   TAY
00243C  3  A9 07                LDA     #$07
00243E  3  20 C4 24             JSR     psgwr           ; SET LOW BYTE
002441  3  60                   RTS
002442  3               
002442  3               ;___TONE___________________________________________________
002442  3               ;
002442  3               ; SELECT TONE CHANNEL
002442  3               ;
002442  3               ;  TAKES ONE PARAMETER CHANNEL
002442  3               ;
002442  3               ; THIS IS NATIVE '816 CODE
002442  3               ;__________________________________________________________
002442  3               V_TONE:
002442  3  20 DE 3F             JSR     LAB_GTBY        ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
002445  3  DA                   PHX
002446  3               
002446  3  A9 07                LDA     #$07
002448  3  20 9C 24             JSR     psgrd           ; GET CONFIG
00244B  3  68                   PLA
00244C  3  5A                   PHY
00244D  3  29 03                AND     #$03
00244F  3  AA                   TAX                     ; A=CONFIG, X=CHANNEL
002450  3  68                   PLA
002451  3  E0 00                CPX     #$00
002453  3  D0 06                BNE     TONE_1
002455  3  29 3E                AND     #%00111110
002457  3  09 08                ORA     #%00001000
002459  3  80 0E                BRA     TONE_3
00245B  3               TONE_1:
00245B  3  E0 01                CPX     #$01
00245D  3  D0 06                BNE     TONE_2
00245F  3  29 3D                AND     #%00111101
002461  3  09 10                ORA     #%00010000
002463  3  80 04                BRA     TONE_3
002465  3               TONE_2:
002465  3  29 3B                AND     #%00111011
002467  3  09 20                ORA     #%00100000
002469  3               TONE_3:
002469  3  A8                   TAY
00246A  3  A9 07                LDA     #$07
00246C  3  20 C4 24             JSR     psgwr           ; SET LOW BYTE
00246F  3  60                   RTS
002470  3               
002470  3               
002470  3               ;___CONTROLLER_______________________________________________
002470  3               ;
002470  3               ; GET JOYTICK STATUS
002470  3               ;
002470  3               ;  TAKES ONE PARAMETERS JOYSTICK#, RETURNS STATUS
002470  3               ;
002470  3               ; THIS IS NATIVE '816 CODE
002470  3               ;__________________________________________________________
002470  3               LAB_CON:
002470  3  20 82 40             JSR     LAB_F2FX        ; GET THE PARAMETER, RETURN IN X (controller#)
002473  3  A5 11                LDA     <Itempl
002475  3  29 01                AND     #$01
002477  3  18                   CLC
002478  3  69 0E                ADC     #14
00247A  3  20 9C 24             JSR     psgrd           ; return value in y
00247D  3  4C 0A 39             JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return
002480  3               
002480  3               
002480  3               
002480  3               
002480  3               ;___utility functions____________________________________________
002480  3               psginit:
002480  3  A9 9C                LDA     #%10011100
002482  3  85 FE                STA     >via1ddra
002484  3  A9 10                LDA     #%00010000
002486  3  85 FE                STA     >via1rega
002488  3  A9 FF                LDA     #$FF
00248A  3  85 FE                STA     >via1ddrb
00248C  3  A9 00                LDA     #$00
00248E  3  85 FE                STA     >via1regb
002490  3  60                   RTS
002491  3  20 EA 24             JSR     clrpsg
002494  3               
002494  3  A9 07                LDA     #7
002496  3  A0 3F                LDY     #$3F
002498  3  20 C4 24             JSR     psgwr
00249B  3  60                   RTS
00249C  3               
00249C  3               psgrd:
00249C  3  85 FE                STA     >via1regb       ; select register
00249E  3  A9 1C                LDA     #%00011100      ; latch address
0024A0  3  85 FE                STA     >via1rega
0024A2  3               
0024A2  3  85 FE                STA     >via1rega
0024A4  3  85 FE                STA     >via1rega
0024A6  3               
0024A6  3  A9 10                LDA     #%00010000      ; inact
0024A8  3  85 FE                STA     >via1rega
0024AA  3               
0024AA  3  85 FE                STA     >via1rega
0024AC  3               
0024AC  3  A9 00                LDA     #$00
0024AE  3  85 FE                STA     >via1ddrb
0024B0  3  A9 18                LDA     #%00011000      ; latch data
0024B2  3  85 FE                STA     >via1rega
0024B4  3               
0024B4  3  85 FE                STA     >via1rega
0024B6  3  85 FE                STA     >via1rega
0024B8  3               
0024B8  3  A5 FE                LDA     >via1regb       ; get data
0024BA  3  A8                   TAY
0024BB  3  A9 FF                LDA     #$FF
0024BD  3  85 FE                STA     >via1ddrb
0024BF  3  A9 10                LDA     #%00010000      ; inact
0024C1  3  85 FE                STA     >via1rega
0024C3  3  60                   RTS
0024C4  3               
0024C4  3               
0024C4  3               psgwr:
0024C4  3  85 FE                STA     >via1regb       ; select register
0024C6  3  A9 1C                LDA     #%00011100      ; latch address
0024C8  3  85 FE                STA     >via1rega
0024CA  3               
0024CA  3  85 FE                STA     >via1rega
0024CC  3  85 FE                STA     >via1rega
0024CE  3               
0024CE  3  A9 10                LDA     #%00010000      ; inact
0024D0  3  85 FE                STA     >via1rega
0024D2  3               
0024D2  3  85 FE                STA     >via1rega
0024D4  3  85 FE                STA     >via1rega
0024D6  3  98                   TYA
0024D7  3  85 FE                STA     >via1regb       ; store data
0024D9  3               
0024D9  3  85 FE                STA     >via1regb       ; store data
0024DB  3  85 FE                STA     >via1regb       ; store data
0024DD  3               
0024DD  3  A9 14                LDA     #%00010100      ; latch data
0024DF  3  85 FE                STA     >via1rega
0024E1  3               
0024E1  3  85 FE                STA     >via1rega
0024E3  3  85 FE                STA     >via1rega
0024E5  3               
0024E5  3  A9 10                LDA     #%00010000      ; inact
0024E7  3  85 FE                STA     >via1rega
0024E9  3  60                   RTS
0024EA  3               
0024EA  3               ;
0024EA  3               ; Clear PSG registers to default
0024EA  3               ;
0024EA  3               clrpsg:
0024EA  3  DA 5A 48 08          STORECONTEXT
0024EE  3  E2 30                ACCUMULATORINDEX8
0024F0  3  A2 00                LDX     #00
0024F2  3  A0 00                LDY     #00
0024F4  3               clrpsg1:
0024F4  3  8A                   TXA
0024F5  3  20 C4 24             JSR     psgwr           ; set register X to 0
0024F8  3  E8                   INX
0024F9  3  E0 11                CPX     #17
0024FB  3  D0 F7                BNE     clrpsg1
0024FD  3  28 68 7A FA          RESTORECONTEXT
002501  3  60                   RTS
002502  3               
002502  2               
002502  2               
002502  2               
002502  2               ;___TitleScreen_____________________________________________
002502  2               ;
002502  2               ; Basic Title Screen
002502  2               ;
002502  2               ; THIS IS NATIVE '816 CODE
002502  2               ;__________________________________________________________
002502  2               TitleScreen:
002502  2  20 80 24             JSR     psginit
002505  2  A9 28                LDA     #40
002507  2  85 03                STA     >VIDEOWIDTH
002509  2  A9 02                LDA     #2
00250B  2  85 06                STA     <VIDEOMODE
00250D  2  A5 03                LDA     >ConsoleDevice
00250F  2  C9 00                CMP     #$00
002511  2  D0 08                BNE     TitleScreen_1
002513  2  A9 4B                LDA     #<LAB_SMSG1     ; point to sign-on message (low addr)
002515  2  A0 16                LDY     #>LAB_SMSG1     ; point to sign-on message (high addr)
002517  2  20 CA 30             JSR     LAB_18C3        ; print null terminated string from memory
00251A  2  60                   RTS
00251B  2               TitleScreen_1:
00251B  2  A2 02                LDX     #02
00251D  2  20 22 1E             JSR     V_SCREEN1
002520  2  8B                   PHB
002521  2  DA A2 00 DA          SETBANK 0
002525  2  AB FA        
002527  2  A9 F4                LDA     #$F4
002529  2  22 18 FD 00          JSL     LSetColorVEC
00252D  2  A2 00                LDX     #$00
00252F  2  9B                   TXY
002530  2  22 0C FD 00          JSL     LSetXYVEC
002534  2  AB                   PLB
002535  2  A9 F8                LDA     #<LAB_CONMSG    ; point to sign-on message (low addr)
002537  2  A0 15                LDY     #>LAB_CONMSG    ; point to sign-on message (high addr)
002539  2  20 CA 30             JSR     LAB_18C3        ; print null terminated string from memory
00253C  2  60                   RTS
00253D  2               
00253D  2               ;___ScreenEditor____________________________________________
00253D  2               ;
00253D  2               ; Basic Screen editor code
00253D  2               ;
00253D  2               ; THIS IS NATIVE '816 CODE
00253D  2               ;__________________________________________________________
00253D  2               ScreenEditor:
00253D  2  48                   PHA
00253E  2  DA                   PHX
00253F  2  5A                   PHY
002540  2  08                   PHP
002541  2  E2 30                ACCUMULATORINDEX8
002543  2  8B                   PHB
002544  2  DA A2 00 DA          SETBANK 0
002548  2  AB FA        
00254A  2               ; allow prepopulate of screen
00254A  2               ploop:
00254A  2  22 1C FD 00          JSL     LCURSORVEC
00254E  2  22 08 FD 00          JSL     LINPWVEC
002552  2  C9 FF                CMP     #$FF
002554  2  F0 F4                BEQ     ploop
002556  2  22 20 FD 00          JSL     LUNCURSORVEC
00255A  2  C9 01                CMP     #01
00255C  2  F0 19                BEQ     crsrup
00255E  2  C9 02                CMP     #02
002560  2  F0 21                BEQ     crsrdn
002562  2  C9 1F                CMP     #$1f
002564  2  F0 43                BEQ     crsrlt
002566  2  C9 04                CMP     #$04
002568  2  F0 5E                BEQ     crsrrt
00256A  2  48                   PHA
00256B  2  22 00 FD 00          JSL     LPRINTVEC
00256F  2  68                   PLA
002570  2  C9 0D                CMP     #13
002572  2  F0 68                BEQ     pexit
002574  2  4C 4A 25             JMP     ploop
002577  2               
002577  2               crsrup:
002577  2  AD 31 03             LDA     CSRY
00257A  2  C9 00                CMP     #00
00257C  2  F0 CC                BEQ     ploop
00257E  2  CE 31 03             DEC     CSRY
002581  2  80 C7                BRA     ploop
002583  2               crsrdn:
002583  2  AD 31 03             LDA     CSRY
002586  2  C9 17                CMP     #23
002588  2  F0 05                BEQ     crsrdn_1
00258A  2  EE 31 03             INC     CSRY
00258D  2  80 BB                BRA     ploop
00258F  2               crsrdn_1:
00258F  2  AD 30 03             LDA     CSRX
002592  2  48                   PHA
002593  2  A9 28                LDA     #40
002595  2  A2 00                LDX     #0
002597  2  A0 17                LDY     #23
002599  2  8E 30 03             STX     CSRX
00259C  2  8C 31 03             STY     CSRY
00259F  2  22 14 FD 00          JSL     LSrlUpVEC
0025A3  2  68                   PLA
0025A4  2  8D 30 03             STA     CSRX
0025A7  2  80 A1                BRA     ploop
0025A9  2               crsrlt:
0025A9  2  AD 30 03             LDA     CSRX
0025AC  2  C9 00                CMP     #00
0025AE  2  F0 06                BEQ     crsrlt_1
0025B0  2  CE 30 03             DEC     CSRX
0025B3  2  4C 4A 25             JMP     ploop
0025B6  2               crsrlt_1:
0025B6  2  AD 31 03             LDA     CSRY
0025B9  2  C9 00                CMP     #00
0025BB  2  F0 8D                BEQ     ploop
0025BD  2  A9 27                LDA     #39
0025BF  2  8D 30 03             STA     CSRX
0025C2  2  CE 31 03             DEC     CSRY
0025C5  2  4C 4A 25             JMP     ploop
0025C8  2               crsrrt:
0025C8  2  AD 30 03             LDA     CSRX
0025CB  2  C9 27                CMP     #39
0025CD  2  F0 06                BEQ     crsrrt_1
0025CF  2  EE 30 03             INC     CSRX
0025D2  2  4C 4A 25             JMP     ploop
0025D5  2               crsrrt_1:
0025D5  2  A9 00                LDA     #00
0025D7  2  8D 30 03             STA     CSRX
0025DA  2  80 A7                BRA     crsrdn
0025DC  2               pexit:
0025DC  2  20 00 26             JSR     LdKbBuffer
0025DF  2               
0025DF  2  A2 51                LDX     #81
0025E1  2  A9 00                LDA     #$00
0025E3  2  95 21                STA     >LIbuffs,X
0025E5  2               TERMLOOP:
0025E5  2  CA                   DEX
0025E6  2  B5 21                LDA     >LIbuffs,X
0025E8  2  C9 20                CMP     #32
0025EA  2  F0 06                BEQ     TERMLOOP_B
0025EC  2  C9 00                CMP     #00
0025EE  2  F0 06                BEQ     TERMLOOP_C
0025F0  2  80 08                BRA     TERMLOOP_A
0025F2  2               TERMLOOP_B:
0025F2  2  A9 00                LDA     #00
0025F4  2  95 21                STA     >LIbuffs,X
0025F6  2               TERMLOOP_C:
0025F6  2  E0 00                CPX     #00
0025F8  2  D0 EB                BNE     TERMLOOP
0025FA  2               TERMLOOP_A:
0025FA  2               
0025FA  2  AB                   PLB
0025FB  2  28                   PLP
0025FC  2  7A                   PLY
0025FD  2  FA                   PLX
0025FE  2  68                   PLA
0025FF  2  60                   RTS
002600  2               
002600  2               
002600  2               LdKbBuffer:
002600  2  AD 30 03             LDA     CSRX
002603  2  48                   PHA
002604  2  AD 31 03             LDA     CSRY
002607  2  48                   PHA
002608  2               ; clear input buffer
002608  2  A2 51                LDX     #81
00260A  2               clloop:
00260A  2  A9 00                LDA     #00
00260C  2  95 20                STA     >LIbuffs-1,X
00260E  2  CA                   DEX
00260F  2  D0 F9                BNE     clloop
002611  2               
002611  2               ; are we on the first line?  If so, we know it is not a continue
002611  2  AC 31 03             LDY     CSRY
002614  2  88                   DEY
002615  2  C0 00                CPY     #$00
002617  2  F0 0D                BEQ     LdKbBuffer_1
002619  2               ; if prior line linked  set y-1
002619  2  BB                   TYX
00261A  2  BD D0 03             LDA     LINEFLGS,X
00261D  2  C9 00                CMP     #$00
00261F  2  F0 05                BEQ     LdKbBuffer_1
002621  2  88                   DEY
002622  2  A9 51                LDA     #81             ; get 80 chars
002624  2  80 15                BRA     LdKbBuffer_1b
002626  2               ; get chars; 40 if last line char=32, 80 if not
002626  2               
002626  2               LdKbBuffer_1:
002626  2               ; is this the last line on the screen?
002626  2  C0 17                CPY     #23
002628  2  F0 0F                BEQ     LdKbBuffer_1a
00262A  2               ; if current line linked carries to the next set size to 80
00262A  2  BB                   TYX
00262B  2  BD D1 03             LDA     LINEFLGS+1,X
00262E  2  C9 00                CMP     #$00
002630  2  F0 07                BEQ     LdKbBuffer_1a
002632  2  68                   PLA
002633  2  1A                   INC     A
002634  2  48                   PHA
002635  2  A9 51                LDA     #81             ; get 80 chars
002637  2  80 02                BRA     LdKbBuffer_1b
002639  2               LdKbBuffer_1a:
002639  2  A9 29                LDA     #41             ; get 40 chars
00263B  2               LdKbBuffer_1b:
00263B  2  A2 00                LDX     #0
00263D  2  22 0C FD 00          JSL     LSetXYVEC
002641  2  A8                   TAY
002642  2               LdKbBuffer_2:
002642  2  20 CF 22             JSR     DELAY9918
002645  2  AD 0A FE             LDA     DATAP
002648  2  95 20                STA     >LIbuffs-1,X
00264A  2  E8                   INX
00264B  2  88                   DEY
00264C  2  C0 00                CPY     #00
00264E  2  D0 F2                BNE     LdKbBuffer_2
002650  2  7A                   PLY
002651  2  8C 31 03             STY     CSRY
002654  2  68                   PLA
002655  2  8D 30 03             STA     CSRX
002658  2  C0 18                CPY     #24
00265A  2  D0 0A                BNE     LdKbBuffer_3
00265C  2  88                   DEY
00265D  2  8C 31 03             STY     CSRY
002660  2  A9 28                LDA     #40
002662  2  22 14 FD 00          JSL     LSrlUpVEC
002666  2               LdKbBuffer_3:
002666  2  60                   RTS
002667  2               
002667  2               ;___LAB_MONITOR_____________________________________________
002667  2               ;
002667  2               ; UTILIZE BIOS TO GO TO MONITOR
002667  2               ;
002667  2               ;
002667  2               ; THIS IS NATIVE '816 CODE
002667  2               ;__________________________________________________________
002667  2               LAB_MONITOR:
002667  2  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
002668  2  18                   CLC                     ;
002669  2  FB                   XCE                     ; SET NATIVE MODE
00266A  2  DA A2 00 DA          SETBANK 0
00266E  2  AB FA        
002670  2  C2 30                ACCUMULATORINDEX16
002672  2  A9 FF DF             LDA     #STACK          ; get the stack address
002675  2  1B                   TCS                     ; and set the stack to it
002676  2  5C 00 80 00          JML     $008000
00267A  2               
00267A  1               ;
00267A  1               ;____________________________________________________________________________________________
00267A  1               
00267A  1               
00267A  1               ;   ensure CPU Context is in a known state
00267A  1  EA                   NOP                     ; FIX A CODE PAGE ALIGNMENT PROBLEM
00267B  1               BASICBEGIN:
00267B  1               
00267B  1  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
00267C  1  18                   CLC                     ;
00267D  1  FB                   XCE                     ; SET NATIVE MODE
00267E  1  C2 30                ACCUMULATORINDEX16
002680  1  A9 FF DF             LDA     #STACK          ; get the stack address
002683  1  1B                   TCS                     ; and set the stack to it
002684  1  A9 00 00             LDA     #$0000          ;
002687  1  48                   PHA                     ; Set Direct Register to 0
002688  1  2B                   PLD                     ;
002689  1               
002689  1                       .IF     PROGRAMBANK=DATABANK
002689  1               
002689  1                       .ELSE
002689  1  A2 00 10                 LDX     #$1000
00268C  1  A0 00 10                 LDY     #$1000
00268F  1  A9 00 10                 LDA     #$1000
002692  1  54 00 00                 MVN     PROGRAMBANK,DATABANK; COPY TABLES $1000 THROUGH $2000 PLUS OR MINUS :) TO WORKING BANK
002695  1                       .ENDIF
002695  1  E2 30                ACCUMULATORINDEX8
002697  1  A9 FF                LDA     #PROGRAMBANK    ; SET DATA BANK = TO PROGRAM BANK TO ALLOW FOR INITIALIZATION FROM ROM
002699  1  48                   PHA
00269A  1  AB                   PLB                     ;
00269B  1               
00269B  1               
00269B  1               
00269B  1               LAB_COLD:
00269B  1  A2 04                LDX     #PG2_TABE-PG2_TABS-1
00269D  1               ; byte count-1
00269D  1               LAB_2D13:
00269D  1  BD 33 10             LDA     PG2_TABS,X      ; get byte
0026A0  1  A0 00                LDY     #00             ; SET DATA BANK = TO ZERO BANK
0026A2  1  5A                   PHY
0026A3  1  AB                   PLB                     ;
0026A4  1  95 02                STA     >ccflag,X       ; store in page 2
0026A6  1  A0 FF                LDY     #PROGRAMBANK    ; SET DATA BANK = TO PROGRAM BANK TO ALLOW FOR INITIALIZATION FROM ROM
0026A8  1  5A                   PHY
0026A9  1  AB                   PLB                     ;
0026AA  1               
0026AA  1  CA                   DEX                     ; decrement count
0026AB  1  10 F0                BPL     LAB_2D13        ; loop if not done
0026AD  1               
0026AD  1  A2 FF                LDX     #$FF            ; set byte
0026AF  1  86 88                STX     <Clineh         ; set current line high byte (set immediate mode)
0026B1  1               
0026B1  1  A9 4C                LDA     #$4C            ; code for JMP
0026B3  1  85 A1                STA     <Fnxjmp         ; save for jump vector for functions
0026B5  1               
0026B5  1               ; copy block from LAB_2CEE to $00BC - $00E0
0026B5  1               
0026B5  1  A0 1D                LDY     #LAB_2CEE_END-LAB_2CEE; set byte count
0026B7  1               LAB_2D4E:
0026B7  1  BE 02 10             LDX     LAB_2CEE-1,Y    ; get byte from table
0026BA  1  96 BB                STX     <LAB_IGBY-1,Y   ; save byte in page zero
0026BC  1  88                   DEY                     ; decrement count
0026BD  1  D0 F8                BNE     LAB_2D4E        ; loop if not all done
0026BF  1               
0026BF  1               ; copy block from StrTab to $0000 - $0012
0026BF  1               
0026BF  1               LAB_GMEM:
0026BF  1  A0 12                LDY     #EndTab-StrTab-1; set byte count-1
0026C1  1               TabLoop:
0026C1  1  BE 20 10             LDX     StrTab,Y        ; get byte from table
0026C4  1  96 00                STX     <PLUS_0,Y       ; save byte in page zero
0026C6  1  88                   DEY                     ; decrement count
0026C7  1  10 F8                BPL     TabLoop         ; loop if not all done
0026C9  1               
0026C9  1               ; DO TITLE SCREEN
0026C9  1  20 02 25             JSR     TitleScreen
0026CC  1               
0026CC  1               
0026CC  1               ; set-up start values
0026CC  1  A9 02                LDA     #DATABANK       ; SET DATA BANK = TO DATA BANK, ALL PROGRAM DATA IN THIS AREA
0026CE  1  85 C5                STA     <Bpntrp         ; SET LAB_GBYT PAGE POINTER TO DATA BANK
0026D0  1  48                   PHA
0026D1  1  AB                   PLB
0026D2  1  A9 02                LDA     #2              ;
0026D4  1  85 06                STA     <VIDEOMODE
0026D6  1  A9 00                LDA     #$00            ; clear A
0026D8  1  85 E5                STA     <NmiBase        ; clear NMI handler enabled flag
0026DA  1  85 E8                STA     <IrqBase        ; clear IRQ handler enabled flag
0026DC  1  85 B2                STA     <FAC1_o         ; clear FAC1 overflow byte
0026DE  1  85 67                STA     <last_sh        ; clear descriptor stack top item pointer high byte
0026E0  1               
0026E0  1  A9 0E                LDA     #$0E            ; set default tab size
0026E2  1  85 64                STA     <TabSiz         ; save it
0026E4  1  A9 03                LDA     #$03            ; set garbage collect step size for descriptor stack
0026E6  1  85 A0                STA     <g_step         ; save it
0026E8  1  A2 68                LDX     #<des_sk        ; descriptor stack start
0026EA  1  86 65                STX     <next_s         ; set descriptor stack pointer
0026EC  1  20 82 30             JSR     LAB_CRLF        ; print CR/LF
0026EF  1               
0026EF  1  A9 00                LDA     #<Ram_top
0026F1  1  A0 FF                LDY     #>Ram_top
0026F3  1  85 85                STA     <Ememl          ; set end of mem low byte
0026F5  1  84 86                STY     <Ememh          ; set end of mem high byte
0026F7  1  85 81                STA     <Sstorl         ; set bottom of string space low byte
0026F9  1  84 82                STY     <Sstorh         ; set bottom of string space high byte
0026FB  1               
0026FB  1  A0 00                LDY     #<Ram_base      ; set start addr low byte
0026FD  1  A2 22                LDX     #>Ram_base      ; set start addr high byte
0026FF  1  84 79                STY     <Smeml          ; save start of mem low byte
002701  1  86 7A                STX     <Smemh          ; save start of mem high byte
002703  1               
002703  1  98                   TYA                     ; clear A
002704  1  91 79                STA     (<Smeml),Y      ; clear first byte
002706  1  E6 79                INC     <Smeml          ; increment start of mem low byte
002708  1               LAB_2E05:
002708  1  20 82 30             JSR     LAB_CRLF        ; print CR/LF
00270B  1  20 44 2A             JSR     LAB_1463        ; do "NEW" and "CLEAR"
00270E  1  A5 85                LDA     <Ememl          ; get end of mem low byte
002710  1  38                   SEC                     ; set carry for subtract
002711  1  E5 79                SBC     <Smeml          ; subtract start of mem low byte
002713  1  AA                   TAX                     ; copy to X
002714  1  A5 86                LDA     <Ememh          ; get end of mem high byte
002716  1  E5 7A                SBC     <Smemh          ; subtract start of mem high byte
002718  1  20 E3 47             JSR     LAB_295E        ; print XA as unsigned integer (bytes free)
00271B  1  A9 3F                LDA     #<LAB_SMSG      ; point to sign-on message (low addr)
00271D  1  A0 16                LDY     #>LAB_SMSG      ; point to sign-on message (high addr)
00271F  1  20 CA 30             JSR     LAB_18C3        ; print null terminated string from memory
002722  1  A9 33                LDA     #<LAB_1274      ; warm start vector low byte
002724  1  A0 28                LDY     #>LAB_1274      ; warm start vector high byte
002726  1  85 01                STA     <Wrmjpl         ; save warm start vector low byte
002728  1  84 02                STY     <Wrmjph         ; save warm start vector high byte
00272A  1  6C 01 00             JMP     (Wrmjpl)        ; go do warm start
00272D  1               
00272D  1               ; open up space in memory
00272D  1               ; move (<Ostrtl)-(<Obendl) to new block ending at (<Nbendl)
00272D  1               
00272D  1               ; <Nbendl,<Nbendh - new block end address (A/Y)
00272D  1               ; <Obendl,<Obendh - old block end address
00272D  1               ; <Ostrtl,<Ostrth - old block start address
00272D  1               
00272D  1               ; returns with ..
00272D  1               
00272D  1               ; <Nbendl,<Nbendh - new block start address (high byte - $100)
00272D  1               ; <Obendl,<Obendh - old block start address (high byte - $100)
00272D  1               ; <Ostrtl,<Ostrth - old block start address (unchanged)
00272D  1               
00272D  1               LAB_11CF:
00272D  1  20 D7 27             JSR     LAB_121F        ; check available memory, "Out of memory" error if no room
002730  1               ; addr to check is in AY (low/high)
002730  1  85 7F                STA     <Earryl         ; save new array mem end low byte
002732  1  84 80                STY     <Earryh         ; save new array mem end high byte
002734  1               
002734  1               ; open up space in memory
002734  1               ; move (<Ostrtl)-(<Obendl) to new block ending at (<Nbendl)
002734  1               ; don't set array end
002734  1               
002734  1               LAB_11D6:
002734  1  38                   SEC                     ; set carry for subtract
002735  1  A5 A6                LDA     <Obendl         ; get block end low byte
002737  1  E5 AA                SBC     <Ostrtl         ; subtract block start low byte
002739  1  A8                   TAY                     ; copy MOD(block length/$100) byte to Y
00273A  1  A5 A7                LDA     <Obendh         ; get block end high byte
00273C  1  E5 AB                SBC     <Ostrth         ; subtract block start high byte
00273E  1  AA                   TAX                     ; copy block length high byte to X
00273F  1  E8                   INX                     ; +1 to allow for count=0 exit
002740  1  98                   TYA                     ; copy block length low byte to A
002741  1  F0 74                BEQ     LAB_120A        ; branch if length low byte=0
002743  1               
002743  1               ; block is (X-1)*256+Y bytes, do the Y bytes first
002743  1               
002743  1  38                   SEC                     ; set carry for add + 1, two's complement
002744  1  49 FF                EOR     #$FF            ; invert low byte for subtract
002746  1  65 A6                ADC     <Obendl         ; add block end low byte
002748  1               
002748  1  85 A6                STA     <Obendl         ; save corrected old block end low byte
00274A  1  B0 03                BCS     LAB_11F3        ; branch if no underflow
00274C  1               
00274C  1  C6 A7                DEC     <Obendh         ; else decrement block end high byte
00274E  1  38                   SEC                     ; set carry for add + 1, two's complement
00274F  1               LAB_11F3:
00274F  1  98                   TYA                     ; get MOD(block length/$100) byte
002750  1  49 FF                EOR     #$FF            ; invert low byte for subtract
002752  1  65 A4                ADC     <Nbendl         ; add destination end low byte
002754  1  85 A4                STA     <Nbendl         ; save modified new block end low byte
002756  1  B0 30                BCS     LAB_1203        ; branch if no underflow
002758  1               
002758  1  C6 A5                DEC     <Nbendh         ; else decrement block end high byte
00275A  1  90 2C                BCC     LAB_1203        ; branch always
00275C  1               
00275C  1               LAB_11FF:
00275C  1  8B DA A2 01          LDAINDIRECTY Obendl     ; get byte from source
002760  1  B5 A6 C9 00  
002764  1  D0 04 A2 00  
002772  1  8B DA 48 A2          STAINDIRECTY Nbendl     ; copy byte to destination
002776  1  01 B5 A4 C9  
00277A  1  00 D0 04 A2  
002788  1               LAB_1203:
002788  1  88                   DEY                     ; decrement index
002789  1  D0 D1                BNE     LAB_11FF        ; loop until Y=0
00278B  1               
00278B  1               ; now do Y=0 indexed byte
00278B  1  8B DA A2 01          LDAINDIRECTY Obendl     ; get byte from source
00278F  1  B5 A6 C9 00  
002793  1  D0 04 A2 00  
0027A1  1  8B DA 48 A2          STAINDIRECTY Nbendl     ; save byte to destination
0027A5  1  01 B5 A4 C9  
0027A9  1  00 D0 04 A2  
0027B7  1               LAB_120A:
0027B7  1  C6 A7                DEC     <Obendh         ; decrement source pointer high byte
0027B9  1  C6 A5                DEC     <Nbendh         ; decrement destination pointer high byte
0027BB  1  CA                   DEX                     ; decrement block count
0027BC  1  D0 CA                BNE     LAB_1203        ; loop until count = $0
0027BE  1               
0027BE  1  60                   RTS
0027BF  1               
0027BF  1               ; check room on stack for A bytes
0027BF  1               ; stack too deep? do OM error
0027BF  1               LAB_1212:
0027BF  1  C2 20                ACCUMULATOR16
0027C1  1  29 FF 00             AND     #$00FF
0027C4  1  18                   CLC
0027C5  1  69 00 D0             ADC     #STACK_BOTTOM
0027C8  1  85 FD                STA     <TEMPW
0027CA  1  3B                   TSC
0027CB  1  C5 FD                CMP     <TEMPW
0027CD  1  90 03                BCC     LAB_1213        ; if stack < limit do "Out of memory" error then warm start
0027CF  1  E2 20                ACCUMULATOR8
0027D1  1  60                   RTS
0027D2  1               LAB_1213:
0027D2  1  E2 20                ACCUMULATOR8
0027D4  1  4C 06 28             JMP     LAB_OMER
0027D7  1               
0027D7  1               ; check available memory, "Out of memory" error if no room
0027D7  1               ; addr to check is in AY (low/high)
0027D7  1               
0027D7  1               LAB_121F:
0027D7  1  C4 82                CPY     <Sstorh         ; compare bottom of string mem high byte
0027D9  1  90 2A                BCC     LAB_124B        ; if less then exit (is ok)
0027DB  1               
0027DB  1  D0 04                BNE     LAB_1229        ; skip next test if greater (tested <)
0027DD  1               
0027DD  1               ; high byte was =, now do low byte
0027DD  1  C5 81                CMP     <Sstorl         ; compare with bottom of string mem low byte
0027DF  1  90 24                BCC     LAB_124B        ; if less then exit (is ok)
0027E1  1               
0027E1  1               ; addr is > string storage ptr (oops!)
0027E1  1               LAB_1229:
0027E1  1  48                   PHA                     ; push addr low byte
0027E2  1  A2 08                LDX     #$08            ; set index to save <Adatal to <expneg inclusive
0027E4  1  98                   TYA                     ; copy addr high byte (to push on stack)
0027E5  1               
0027E5  1               ; save misc numeric work area
0027E5  1               LAB_122D:
0027E5  1  48                   PHA                     ; push byte
0027E6  1  B5 A3                LDA     <Adatal-1,X     ; get byte from <Adatal to <expneg ( ,$00 not pushed)
0027E8  1  CA                   DEX                     ; decrement index
0027E9  1  10 FA                BPL     LAB_122D        ; loop until all done
0027EB  1               
0027EB  1  20 2B 3B             JSR     LAB_GARB        ; garbage collection routine
0027EE  1               
0027EE  1               ; restore misc numeric work area
0027EE  1  A2 00                LDX     #$00            ; clear the index to restore bytes
0027F0  1               LAB_1238:
0027F0  1  68                   PLA                     ; pop byte
0027F1  1  95 A4                STA     <Adatal,X       ; save byte to <Adatal to <expneg
0027F3  1  E8                   INX                     ; increment index
0027F4  1  E0 08                CPX     #$08            ; compare with end + 1
0027F6  1  30 F8                BMI     LAB_1238        ; loop if more to do
0027F8  1               
0027F8  1  68                   PLA                     ; pop addr high byte
0027F9  1  A8                   TAY                     ; copy back to Y
0027FA  1  68                   PLA                     ; pop addr low byte
0027FB  1  C4 82                CPY     <Sstorh         ; compare bottom of string mem high byte
0027FD  1  90 06                BCC     LAB_124B        ; if less then exit (is ok)
0027FF  1               
0027FF  1  D0 05                BNE     LAB_OMER        ; if greater do "Out of memory" error then warm start
002801  1               
002801  1               ; high byte was =, now do low byte
002801  1  C5 81                CMP     <Sstorl         ; compare with bottom of string mem low byte
002803  1  B0 01                BCS     LAB_OMER        ; if >= do "Out of memory" error then warm start
002805  1               
002805  1               ; ok exit, carry clear
002805  1               LAB_124B:
002805  1  60                   RTS
002806  1               
002806  1               ; do "Out of memory" error then warm start
002806  1               
002806  1               LAB_OMER:
002806  1  A2 0C                LDX     #$0C            ; error code $0C ("Out of memory" error)
002808  1               
002808  1               ; do error #X, then warm start
002808  1               
002808  1               LAB_XERR:
002808  1  20 82 30             JSR     LAB_CRLF        ; print CR/LF
00280B  1               
00280B  1  A5 06                LDA     <VIDEOMODE
00280D  1  C9 02                CMP     #2
00280F  1  F0 07                BEQ     LAB_XERRA
002811  1  DA                   PHX
002812  1  A2 02                LDX     #2
002814  1  20 22 1E             JSR     V_SCREEN1
002817  1  FA                   PLX
002818  1               LAB_XERRA:
002818  1  BD 8D 16             LDA     LAB_BAER,X      ; get error message pointer low byte
00281B  1  BC 8E 16             LDY     LAB_BAER+1,X    ; get error message pointer high byte
00281E  1  20 CA 30             JSR     LAB_18C3        ; print null terminated string from memory
002821  1               
002821  1  20 7D 2A             JSR     LAB_1491        ; flush stack and clear continue flag
002824  1  A9 CA                LDA     #<LAB_EMSG      ; point to " Error" low addr
002826  1  A0 17                LDY     #>LAB_EMSG      ; point to " Error" high addr
002828  1               LAB_1269:
002828  1  20 CA 30             JSR     LAB_18C3        ; print null terminated string from memory
00282B  1  A4 88                LDY     <Clineh         ; get current line high byte
00282D  1  C8                   INY                     ; increment it
00282E  1  F0 03                BEQ     LAB_1274        ; go do warm start (was immediate mode)
002830  1               
002830  1               ; else print line number
002830  1  20 D8 47             JSR     LAB_2953        ; print " in line [LINE #]"
002833  1               
002833  1               ; BASIC warm start entry point
002833  1               ; wait for Basic command
002833  1               
002833  1               LAB_1274:
002833  1  A5 06                LDA     <VIDEOMODE
002835  1  C9 02                CMP     #2
002837  1  F0 05                BEQ     LAB_1274a
002839  1  A2 02                LDX     #2
00283B  1  20 22 1E             JSR     V_SCREEN1
00283E  1               LAB_1274a:
00283E  1               ; clear ON IRQ/NMI bytes
00283E  1  A9 00                LDA     #$00            ; clear A
002840  1  85 E8                STA     <IrqBase        ; clear enabled byte
002842  1  85 E5                STA     <NmiBase        ; clear enabled byte
002844  1  A9 DB                LDA     #<LAB_RMSG      ; point to "Ready" message low byte
002846  1  A0 17                LDY     #>LAB_RMSG      ; point to "Ready" message high byte
002848  1               
002848  1  20 CA 30             JSR     LAB_18C3        ; go do print string
00284B  1               
00284B  1               ; wait for Basic command (no "Ready")
00284B  1               
00284B  1               LAB_127D:
00284B  1  20 30 29             JSR     LAB_1357        ; call for BASIC input
00284E  1               LAB_1280:
00284E  1  86 C3                STX     <Bpntrl         ; set BASIC execute pointer low byte
002850  1  84 C4                STY     <Bpntrh         ; set BASIC execute pointer high byte
002852  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002856  1  F0 F3                BEQ     LAB_127D        ; loop while null
002858  1               
002858  1               ; got to interpret input line now ..
002858  1               
002858  1  A2 FF                LDX     #$FF            ; current line to null value
00285A  1  86 88                STX     <Clineh         ; set current line high byte
00285C  1  90 06                BCC     LAB_1295        ; branch if numeric character (handle new BASIC line)
00285E  1               
00285E  1               ; no line number .. immediate mode
00285E  1  20 6F 29             JSR     LAB_13A6        ; crunch keywords into Basic tokens
002861  1  4C F2 2B             JMP     LAB_15F6        ; go scan and interpret code
002864  1               
002864  1               ; handle new BASIC line
002864  1               
002864  1               LAB_1295:
002864  1  20 63 2E             JSR     LAB_GFPN        ; get fixed-point number into temp integer
002867  1  20 6F 29             JSR     LAB_13A6        ; crunch keywords into Basic tokens
00286A  1  84 5D                STY     <Ibptr          ; save index pointer to end of crunched line
00286C  1  20 18 2A             JSR     LAB_SSLN        ; search BASIC for temp integer line number
00286F  1  90 44                BCC     LAB_12E6        ; branch if not found
002871  1               
002871  1               ; aroooogah! line # already exists! delete it
002871  1  A0 01                LDY     #$01            ; set index to next line pointer high byte
002873  1  B1 AA                LDA     (<Baslnl),Y     ; get next line pointer high byte
002875  1  85 72                STA     <ut1_ph         ; save it
002877  1  A5 7B                LDA     <Svarl          ; get start of vars low byte
002879  1  85 71                STA     <ut1_pl         ; save it
00287B  1  A5 AB                LDA     <Baslnh         ; get found line pointer high byte
00287D  1  85 74                STA     <ut2_ph         ; save it
00287F  1  A5 AA                LDA     <Baslnl         ; get found line pointer low byte
002881  1  88                   DEY                     ; decrement index
002882  1  F1 AA                SBC     (<Baslnl),Y     ; subtract next line pointer low byte
002884  1  18                   CLC                     ; clear carry for add
002885  1  65 7B                ADC     <Svarl          ; add start of vars low byte
002887  1  85 7B                STA     <Svarl          ; save new start of vars low byte
002889  1  85 73                STA     <ut2_pl         ; save destination pointer low byte
00288B  1  A5 7C                LDA     <Svarh          ; get start of vars high byte
00288D  1  69 FF                ADC     #$FF            ; -1 + carry
00288F  1  85 7C                STA     <Svarh          ; save start of vars high byte
002891  1  E5 AB                SBC     <Baslnh         ; subtract found line pointer high byte
002893  1  AA                   TAX                     ; copy to block count
002894  1  38                   SEC                     ; set carry for subtract
002895  1  A5 AA                LDA     <Baslnl         ; get found line pointer low byte
002897  1  E5 7B                SBC     <Svarl          ; subtract start of vars low byte
002899  1  A8                   TAY                     ; copy to bytes in first block count
00289A  1  B0 03                BCS     LAB_12D0        ; branch if overflow
00289C  1               
00289C  1  E8                   INX                     ; increment block count (correct for =0 loop exit)
00289D  1  C6 74                DEC     <ut2_ph         ; decrement destination high byte
00289F  1               LAB_12D0:
00289F  1  18                   CLC                     ; clear carry for add
0028A0  1  65 71                ADC     <ut1_pl         ; add source pointer low byte
0028A2  1  90 03                BCC     LAB_12D8        ; branch if no overflow
0028A4  1               
0028A4  1  C6 72                DEC     <ut1_ph         ; else decrement source pointer high byte
0028A6  1  18                   CLC                     ; clear carry
0028A7  1               
0028A7  1               ; close up memory to delete old line
0028A7  1               LAB_12D8:
0028A7  1  B1 71                LDA     (<ut1_pl),Y     ; get byte from source
0028A9  1  91 73                STA     (<ut2_pl),Y     ; copy to destination
0028AB  1  C8                   INY                     ; increment index
0028AC  1  D0 F9                BNE     LAB_12D8        ; while <> 0 do this block
0028AE  1               
0028AE  1  E6 72                INC     <ut1_ph         ; increment source pointer high byte
0028B0  1  E6 74                INC     <ut2_ph         ; increment destination pointer high byte
0028B2  1  CA                   DEX                     ; decrement block count
0028B3  1  D0 F2                BNE     LAB_12D8        ; loop until all done
0028B5  1               
0028B5  1               ; got new line in buffer and no existing same #
0028B5  1               LAB_12E6:
0028B5  1  AD 81 21             LDA     Ibuffs          ; get byte from start of input buffer
0028B8  1  F0 3F                BEQ     LAB_1319        ; if null line just go flush stack/vars and exit
0028BA  1               
0028BA  1               ; got new line and it isn't empty line
0028BA  1  A5 85                LDA     <Ememl          ; get end of mem low byte
0028BC  1  A4 86                LDY     <Ememh          ; get end of mem high byte
0028BE  1  85 81                STA     <Sstorl         ; set bottom of string space low byte
0028C0  1  84 82                STY     <Sstorh         ; set bottom of string space high byte
0028C2  1  A5 7B                LDA     <Svarl          ; get start of vars low byte	(end of BASIC)
0028C4  1  85 A6                STA     <Obendl         ; save old block end low byte
0028C6  1  A4 7C                LDY     <Svarh          ; get start of vars high byte	(end of BASIC)
0028C8  1  84 A7                STY     <Obendh         ; save old block end high byte
0028CA  1  65 5D                ADC     <Ibptr          ; add input buffer pointer	(also buffer length)
0028CC  1  90 01                BCC     LAB_1301        ; branch if no overflow from add
0028CE  1               
0028CE  1  C8                   INY                     ; else increment high byte
0028CF  1               LAB_1301:
0028CF  1  85 A4                STA     <Nbendl         ; save new block end low byte	(move to, low byte)
0028D1  1  84 A5                STY     <Nbendh         ; save new block end high byte
0028D3  1  20 2D 27             JSR     LAB_11CF        ; open up space in memory
0028D6  1               ; old start pointer <Ostrtl,<Ostrth set by the find line call
0028D6  1  A5 7F                LDA     <Earryl         ; get array mem end low byte
0028D8  1  A4 80                LDY     <Earryh         ; get array mem end high byte
0028DA  1  85 7B                STA     <Svarl          ; save start of vars low byte
0028DC  1  84 7C                STY     <Svarh          ; save start of vars high byte
0028DE  1  A4 5D                LDY     <Ibptr          ; get input buffer pointer	(also buffer length)
0028E0  1  88                   DEY                     ; adjust for loop type
0028E1  1               LAB_1311:
0028E1  1  B9 7D 21             LDA     Ibuffs-4,Y      ; get byte from crunched line
0028E4  1  91 AA                STA     (<Baslnl),Y     ; save it to program memory
0028E6  1  88                   DEY                     ; decrement count
0028E7  1  C0 03                CPY     #$03            ; compare with first byte-1
0028E9  1  D0 F6                BNE     LAB_1311        ; continue while count <> 3
0028EB  1               
0028EB  1  A5 12                LDA     <Itemph         ; get line # high byte
0028ED  1  91 AA                STA     (<Baslnl),Y     ; save it to program memory
0028EF  1  88                   DEY                     ; decrement count
0028F0  1  A5 11                LDA     <Itempl         ; get line # low byte
0028F2  1  91 AA                STA     (<Baslnl),Y     ; save it to program memory
0028F4  1  88                   DEY                     ; decrement count
0028F5  1  A9 FF                LDA     #$FF            ; set byte to allow chain rebuild. if you didn't set this
0028F7  1               ; byte then a zero already here would stop the chain rebuild
0028F7  1               ; as it would think it was the [EOT] marker.
0028F7  1  91 AA                STA     (<Baslnl),Y     ; save it to program memory
0028F9  1               
0028F9  1               LAB_1319:
0028F9  1  20 59 2A             JSR     LAB_1477        ; reset execution to start, clear vars and flush stack
0028FC  1  A6 79                LDX     <Smeml          ; get start of mem low byte
0028FE  1  A5 7A                LDA     <Smemh          ; get start of mem high byte
002900  1  A0 01                LDY     #$01            ; index to high byte of next line pointer
002902  1               LAB_1325:
002902  1  86 71                STX     <ut1_pl         ; set line start pointer low byte
002904  1  85 72                STA     <ut1_ph         ; set line start pointer high byte
002906  1  B1 71                LDA     (<ut1_pl),Y     ; get it
002908  1  F0 18                BEQ     LAB_133E        ; exit if end of program
00290A  1               
00290A  1               ; rebuild chaining of Basic lines
00290A  1               
00290A  1  A0 04                LDY     #$04            ; point to first code byte of line
00290C  1               ; there is always 1 byte + [EOL] as null entries are deleted
00290C  1               LAB_1330:
00290C  1  C8                   INY                     ; next code byte
00290D  1  B1 71                LDA     (<ut1_pl),Y     ; get byte
00290F  1  D0 FB                BNE     LAB_1330        ; loop if not [EOL]
002911  1               
002911  1  38                   SEC                     ; set carry for add + 1
002912  1  98                   TYA                     ; copy end index
002913  1  65 71                ADC     <ut1_pl         ; add to line start pointer low byte
002915  1  AA                   TAX                     ; copy to X
002916  1  A0 00                LDY     #$00            ; clear index, point to this line's next line pointer
002918  1  91 71                STA     (<ut1_pl),Y     ; set next line pointer low byte
00291A  1  98                   TYA                     ; clear A
00291B  1  65 72                ADC     <ut1_ph         ; add line start pointer high byte + carry
00291D  1  C8                   INY                     ; increment index to high byte
00291E  1  91 71                STA     (<ut1_pl),Y     ; save next line pointer low byte
002920  1  90 E0                BCC     LAB_1325        ; go do next line, branch always, carry clear
002922  1               
002922  1               
002922  1               LAB_133E:
002922  1  4C 4B 28             JMP     LAB_127D        ; else we just wait for Basic command, no "Ready"
002925  1               
002925  1               ; print "? " and get BASIC input
002925  1               
002925  1               LAB_INLN:
002925  1               ;JSR	LAB_18E3		; print "?" character
002925  1  20 F3 30             JSR     LAB_18E0        ; print " "
002928  1  D0 16                BNE     SimpleSerialEditor; call for BASIC input and return
00292A  1               
00292A  1               ; receive line from keyboard
00292A  1               
00292A  1               ; $08 as delete key (BACKSPACE on standard keyboard)
00292A  1               LAB_134B:
00292A  1  20 F8 30             JSR     LAB_PRNA        ; go print the character
00292D  1  CA                   DEX                     ; decrement the buffer counter (delete)
00292E  1  80 12                BRA     LAB_1359
002930  1               
002930  1               ; call for BASIC input (main entry point)
002930  1               LAB_1357:
002930  1  A5 03                LDA     >ConsoleDevice
002932  1  C9 00                CMP     #$00
002934  1  F0 0A                BEQ     SimpleSerialEditor
002936  1               ;	do screen editor
002936  1  20 3D 25             JSR     ScreenEditor
002939  1  A2 81                LDX     #<Ibuffs        ; set X to buffer start-1 low byte
00293B  1  A0 21                LDY     #>Ibuffs        ; set Y to buffer start-1 high byte
00293D  1  A9 00                LDA     #$00
00293F  1  60                   RTS
002940  1               
002940  1               SimpleSerialEditor:
002940  1  A2 00                LDX     #$00            ; clear BASIC line buffer pointer
002942  1               LAB_1359:
002942  1  20 C1 18             JSR     V_INPT          ; call scan input device
002945  1  B0 FB                BCS     LAB_1359        ; loop if no byte
002947  1               ;BEQ	LAB_1359		; loop until valid input (ignore NULLs)
002947  1               
002947  1  C9 07                CMP     #$07            ; compare with [BELL]
002949  1  F0 10                BEQ     LAB_1378        ; branch if [BELL]
00294B  1               
00294B  1  C9 0D                CMP     #$0D            ; compare with [CR]
00294D  1  F0 19                BEQ     LAB_1384        ; do CR/LF exit if [CR]
00294F  1               
00294F  1  E0 00                CPX     #$00            ; compare pointer with $00
002951  1  D0 04                BNE     LAB_1374        ; branch if not empty
002953  1               
002953  1               ; next two lines ignore any non print character and [SPACE] if input buffer empty
002953  1               
002953  1  C9 21                CMP     #$21            ; compare with [SP]+1
002955  1  90 EB                BCC     LAB_1359        ; if < ignore character
002957  1               
002957  1               LAB_1374:
002957  1  C9 08                CMP     #$08            ; compare with [BACKSPACE] (delete last character)
002959  1  F0 CF                BEQ     LAB_134B        ; go delete last character
00295B  1               
00295B  1               LAB_1378:
00295B  1  E0 50                CPX     #Ibuffe-Ibuffs  ; compare character count with max
00295D  1  B0 0C                BCS     LAB_138E        ; skip store and do [BELL] if buffer full
00295F  1               
00295F  1  9D 81 21             STA     Ibuffs,X        ; else store in buffer
002962  1  E8                   INX                     ; increment pointer
002963  1               LAB_137F:
002963  1  20 F8 30             JSR     LAB_PRNA        ; go print the character
002966  1  D0 DA                BNE     LAB_1359        ; always loop for next character
002968  1               
002968  1               LAB_1384:
002968  1  4C 79 30             JMP     LAB_1866        ; do CR/LF exit to BASIC
00296B  1               
00296B  1               ; announce buffer full
00296B  1               
00296B  1               LAB_138E:
00296B  1  A9 07                LDA     #$07            ; [BELL] character into A
00296D  1  D0 F4                BNE     LAB_137F        ; go print the [BELL] but ignore input character
00296F  1               ; branch always
00296F  1               
00296F  1               ; crunch keywords into Basic tokens
00296F  1               ; position independent buffer version ..
00296F  1               ; faster, dictionary search version ....
00296F  1               
00296F  1               LAB_13A6:
00296F  1  A0 FF                LDY     #$FF            ; set save index (makes for easy math later)
002971  1               
002971  1  38                   SEC                     ; set carry for subtract
002972  1  A5 C3                LDA     <Bpntrl         ; get basic execute pointer low byte
002974  1  E9 81                SBC     #<Ibuffs        ; subtract input buffer start pointer
002976  1  AA                   TAX                     ; copy result to X (index past line # if any)
002977  1               
002977  1  86 60                STX     <Oquote         ; clear open quote/DATA flag
002979  1               LAB_13AC:
002979  1  BD 81 21             LDA     Ibuffs,X        ; get byte from input buffer
00297C  1  F0 51                BEQ     LAB_13EC        ; if null save byte then exit
00297E  1               
00297E  1  C9 5F                CMP     #'_'            ; compare with "_"
002980  1  B0 4D                BCS     LAB_13EC        ; if >= go save byte then continue crunching
002982  1               
002982  1  C9 3C                CMP     #'<'            ; compare with "<"
002984  1  B0 0E                BCS     LAB_13CC        ; if >= go crunch now
002986  1               
002986  1  C9 30                CMP     #'0'            ; compare with "0"
002988  1  B0 45                BCS     LAB_13EC        ; if >= go save byte then continue crunching
00298A  1               
00298A  1  85 5C                STA     <Scnquo         ; save buffer byte as search character
00298C  1  C9 22                CMP     #$22            ; is it quote character?
00298E  1  F0 64                BEQ     LAB_1410        ; branch if so (copy quoted string)
002990  1               
002990  1  C9 2A                CMP     #'*'            ; compare with "*"
002992  1  90 3B                BCC     LAB_13EC        ; if < go save byte then continue crunching
002994  1               
002994  1               ; else crunch now
002994  1               LAB_13CC:
002994  1  24 60                BIT     <Oquote         ; get open quote/DATA token flag
002996  1  70 37                BVS     LAB_13EC        ; branch if b6 of <Oquote set (was DATA)
002998  1               ; go save byte then continue crunching
002998  1               
002998  1  86 78                STX     <TempB          ; save buffer read index
00299A  1  84 BA                STY     <csidx          ; copy buffer save index
00299C  1  A0 73                LDY     #<TAB_1STC      ; get keyword first character table low address
00299E  1  84 73                STY     <ut2_pl         ; save pointer low byte
0029A0  1  A0 11                LDY     #>TAB_1STC      ; get keyword first character table high address
0029A2  1  84 74                STY     <ut2_ph         ; save pointer high byte
0029A4  1  A0 00                LDY     #$00            ; clear table pointer
0029A6  1               
0029A6  1               LAB_13D0:
0029A6  1  D1 73                CMP     (<ut2_pl),Y     ; compare with keyword first character table byte
0029A8  1  F0 05                BEQ     LAB_13D1        ; go do word_table_chr if match
0029AA  1               
0029AA  1  90 21                BCC     LAB_13EA        ; if < keyword first character table byte go restore
0029AC  1               ; Y and save to crunched
0029AC  1               
0029AC  1  C8                   INY                     ; else increment pointer
0029AD  1  D0 F7                BNE     LAB_13D0        ; and loop (branch always)
0029AF  1               
0029AF  1               ; have matched first character of some keyword
0029AF  1               
0029AF  1               LAB_13D1:
0029AF  1  98                   TYA                     ; copy matching index
0029B0  1  0A                   ASL     A               ; *2 (bytes per pointer)
0029B1  1  AA                   TAX                     ; copy to new index
0029B2  1  BD 92 11             LDA     TAB_CHRT,X      ; get keyword table pointer low byte
0029B5  1  85 73                STA     <ut2_pl         ; save pointer low byte
0029B7  1  BD 93 11             LDA     TAB_CHRT+1,X    ; get keyword table pointer high byte
0029BA  1  85 74                STA     <ut2_ph         ; save pointer high byte
0029BC  1               
0029BC  1  A0 FF                LDY     #$FF            ; clear table pointer (make -1 for start)
0029BE  1               
0029BE  1  A6 78                LDX     <TempB          ; restore buffer read index
0029C0  1               
0029C0  1               LAB_13D6:
0029C0  1  C8                   INY                     ; next table byte
0029C1  1  B1 73                LDA     (<ut2_pl),Y     ; get byte from table
0029C3  1               LAB_13D8:
0029C3  1  30 08                BMI     LAB_13EA        ; all bytes matched so go save token
0029C5  1               
0029C5  1  E8                   INX                     ; next buffer byte
0029C6  1  DD 81 21             CMP     Ibuffs,X        ; compare with byte from input buffer
0029C9  1  F0 F5                BEQ     LAB_13D6        ; go compare next if match
0029CB  1               
0029CB  1  D0 2E                BNE     LAB_1417        ; branch if >< (not found keyword)
0029CD  1               
0029CD  1               LAB_13EA:
0029CD  1  A4 BA                LDY     <csidx          ; restore save index
0029CF  1               
0029CF  1               ; save crunched to output
0029CF  1               LAB_13EC:
0029CF  1  E8                   INX                     ; increment buffer index (to next input byte)
0029D0  1  C8                   INY                     ; increment save index (to next output byte)
0029D1  1  99 81 21             STA     Ibuffs,Y        ; save byte to output
0029D4  1  C9 00                CMP     #$00            ; set the flags, set carry
0029D6  1  F0 35                BEQ     LAB_142A        ; do exit if was null [EOL]
0029D8  1               
0029D8  1               ; A holds token or byte here
0029D8  1  E9 3A                SBC     #':'            ; subtract ":" (carry set by CMP #00)
0029DA  1  F0 04                BEQ     LAB_13FF        ; branch if it was ":" (is now $00)
0029DC  1               
0029DC  1               ; A now holds token-$3A
0029DC  1  C9 49                CMP     #TK_DATA-$3A    ; compare with DATA token - $3A
0029DE  1  D0 02                BNE     LAB_1401        ; branch if not DATA
0029E0  1               
0029E0  1               ; token was : or DATA
0029E0  1               LAB_13FF:
0029E0  1  85 60                STA     <Oquote         ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
0029E2  1               LAB_1401:
0029E2  1  49 57                EOR     #TK_REM-$3A     ; effectively subtract REM token offset
0029E4  1  F0 03                BEQ     LAB_1401_A
0029E6  1  4C 79 29             JMP     LAB_13AC        ; If wasn't REM then go crunch rest of line
0029E9  1               
0029E9  1               LAB_1401_A:
0029E9  1  85 5C                STA     <Asrch          ; else was REM so set search for [EOL]
0029EB  1               
0029EB  1               ; loop for REM, "..." etc.
0029EB  1               LAB_1408:
0029EB  1  BD 81 21             LDA     Ibuffs,X        ; get byte from input buffer
0029EE  1  F0 DF                BEQ     LAB_13EC        ; branch if null [EOL]
0029F0  1               
0029F0  1  C5 5C                CMP     <Asrch          ; compare with stored character
0029F2  1  F0 DB                BEQ     LAB_13EC        ; branch if match (end quote)
0029F4  1               
0029F4  1               ; entry for copy string in quotes, don't crunch
0029F4  1               LAB_1410:
0029F4  1  C8                   INY                     ; increment buffer save index
0029F5  1  99 81 21             STA     Ibuffs,Y        ; save byte to output
0029F8  1  E8                   INX                     ; increment buffer read index
0029F9  1  D0 F0                BNE     LAB_1408        ; loop while <> 0 (should never be 0!)
0029FB  1               
0029FB  1               ; not found keyword this go
0029FB  1               LAB_1417:
0029FB  1  A6 78                LDX     <TempB          ; compare has failed, restore buffer index (start byte!)
0029FD  1               
0029FD  1               ; now find the end of this word in the table
0029FD  1               LAB_141B:
0029FD  1  B1 73                LDA     (<ut2_pl),Y     ; get table byte
0029FF  1  08                   PHP                     ; save status
002A00  1  C8                   INY                     ; increment table index
002A01  1  28                   PLP                     ; restore byte status
002A02  1  10 F9                BPL     LAB_141B        ; if not end of keyword go do next
002A04  1               
002A04  1  B1 73                LDA     (<ut2_pl),Y     ; get byte from keyword table
002A06  1  D0 BB                BNE     LAB_13D8        ; go test next word if not zero byte (end of table)
002A08  1               
002A08  1               ; reached end of table with no match
002A08  1  BD 81 21             LDA     Ibuffs,X        ; restore byte from input buffer
002A0B  1  10 C0                BPL     LAB_13EA        ; branch always (all bytes in buffer are $00-$7F)
002A0D  1               ; go save byte in output and continue crunching
002A0D  1               
002A0D  1               ; reached [EOL]
002A0D  1               LAB_142A:
002A0D  1  C8                   INY                     ; increment pointer
002A0E  1  C8                   INY                     ; increment pointer (makes it next line pointer high byte)
002A0F  1  99 81 21             STA     Ibuffs,Y        ; save [EOL] (marks [EOT] in immediate mode)
002A12  1  C8                   INY                     ; adjust for line copy
002A13  1  C8                   INY                     ; adjust for line copy
002A14  1  C8                   INY                     ; adjust for line copy
002A15  1  C6 C3                DEC     <Bpntrl         ; allow for increment (change if buffer starts at $xxFF)
002A17  1  60                   RTS
002A18  1               
002A18  1               ; search Basic for temp integer line number from start of mem
002A18  1               
002A18  1               LAB_SSLN:
002A18  1  A5 79                LDA     <Smeml          ; get start of mem low byte
002A1A  1  A6 7A                LDX     <Smemh          ; get start of mem high byte
002A1C  1               
002A1C  1               ; search Basic for temp integer line number from AX
002A1C  1               ; returns carry set if found
002A1C  1               ; returns <Baslnl/<Baslnh pointer to found or next higher (not found) line
002A1C  1               
002A1C  1               ; old 541 new 507
002A1C  1               
002A1C  1               LAB_SHLN:
002A1C  1  A0 01                LDY     #$01            ; set index
002A1E  1  85 AA                STA     <Baslnl         ; save low byte as current
002A20  1  86 AB                STX     <Baslnh         ; save high byte as current
002A22  1  B1 AA                LDA     (<Baslnl),Y     ; get pointer high byte from addr
002A24  1  F0 1A                BEQ     LAB_145F        ; pointer was zero so we're done, do 'not found' exit
002A26  1               
002A26  1  A0 03                LDY     #$03            ; set index to line # high byte
002A28  1  B1 AA                LDA     (<Baslnl),Y     ; get line # high byte
002A2A  1  88                   DEY                     ; decrement index (point to low byte)
002A2B  1  C5 12                CMP     <Itemph         ; compare with temporary integer high byte
002A2D  1  D0 04                BNE     LAB_1455        ; if <> skip low byte check
002A2F  1               
002A2F  1  B1 AA                LDA     (<Baslnl),Y     ; get line # low byte
002A31  1  C5 11                CMP     <Itempl         ; compare with temporary integer low byte
002A33  1               LAB_1455:
002A33  1  B0 09                BCS     LAB_145E        ; else if temp < this line, exit (passed line#)
002A35  1               
002A35  1               LAB_1456:
002A35  1  88                   DEY                     ; decrement index to next line ptr high byte
002A36  1  B1 AA                LDA     (<Baslnl),Y     ; get next line pointer high byte
002A38  1  AA                   TAX                     ; copy to X
002A39  1  88                   DEY                     ; decrement index to next line ptr low byte
002A3A  1  B1 AA                LDA     (<Baslnl),Y     ; get next line pointer low byte
002A3C  1  90 DE                BCC     LAB_SHLN        ; go search for line # in temp (<Itempl/<Itemph) from AX
002A3E  1               ; (carry always clear)
002A3E  1               
002A3E  1               LAB_145E:
002A3E  1  F0 01                BEQ     LAB_1460        ; exit if temp = found line #, carry is set
002A40  1               
002A40  1               LAB_145F:
002A40  1  18                   CLC                     ; clear found flag
002A41  1               LAB_1460:
002A41  1  60                   RTS
002A42  1               
002A42  1               ; perform NEW
002A42  1               
002A42  1               LAB_NEW:
002A42  1  D0 FD                BNE     LAB_1460        ; exit if not end of statement (to do syntax error)
002A44  1               
002A44  1               LAB_1463:
002A44  1  A9 00                LDA     #$00            ; clear A
002A46  1  A8                   TAY                     ; clear Y
002A47  1  91 79                STA     (<Smeml),Y      ; clear first line, next line pointer, low byte
002A49  1  C8                   INY                     ; increment index
002A4A  1  91 79                STA     (<Smeml),Y      ; clear first line, next line pointer, high byte
002A4C  1  18                   CLC                     ; clear carry
002A4D  1  A5 79                LDA     <Smeml          ; get start of mem low byte
002A4F  1  69 02                ADC     #$02            ; calculate end of BASIC low byte
002A51  1  85 7B                STA     <Svarl          ; save start of vars low byte
002A53  1  A5 7A                LDA     <Smemh          ; get start of mem high byte
002A55  1  69 00                ADC     #$00            ; add any carry
002A57  1  85 7C                STA     <Svarh          ; save start of vars high byte
002A59  1               
002A59  1               ; reset execution to start, clear vars and flush stack
002A59  1               
002A59  1               LAB_1477:
002A59  1  18                   CLC                     ; clear carry
002A5A  1  A5 79                LDA     <Smeml          ; get start of mem low byte
002A5C  1  69 FF                ADC     #$FF            ; -1
002A5E  1  85 C3                STA     <Bpntrl         ; save BASIC execute pointer low byte
002A60  1  A5 7A                LDA     <Smemh          ; get start of mem high byte
002A62  1  69 FF                ADC     #$FF            ; -1+carry
002A64  1  85 C4                STA     <Bpntrh         ; save BASIC execute pointer high byte
002A66  1               ; "CLEAR" command gets here
002A66  1               
002A66  1               LAB_147A:
002A66  1  A5 85                LDA     <Ememl          ; get end of mem low byte
002A68  1  A4 86                LDY     <Ememh          ; get end of mem high byte
002A6A  1  85 81                STA     <Sstorl         ; set bottom of string space low byte
002A6C  1  84 82                STY     <Sstorh         ; set bottom of string space high byte
002A6E  1  A5 7B                LDA     <Svarl          ; get start of vars low byte
002A70  1  A4 7C                LDY     <Svarh          ; get start of vars high byte
002A72  1  85 7D                STA     <Sarryl         ; save var mem end low byte
002A74  1  84 7E                STY     <Sarryh         ; save var mem end high byte
002A76  1  85 7F                STA     <Earryl         ; save array mem end low byte
002A78  1  84 80                STY     <Earryh         ; save array mem end high byte
002A7A  1  20 51 2C             JSR     LAB_161A        ; perform RESTORE command
002A7D  1               
002A7D  1               ; flush stack and clear continue flag
002A7D  1               
002A7D  1               LAB_1491:
002A7D  1  A2 68                LDX     #<des_sk        ; set descriptor stack pointer
002A7F  1  86 65                STX     <next_s         ; save descriptor stack pointer
002A81  1  C2 30                ACCUMULATORINDEX16
002A83  1  FA                   PLX                     ; pull return address low byte
002A84  1  A9 FF DF             LDA     #STACK          ; get the stack address
002A87  1  1B                   TCS                     ; and set the stack to it
002A88  1  DA                   PHX
002A89  1  E2 30                ACCUMULATORINDEX8
002A8B  1  A9 00                LDA     #$00            ; clear byte
002A8D  1  85 8C                STA     <Cpntrh         ; clear continue pointer high byte
002A8F  1  85 61                STA     <Sufnxf         ; clear subscript/FNX flag
002A91  1               LAB_14A6:
002A91  1  60                   RTS
002A92  1               
002A92  1               ; perform CLEAR
002A92  1               
002A92  1               LAB_CLEAR:
002A92  1  F0 D2                BEQ     LAB_147A        ; if no following token go do "CLEAR"
002A94  1               
002A94  1               ; else there was a following token (go do syntax error)
002A94  1  60                   RTS
002A95  1               
002A95  1               ; perform LIST [n][-m]
002A95  1               ; bigger, faster version (a _lot_ faster)
002A95  1               
002A95  1               LAB_LIST:
002A95  1  90 06                BCC     LAB_14BD        ; branch if next character numeric (LIST n..)
002A97  1               
002A97  1  F0 04                BEQ     LAB_14BD        ; branch if next character [NULL] (LIST)
002A99  1               
002A99  1  C9 CC                CMP     #TK_MINUS       ; compare with token for -
002A9B  1  D0 F4                BNE     LAB_14A6        ; exit if not - (LIST -m)
002A9D  1               
002A9D  1               ; LIST [[n][-m]]
002A9D  1               ; this bit sets the n , if present, as the start and end
002A9D  1               LAB_14BD:
002A9D  1  20 63 2E             JSR     LAB_GFPN        ; get fixed-point number into temp integer
002AA0  1  20 18 2A             JSR     LAB_SSLN        ; search BASIC for temp integer line number
002AA3  1               ; (pointer in <Baslnl/<Baslnh)
002AA3  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002AA7  1  F0 0D                BEQ     LAB_14D4        ; branch if no more characters
002AA9  1               
002AA9  1               ; this bit checks the - is present
002AA9  1  C9 CC                CMP     #TK_MINUS       ; compare with token for -
002AAB  1  D0 61                BNE     LAB_152B        ; return if not "-" (will be Syntax error)
002AAD  1               
002AAD  1               ; LIST [n]-m
002AAD  1               ; the - was there so set m as the end value
002AAD  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002AB1  1  20 63 2E             JSR     LAB_GFPN        ; get fixed-point number into temp integer
002AB4  1  D0 58                BNE     LAB_152B        ; exit if not ok
002AB6  1               
002AB6  1               LAB_14D4:
002AB6  1  A5 11                LDA     <Itempl         ; get temporary integer low byte
002AB8  1  05 12                ORA     <Itemph         ; OR temporary integer high byte
002ABA  1  D0 06                BNE     LAB_14E2        ; branch if start set
002ABC  1               
002ABC  1  A9 FF                LDA     #$FF            ; set for -1
002ABE  1  85 11                STA     <Itempl         ; set temporary integer low byte
002AC0  1  85 12                STA     <Itemph         ; set temporary integer high byte
002AC2  1               LAB_14E2:
002AC2  1  A0 01                LDY     #$01            ; set index for line
002AC4  1  84 60                STY     <Oquote         ; clear open quote flag
002AC6  1  20 82 30             JSR     LAB_CRLF        ; print CR/LF
002AC9  1  B1 AA                LDA     (<Baslnl),Y     ; get next line pointer high byte
002ACB  1               ; pointer initially set by search at LAB_14BD
002ACB  1  F0 41                BEQ     LAB_152B        ; if null all done so exit
002ACD  1  20 16 2C             JSR     LAB_1629        ; do CRTL-C check vector
002AD0  1               
002AD0  1  C8                   INY                     ; increment index for line
002AD1  1  B1 AA                LDA     (<Baslnl),Y     ; get line # low byte
002AD3  1  AA                   TAX                     ; copy to X
002AD4  1  C8                   INY                     ; increment index
002AD5  1  B1 AA                LDA     (<Baslnl),Y     ; get line # high byte
002AD7  1  C5 12                CMP     <Itemph         ; compare with temporary integer high byte
002AD9  1  D0 04                BNE     LAB_14FF        ; branch if no high byte match
002ADB  1               
002ADB  1  E4 11                CPX     <Itempl         ; compare with temporary integer low byte
002ADD  1  F0 02                BEQ     LAB_1501        ; branch if = last line to do (< will pass next branch)
002ADF  1               
002ADF  1               LAB_14FF:                       ; else ..
002ADF  1  B0 2D                BCS     LAB_152B        ; if greater all done so exit
002AE1  1               
002AE1  1               LAB_1501:
002AE1  1  84 97                STY     <Tidx1          ; save index for line
002AE3  1  20 E3 47             JSR     LAB_295E        ; print XA as unsigned integer
002AE6  1  A9 20                LDA     #$20            ; space is the next character
002AE8  1               LAB_1508:
002AE8  1  A4 97                LDY     <Tidx1          ; get index for line
002AEA  1  29 7F                AND     #$7F            ; mask top out bit of character
002AEC  1               LAB_150C:
002AEC  1  20 F8 30             JSR     LAB_PRNA        ; go print the character
002AEF  1  C9 22                CMP     #$22            ; was it " character
002AF1  1  D0 06                BNE     LAB_1519        ; branch if not
002AF3  1               
002AF3  1               ; we are either entering or leaving a pair of quotes
002AF3  1  A5 60                LDA     <Oquote         ; get open quote flag
002AF5  1  49 FF                EOR     #$FF            ; toggle it
002AF7  1  85 60                STA     <Oquote         ; save it back
002AF9  1               LAB_1519:
002AF9  1  C8                   INY                     ; increment index
002AFA  1  B1 AA                LDA     (<Baslnl),Y     ; get next byte
002AFC  1  D0 11                BNE     LAB_152E        ; branch if not [EOL] (go print character)
002AFE  1  A8                   TAY                     ; else clear index
002AFF  1  B1 AA                LDA     (<Baslnl),Y     ; get next line pointer low byte
002B01  1  AA                   TAX                     ; copy to X
002B02  1  C8                   INY                     ; increment index
002B03  1  B1 AA                LDA     (<Baslnl),Y     ; get next line pointer high byte
002B05  1  86 AA                STX     <Baslnl         ; set pointer to line low byte
002B07  1  85 AB                STA     <Baslnh         ; set pointer to line high byte
002B09  1  F0 03                BEQ     LAB_152B
002B0B  1  4C C2 2A             JMP     LAB_14E2        ; go do next line if not [EOT]
002B0E  1               
002B0E  1               ; else ..
002B0E  1               LAB_152B:
002B0E  1  60                   RTS
002B0F  1               
002B0F  1               LAB_152E:
002B0F  1  10 DB                BPL     LAB_150C        ; just go print it if not token byte
002B11  1               
002B11  1               ; else was token byte so uncrunch it (maybe)
002B11  1  24 60                BIT     <Oquote         ; test the open quote flag
002B13  1  30 D7                BMI     LAB_150C        ; just go print character if open quote set
002B15  1               
002B15  1  A2 14                LDX     #>LAB_KEYT      ; get table address high byte
002B17  1  0A                   ASL     A               ; *2
002B18  1  0A                   ASL     A               ; *4
002B19  1  90 02                BCC     LAB_152F        ; branch if no carry
002B1B  1               
002B1B  1  E8                   INX                     ; else increment high byte
002B1C  1  18                   CLC                     ; clear carry for add
002B1D  1               LAB_152F:
002B1D  1  69 04                ADC     #<LAB_KEYT      ; add low byte
002B1F  1  90 01                BCC     LAB_1530        ; branch if no carry
002B21  1               
002B21  1  E8                   INX                     ; else increment high byte
002B22  1               LAB_1530:
002B22  1  85 73                STA     <ut2_pl         ; save table pointer low byte
002B24  1  86 74                STX     <ut2_ph         ; save table pointer high byte
002B26  1  84 97                STY     <Tidx1          ; save index for line
002B28  1  A0 00                LDY     #$00            ; clear index
002B2A  1  B1 73                LDA     (<ut2_pl),Y     ; get length
002B2C  1  AA                   TAX                     ; copy length
002B2D  1  C8                   INY                     ; increment index
002B2E  1  B1 73                LDA     (<ut2_pl),Y     ; get 1st character
002B30  1  CA                   DEX                     ; decrement length
002B31  1  D0 03                BNE     LAB_1508_A
002B33  1  4C E8 2A             JMP     LAB_1508        ; if no more characters exit and print
002B36  1               LAB_1508_A:
002B36  1  20 F8 30             JSR     LAB_PRNA        ; go print the character
002B39  1  C8                   INY                     ; increment index
002B3A  1  B1 73                LDA     (<ut2_pl),Y     ; get keyword address low byte
002B3C  1  48                   PHA                     ; save it for now
002B3D  1  C8                   INY                     ; increment index
002B3E  1  B1 73                LDA     (<ut2_pl),Y     ; get keyword address high byte
002B40  1  A0 00                LDY     #$00
002B42  1  85 74                STA     <ut2_ph         ; save keyword pointer high byte
002B44  1  68                   PLA                     ; pull low byte
002B45  1  85 73                STA     <ut2_pl         ; save keyword pointer low byte
002B47  1               LAB_1540:
002B47  1  B1 73                LDA     (<ut2_pl),Y     ; get character
002B49  1  CA                   DEX                     ; decrement character count
002B4A  1  D0 03                BNE     LAB_1508_B
002B4C  1  4C E8 2A             JMP     LAB_1508        ; if last character exit and print
002B4F  1               LAB_1508_B:
002B4F  1  20 F8 30             JSR     LAB_PRNA        ; go print the character
002B52  1  C8                   INY                     ; increment index
002B53  1  D0 F2                BNE     LAB_1540        ; loop for next character
002B55  1               
002B55  1               ; perform FOR
002B55  1               
002B55  1               LAB_FOR:
002B55  1  A9 80                LDA     #$80            ; set FNX
002B57  1  85 61                STA     <Sufnxf         ; set subscript/FNX flag
002B59  1  20 C5 2E             JSR     LAB_LET         ; go do LET
002B5C  1  68                   PLA                     ; pull return address
002B5D  1  68                   PLA                     ; pull return address
002B5E  1  A9 10                LDA     #$10            ; we need 16d bytes !
002B60  1  20 BF 27             JSR     LAB_1212        ; check room on stack for A bytes
002B63  1  20 B1 2D             JSR     LAB_SNBS        ; scan for next BASIC statement ([:] or [EOL])
002B66  1  18                   CLC                     ; clear carry for add
002B67  1  98                   TYA                     ; copy index to A
002B68  1  65 C3                ADC     <Bpntrl         ; add BASIC execute pointer low byte
002B6A  1  48                   PHA                     ; push onto stack
002B6B  1  A5 C4                LDA     <Bpntrh         ; get BASIC execute pointer high byte
002B6D  1  69 00                ADC     #$00            ; add carry
002B6F  1  48                   PHA                     ; push onto stack
002B70  1  A5 88                LDA     <Clineh         ; get current line high byte
002B72  1  48                   PHA                     ; push onto stack
002B73  1  A5 87                LDA     <Clinel         ; get current line low byte
002B75  1  48                   PHA                     ; push onto stack
002B76  1  A9 C2                LDA     #TK_TO          ; get "TO" token
002B78  1  20 55 34             JSR     LAB_SCCA        ; scan for CHR$(A) , else do syntax error then warm start
002B7B  1  20 31 33             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
002B7E  1  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
002B81  1               ; else do type mismatch
002B81  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
002B83  1  09 7F                ORA     #$7F            ; set all non sign bits
002B85  1  25 AD                AND     <FAC1_1         ; and FAC1 mantissa1
002B87  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
002B89  1  A9 94                LDA     #<LAB_159F      ; set return address low byte
002B8B  1  A0 2B                LDY     #>LAB_159F      ; set return address high byte
002B8D  1  85 71                STA     <ut1_pl         ; save return address low byte
002B8F  1  84 72                STY     <ut1_ph         ; save return address high byte
002B91  1  4C E7 33             JMP     LAB_1B66        ; round FAC1 and put on stack (returns to next instruction)
002B94  1               
002B94  1               LAB_159F:
002B94  1  A9 9A                LDA     #<LAB_259C      ; set 1 pointer low addr (default step size)
002B96  1  A0 18                LDY     #>LAB_259C      ; set 1 pointer high addr
002B98  1  20 BC 44             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
002B9B  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002B9F  1  C9 C7                CMP     #TK_STEP        ; compare with STEP token
002BA1  1  D0 07                BNE     LAB_15B3        ; jump if not "STEP"
002BA3  1               
002BA3  1               ;.was step so ..
002BA3  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002BA7  1  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
002BAA  1               ; else do type mismatch
002BAA  1               LAB_15B3:
002BAA  1  20 C8 45             JSR     LAB_27CA        ; return A=FF,C=1/-ve A=01,C=0/+ve
002BAD  1  85 B0                STA     <FAC1_s         ; set FAC1 sign (b7)
002BAF  1               ; this is +1 for +ve step and -1 for -ve step, in NEXT we
002BAF  1               ; compare the FOR value and the TO value and return +1 if
002BAF  1               ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
002BAF  1               ; here (+/-1) is then compared to that result and if they
002BAF  1               ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
002BAF  1               ; the loop is done
002BAF  1  20 DC 33             JSR     LAB_1B5B        ; push sign, round FAC1 and put on stack
002BB2  1  A5 98                LDA     <Frnxth         ; get var pointer for FOR/NEXT high byte
002BB4  1  48                   PHA                     ; push on stack
002BB5  1  A5 97                LDA     <Frnxtl         ; get var pointer for FOR/NEXT low byte
002BB7  1  48                   PHA                     ; push on stack
002BB8  1  A9 81                LDA     #TK_FOR         ; get FOR token
002BBA  1  48                   PHA                     ; push on stack
002BBB  1               
002BBB  1               ; interpreter inner loop
002BBB  1               
002BBB  1               LAB_15C2:
002BBB  1  20 16 2C             JSR     LAB_1629        ; do CRTL-C check vector
002BBE  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte
002BC0  1  A4 C4                LDY     <Bpntrh         ; get BASIC execute pointer high byte
002BC2  1               
002BC2  1  A6 88                LDX     <Clineh         ; continue line is $FFxx for immediate mode
002BC4  1               ; ($00xx for RUN from immediate mode)
002BC4  1  E8                   INX                     ; increment it (now $00 if immediate mode)
002BC5  1  F0 04                BEQ     LAB_15D1        ; branch if null (immediate mode)
002BC7  1               
002BC7  1  85 8B                STA     <Cpntrl         ; save continue pointer low byte
002BC9  1  84 8C                STY     <Cpntrh         ; save continue pointer high byte
002BCB  1               LAB_15D1:
002BCB  1  A0 00                LDY     #$00            ; clear index
002BCD  1  B1 C3                LDA     (<Bpntrl),Y     ; get next byte
002BCF  1  F0 07                BEQ     LAB_15DC        ; branch if null [EOL]
002BD1  1               
002BD1  1  C9 3A                CMP     #':'            ; compare with ":"
002BD3  1  F0 1D                BEQ     LAB_15F6        ; branch if = (statement separator)
002BD5  1               
002BD5  1               LAB_15D9:
002BD5  1  4C 68 34             JMP     LAB_SNER        ; else syntax error then warm start
002BD8  1               
002BD8  1               ; have reached [EOL]
002BD8  1               LAB_15DC:
002BD8  1  A0 02                LDY     #$02            ; set index
002BDA  1  B1 C3                LDA     (<Bpntrl),Y     ; get next line pointer high byte
002BDC  1  18                   CLC                     ; clear carry for no "BREAK" message
002BDD  1  F0 59                BEQ     LAB_1651        ; if null go to immediate mode (was immediate or [EOT]
002BDF  1               ; marker)
002BDF  1               
002BDF  1  C8                   INY                     ; increment index
002BE0  1  B1 C3                LDA     (<Bpntrl),Y     ; get line # low byte
002BE2  1  85 87                STA     <Clinel         ; save current line low byte
002BE4  1  C8                   INY                     ; increment index
002BE5  1  B1 C3                LDA     (<Bpntrl),Y     ; get line # high byte
002BE7  1  85 88                STA     <Clineh         ; save current line high byte
002BE9  1  98                   TYA                     ; A now = 4
002BEA  1  65 C3                ADC     <Bpntrl         ; add BASIC execute pointer low byte
002BEC  1  85 C3                STA     <Bpntrl         ; save BASIC execute pointer low byte
002BEE  1  90 02                BCC     LAB_15F6        ; branch if no overflow
002BF0  1               
002BF0  1  E6 C4                INC     <Bpntrh         ; else increment BASIC execute pointer high byte
002BF2  1               LAB_15F6:
002BF2  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002BF6  1               
002BF6  1               
002BF6  1               
002BF6  1               
002BF6  1               LAB_15F9:
002BF6  1  20 FC 2B             JSR     LAB_15FF        ; go interpret BASIC code from (<Bpntrl)
002BF9  1               LAB_15FC:
002BF9  1  4C BB 2B             JMP     LAB_15C2        ; loop
002BFC  1               
002BFC  1               ; interpret BASIC code from (<Bpntrl)
002BFC  1               
002BFC  1               LAB_15FF:
002BFC  1  F0 61                BEQ     LAB_1628        ; exit if zero [EOL]
002BFE  1               
002BFE  1               LAB_1602:
002BFE  1  0A                   ASL     A               ; *2 bytes per vector and normalise token
002BFF  1  B0 03                BCS     LAB_1609        ; branch if was token
002C01  1  4C C5 2E             JMP     LAB_LET         ; else go do implied LET
002C04  1               
002C04  1               LAB_1609:
002C04  1               TK_TABUSE       = (TK_TAB-$80)*2
002C04  1  C9 80                CMP     #TK_TABUSE      ; compare normalised token * 2 with TAB
002C06  1  B0 CD                BCS     LAB_15D9        ; branch if A>=TAB (do syntax error then warm start)
002C08  1               ; only tokens before TAB can start a line
002C08  1  A8                   TAY                     ; copy to index
002C09  1  B9 39 10             LDA     LAB_CTBL+1,Y    ; get vector high byte
002C0C  1  48                   PHA                     ; onto stack
002C0D  1  B9 38 10             LDA     LAB_CTBL,Y      ; get vector low byte
002C10  1  48                   PHA                     ; onto stack
002C11  1  22 BC 00 00          JSL     LAB_IGBY        ; jump to increment and scan memory
002C15  1               ; then "return" to vector
002C15  1  60                   RTS
002C16  1               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
002C16  1               ; key press is detected.
002C16  1               
002C16  1               LAB_1629:
002C16  1  6C 03 02             JMP     (VEC_CC)        ; ctrl c check vector
002C19  1               
002C19  1               ; if there was a key press it gets back here ..
002C19  1               
002C19  1               LAB_1636:
002C19  1  C9 03                CMP     #$03            ; compare with CTRL-C
002C1B  1               
002C1B  1               ; perform STOP
002C1B  1               
002C1B  1               LAB_STOP:
002C1B  1  B0 01                BCS     LAB_163B        ; branch if token follows STOP
002C1D  1               ; else just END
002C1D  1               ; END
002C1D  1               
002C1D  1               LAB_END:
002C1D  1  18                   CLC                     ; clear the carry, indicate a normal program end
002C1E  1               LAB_163B:
002C1E  1  D0 72                BNE     LAB_167A        ; if wasn't CTRL-C or there is a following byte return
002C20  1               
002C20  1  A5 C4                LDA     <Bpntrh         ; get the BASIC execute pointer high byte
002C22  1  49 21                EOR     #>Ibuffs        ; compare with buffer address high byte (Cb unchanged)
002C24  1  F0 10                BEQ     LAB_164F        ; branch if the BASIC pointer is in the input buffer
002C26  1               ; (can't continue in immediate mode)
002C26  1               
002C26  1               ; else ..
002C26  1  49 21                EOR     #>Ibuffs        ; correct the bits
002C28  1  A4 C3                LDY     <Bpntrl         ; get BASIC execute pointer low byte
002C2A  1  84 8B                STY     <Cpntrl         ; save continue pointer low byte
002C2C  1  85 8C                STA     <Cpntrh         ; save continue pointer high byte
002C2E  1               LAB_1647:
002C2E  1  A5 87                LDA     <Clinel         ; get current line low byte
002C30  1  A4 88                LDY     <Clineh         ; get current line high byte
002C32  1  85 89                STA     <Blinel         ; save break line low byte
002C34  1  84 8A                STY     <Blineh         ; save break line high byte
002C36  1               LAB_164F:
002C36  1  68                   PLA                     ; pull return address low
002C37  1  68                   PLA                     ; pull return address high
002C38  1               LAB_1651:
002C38  1  90 12                BCC     LAB_165E        ; if was program end just do warm start
002C3A  1               
002C3A  1               ; else ..
002C3A  1               
002C3A  1  A5 06                LDA     <VIDEOMODE
002C3C  1  C9 02                CMP     #2
002C3E  1  F0 05                BEQ     LAB_1651A
002C40  1  A2 02                LDX     #2
002C42  1  20 22 1E             JSR     V_SCREEN1
002C45  1               LAB_1651A:
002C45  1  A9 C2                LDA     #<LAB_BMSG      ; point to "Break" low byte
002C47  1  A0 17                LDY     #>LAB_BMSG      ; point to "Break" high byte
002C49  1  4C 28 28             JMP     LAB_1269        ; print "Break" and do warm start
002C4C  1               
002C4C  1               LAB_165E:
002C4C  1  4C 33 28             JMP     LAB_1274        ; go do warm start
002C4F  1               
002C4F  1               ; perform RESTORE
002C4F  1               
002C4F  1               LAB_RESTORE:
002C4F  1  D0 0F                BNE     LAB_RESTOREn    ; branch if next character not null (RESTORE n)
002C51  1               
002C51  1               LAB_161A:
002C51  1  38                   SEC                     ; set carry for subtract
002C52  1  A5 79                LDA     <Smeml          ; get start of mem low byte
002C54  1  E9 01                SBC     #$01            ; -1
002C56  1  A4 7A                LDY     <Smemh          ; get start of mem high byte
002C58  1  B0 01                BCS     LAB_1624        ; branch if no underflow
002C5A  1               
002C5A  1               LAB_uflow:
002C5A  1  88                   DEY                     ; else decrement high byte
002C5B  1               LAB_1624:
002C5B  1  85 8F                STA     <Dptrl          ; save DATA pointer low byte
002C5D  1  84 90                STY     <Dptrh          ; save DATA pointer high byte
002C5F  1               LAB_1628:
002C5F  1  60                   RTS
002C60  1               
002C60  1               ; is RESTORE n
002C60  1               LAB_RESTOREn:
002C60  1  20 63 2E             JSR     LAB_GFPN        ; get fixed-point number into temp integer
002C63  1  20 B4 2D             JSR     LAB_SNBL        ; scan for next BASIC line
002C66  1  A5 88                LDA     <Clineh         ; get current line high byte
002C68  1  C5 12                CMP     <Itemph         ; compare with temporary integer high byte
002C6A  1  B0 0B                BCS     LAB_reset_search; branch if >= (start search from beginning)
002C6C  1               
002C6C  1  98                   TYA                     ; else copy line index to A
002C6D  1  38                   SEC                     ; set carry (+1)
002C6E  1  65 C3                ADC     <Bpntrl         ; add BASIC execute pointer low byte
002C70  1  A6 C4                LDX     <Bpntrh         ; get BASIC execute pointer high byte
002C72  1  90 07                BCC     LAB_go_search   ; branch if no overflow to high byte
002C74  1               
002C74  1  E8                   INX                     ; increment high byte
002C75  1  B0 04                BCS     LAB_go_search   ; branch always (can never be carry clear)
002C77  1               
002C77  1               ; search for line # in temp (<Itempl/<Itemph) from start of mem pointer (<Smeml)
002C77  1               
002C77  1               LAB_reset_search:
002C77  1  A5 79                LDA     <Smeml          ; get start of mem low byte
002C79  1  A6 7A                LDX     <Smemh          ; get start of mem high byte
002C7B  1               
002C7B  1               ; search for line # in temp (<Itempl/<Itemph) from (AX)
002C7B  1               
002C7B  1               LAB_go_search:
002C7B  1               
002C7B  1  20 1C 2A             JSR     LAB_SHLN        ; search Basic for temp integer line number from AX
002C7E  1  B0 03                BCS     LAB_line_found  ; if carry set go set pointer
002C80  1               
002C80  1  4C 86 2D             JMP     LAB_16F7        ; else go do "Undefined statement" error
002C83  1               
002C83  1               LAB_line_found:
002C83  1               ; carry already set for subtract
002C83  1  A5 AA                LDA     <Baslnl         ; get pointer low byte
002C85  1  E9 01                SBC     #$01            ; -1
002C87  1  A4 AB                LDY     <Baslnh         ; get pointer high byte
002C89  1  B0 D0                BCS     LAB_1624        ; branch if no underflow (save DATA pointer and return)
002C8B  1               
002C8B  1  90 CD                BCC     LAB_uflow       ; else decrement high byte then save DATA pointer and
002C8D  1               ; return (branch always)
002C8D  1               
002C8D  1               ; perform NULL
002C8D  1               
002C8D  1               LAB_NULL:
002C8D  1  20 DE 3F             JSR     LAB_GTBY        ; get byte parameter
002C90  1  86 0D                STX     <Nullct         ; save new NULL count
002C92  1               LAB_167A:
002C92  1  60                   RTS
002C93  1               
002C93  1               ; perform CONT
002C93  1               
002C93  1               LAB_CONT:
002C93  1  D0 FD                BNE     LAB_167A        ; if following byte exit to do syntax error
002C95  1               
002C95  1  A4 8C                LDY     <Cpntrh         ; get continue pointer high byte
002C97  1  D0 05                BNE     LAB_166C        ; go do continue if we can
002C99  1               
002C99  1  A2 1E                LDX     #$1E            ; error code $1E ("Can't continue" error)
002C9B  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
002C9E  1               
002C9E  1               ; we can continue so ..
002C9E  1               LAB_166C:
002C9E  1  A9 93                LDA     #TK_ON          ; set token for ON
002CA0  1  20 E2 4C             JSR     LAB_IRQ         ; set IRQ flags
002CA3  1  A9 93                LDA     #TK_ON          ; set token for ON
002CA5  1  20 E5 4C             JSR     LAB_NMI         ; set NMI flags
002CA8  1               
002CA8  1  84 C4                STY     <Bpntrh         ; save BASIC execute pointer high byte
002CAA  1  A5 8B                LDA     <Cpntrl         ; get continue pointer low byte
002CAC  1  85 C3                STA     <Bpntrl         ; save BASIC execute pointer low byte
002CAE  1  A5 89                LDA     <Blinel         ; get break line low byte
002CB0  1  A4 8A                LDY     <Blineh         ; get break line high byte
002CB2  1  85 87                STA     <Clinel         ; set current line low byte
002CB4  1  84 88                STY     <Clineh         ; set current line high byte
002CB6  1  60                   RTS
002CB7  1               
002CB7  1               ; perform RUN
002CB7  1               
002CB7  1               LAB_RUN:
002CB7  1  D0 03                BNE     LAB_1696        ; branch if RUN n
002CB9  1  4C 59 2A             JMP     LAB_1477        ; reset execution to start, clear variables, flush stack and
002CBC  1               ; return
002CBC  1               
002CBC  1               ; does RUN n
002CBC  1               
002CBC  1               LAB_1696:
002CBC  1  20 66 2A             JSR     LAB_147A        ; go do "CLEAR"
002CBF  1  F0 2F                BEQ     LAB_16B0        ; get n and do GOTO n (branch always as CLEAR sets Z=1)
002CC1  1               
002CC1  1               ; perform DO
002CC1  1               
002CC1  1               LAB_DO:
002CC1  1  A9 05                LDA     #$05            ; need 5 bytes for DO
002CC3  1  20 BF 27             JSR     LAB_1212        ; check room on stack for A bytes
002CC6  1  A5 C4                LDA     <Bpntrh         ; get BASIC execute pointer high byte
002CC8  1  48                   PHA                     ; push on stack
002CC9  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte
002CCB  1  48                   PHA                     ; push on stack
002CCC  1  A5 88                LDA     <Clineh         ; get current line high byte
002CCE  1  48                   PHA                     ; push on stack
002CCF  1  A5 87                LDA     <Clinel         ; get current line low byte
002CD1  1  48                   PHA                     ; push on stack
002CD2  1  A9 9C                LDA     #TK_DO          ; token for DO
002CD4  1  48                   PHA                     ; push on stack
002CD5  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002CD9  1  4C BB 2B             JMP     LAB_15C2        ; go do interpreter inner loop
002CDC  1               
002CDC  1               ; perform GOSUB
002CDC  1               
002CDC  1               LAB_GOSUB:
002CDC  1  A9 05                LDA     #$05            ; need 5 bytes for GOSUB
002CDE  1  20 BF 27             JSR     LAB_1212        ; check room on stack for A bytes
002CE1  1  A5 C4                LDA     <Bpntrh         ; get BASIC execute pointer high byte
002CE3  1  48                   PHA                     ; push on stack
002CE4  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte
002CE6  1  48                   PHA                     ; push on stack
002CE7  1  A5 88                LDA     <Clineh         ; get current line high byte
002CE9  1  48                   PHA                     ; push on stack
002CEA  1  A5 87                LDA     <Clinel         ; get current line low byte
002CEC  1  48                   PHA                     ; push on stack
002CED  1  A9 8F                LDA     #TK_GOSUB       ; token for GOSUB
002CEF  1  48                   PHA                     ; push on stack
002CF0  1               LAB_16B0:
002CF0  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002CF4  1  20 FA 2C             JSR     LAB_GOTO        ; perform GOTO n
002CF7  1  4C BB 2B             JMP     LAB_15C2        ; go do interpreter inner loop
002CFA  1               ; (can't RTS, we used the stack!)
002CFA  1               
002CFA  1               ; perform GOTO
002CFA  1               
002CFA  1               LAB_GOTO:
002CFA  1  20 63 2E             JSR     LAB_GFPN        ; get fixed-point number into temp integer
002CFD  1  20 B4 2D             JSR     LAB_SNBL        ; scan for next BASIC line
002D00  1  A5 88                LDA     <Clineh         ; get current line high byte
002D02  1  C5 12                CMP     <Itemph         ; compare with temporary integer high byte
002D04  1  B0 0B                BCS     LAB_16D0        ; branch if >= (start search from beginning)
002D06  1               
002D06  1  98                   TYA                     ; else copy line index to A
002D07  1  38                   SEC                     ; set carry (+1)
002D08  1  65 C3                ADC     <Bpntrl         ; add BASIC execute pointer low byte
002D0A  1  A6 C4                LDX     <Bpntrh         ; get BASIC execute pointer high byte
002D0C  1  90 07                BCC     LAB_16D4        ; branch if no overflow to high byte
002D0E  1               
002D0E  1  E8                   INX                     ; increment high byte
002D0F  1  B0 04                BCS     LAB_16D4        ; branch always (can never be carry)
002D11  1               
002D11  1               ; search for line # in temp (<Itempl/<Itemph) from start of mem pointer (<Smeml)
002D11  1               
002D11  1               LAB_16D0:
002D11  1  A5 79                LDA     <Smeml          ; get start of mem low byte
002D13  1  A6 7A                LDX     <Smemh          ; get start of mem high byte
002D15  1               
002D15  1               ; search for line # in temp (<Itempl/<Itemph) from (AX)
002D15  1               
002D15  1               LAB_16D4:
002D15  1  20 1C 2A             JSR     LAB_SHLN        ; search Basic for temp integer line number from AX
002D18  1  90 6C                BCC     LAB_16F7        ; if carry clear go do "Undefined statement" error
002D1A  1               ; (unspecified statement)
002D1A  1               
002D1A  1               ; carry already set for subtract
002D1A  1  A5 AA                LDA     <Baslnl         ; get pointer low byte
002D1C  1  E9 01                SBC     #$01            ; -1
002D1E  1  85 C3                STA     <Bpntrl         ; save BASIC execute pointer low byte
002D20  1  A5 AB                LDA     <Baslnh         ; get pointer high byte
002D22  1  E9 00                SBC     #$00            ; subtract carry
002D24  1  85 C4                STA     <Bpntrh         ; save BASIC execute pointer high byte
002D26  1               LAB_16E5:
002D26  1  60                   RTS
002D27  1               
002D27  1               LAB_DONOK:
002D27  1  A2 22                LDX     #$22            ; error code $22 ("LOOP without DO" error)
002D29  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
002D2C  1               
002D2C  1               ; perform LOOP
002D2C  1               
002D2C  1               LAB_LOOP:
002D2C  1  A8                   TAY                     ; save following token
002D2D  1  A3 03                LDA     3,S             ; get token byte from stack
002D2F  1  C9 9C                CMP     #TK_DO          ; compare with DO token
002D31  1  D0 F4                BNE     LAB_DONOK       ; branch if no matching DO
002D33  1               
002D33  1               ; FIXUP STACK
002D33  1  C2 10                INDEX16
002D35  1  BA                   TSX
002D36  1  E8                   INX                     ; dump calling routine return address
002D37  1  E8                   INX                     ; dump calling routine return address
002D38  1  9A                   TXS                     ; correct stack
002D39  1  E2 10                INDEX8
002D3B  1               
002D3B  1  98                   TYA                     ; get saved following token back
002D3C  1  F0 20                BEQ     LoopAlways      ; if no following token loop forever
002D3E  1               ; (stack pointer in X)
002D3E  1               
002D3E  1  C9 3A                CMP     #':'            ; could be ':'
002D40  1  F0 1C                BEQ     LoopAlways      ; if :... loop forever
002D42  1               
002D42  1  E9 C8                SBC     #TK_UNTIL       ; subtract token for UNTIL, we know carry is set here
002D44  1  AA                   TAX                     ; copy to X (if it was UNTIL then Y will be correct)
002D45  1  F0 04                BEQ     DoRest          ; branch if was UNTIL
002D47  1               
002D47  1  CA                   DEX                     ; decrement result
002D48  1  D0 64                BNE     LAB_16FC        ; if not WHILE go do syntax error and warm start
002D4A  1               ; only if the token was WHILE will this fail
002D4A  1               
002D4A  1  CA                   DEX                     ; set invert result byte
002D4B  1               DoRest:
002D4B  1  86 98                STX     <Frnxth         ; save invert result byte
002D4D  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002D51  1  20 42 33             JSR     LAB_EVEX        ; evaluate expression
002D54  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
002D56  1  F0 02                BEQ     DoCmp           ; if =0 go do straight compare
002D58  1               
002D58  1  A9 FF                LDA     #$FF            ; else set all bits
002D5A  1               DoCmp:
002D5A  1  45 98                EOR     <Frnxth         ; EOR with invert byte
002D5C  1  D0 17                BNE     LoopDone        ; if <> 0 clear stack and back to interpreter loop
002D5E  1               
002D5E  1               ; loop condition wasn't met so do it again
002D5E  1               LoopAlways:
002D5E  1  A3 02                LDA     2,S             ; get current line low byte
002D60  1  85 87                STA     <Clinel         ; save current line low byte
002D62  1  A3 03                LDA     3,S             ; get current line high byte
002D64  1  85 88                STA     <Clineh         ; save current line high byte
002D66  1  A3 04                LDA     4,S             ; get BASIC execute pointer low byte
002D68  1  85 C3                STA     <Bpntrl         ; save BASIC execute pointer low byte
002D6A  1  A3 05                LDA     5,S             ; get BASIC execute pointer high byte
002D6C  1  85 C4                STA     <Bpntrh         ; save BASIC execute pointer high byte
002D6E  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002D72  1  4C BB 2B             JMP     LAB_15C2        ; go do interpreter inner loop
002D75  1               
002D75  1               ; clear stack and back to interpreter loop
002D75  1               LoopDone:
002D75  1  C2 10                INDEX16
002D77  1  BA                   TSX
002D78  1  E8                   INX                     ; dump DO token
002D79  1  E8                   INX                     ; dump current line low byte
002D7A  1  E8                   INX                     ; dump current line high byte
002D7B  1  E8                   INX                     ; dump BASIC execute pointer low byte
002D7C  1  E8                   INX                     ; dump BASIC execute pointer high byte
002D7D  1  9A                   TXS                     ; correct stack
002D7E  1  E2 10                INDEX8
002D80  1  4C A0 2D             JMP     LAB_DATA        ; go perform DATA (find : or [EOL])
002D83  1               
002D83  1               ; do the return without gosub error
002D83  1               
002D83  1               LAB_16F4:
002D83  1  A2 04                LDX     #$04            ; error code $04 ("RETURN without GOSUB" error)
002D85  1  2C                   .BYTE   $2C             ; makes next line BIT LAB_0EA2
002D86  1               
002D86  1               LAB_16F7:                       ; do undefined statement error
002D86  1  A2 0E                LDX     #$0E            ; error code $0E ("Undefined statement" error)
002D88  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
002D8B  1               
002D8B  1               ; perform RETURN
002D8B  1               
002D8B  1               LAB_RETURN:
002D8B  1  D0 99                BNE     LAB_16E5        ; exit if following token (to allow syntax error)
002D8D  1               
002D8D  1               LAB_16E8:
002D8D  1  68                   PLA                     ; dump calling routine return address
002D8E  1  68                   PLA                     ; dump calling routine return address
002D8F  1  68                   PLA                     ; pull token
002D90  1  C9 8F                CMP     #TK_GOSUB       ; compare with GOSUB token
002D92  1  D0 EF                BNE     LAB_16F4        ; branch if no matching GOSUB
002D94  1               
002D94  1               LAB_16FF:
002D94  1  68                   PLA                     ; pull current line low byte
002D95  1  85 87                STA     <Clinel         ; save current line low byte
002D97  1  68                   PLA                     ; pull current line high byte
002D98  1  85 88                STA     <Clineh         ; save current line high byte
002D9A  1  68                   PLA                     ; pull BASIC execute pointer low byte
002D9B  1  85 C3                STA     <Bpntrl         ; save BASIC execute pointer low byte
002D9D  1  68                   PLA                     ; pull BASIC execute pointer high byte
002D9E  1  85 C4                STA     <Bpntrh         ; save BASIC execute pointer high byte
002DA0  1               
002DA0  1               ; now do the DATA statement as we could be returning into
002DA0  1               ; the middle of an ON <var> GOSUB n,m,p,q line
002DA0  1               ; (the return address used by the DATA statement is the one
002DA0  1               ; pushed before the GOSUB was executed!)
002DA0  1               
002DA0  1               ; perform DATA
002DA0  1               
002DA0  1               LAB_DATA:
002DA0  1  20 B1 2D             JSR     LAB_SNBS        ; scan for next BASIC statement ([:] or [EOL])
002DA3  1               
002DA3  1               ; set BASIC execute pointer
002DA3  1               LAB_170F:
002DA3  1  98                   TYA                     ; copy index to A
002DA4  1  18                   CLC                     ; clear carry for add
002DA5  1  65 C3                ADC     <Bpntrl         ; add BASIC execute pointer low byte
002DA7  1  85 C3                STA     <Bpntrl         ; save BASIC execute pointer low byte
002DA9  1  90 02                BCC     LAB_1719        ; skip next if no carry
002DAB  1               
002DAB  1  E6 C4                INC     <Bpntrh         ; else increment BASIC execute pointer high byte
002DAD  1               LAB_1719:
002DAD  1  60                   RTS
002DAE  1               
002DAE  1               LAB_16FC:
002DAE  1  4C 68 34             JMP     LAB_SNER        ; do syntax error then warm start
002DB1  1               
002DB1  1               ; scan for next BASIC statement ([:] or [EOL])
002DB1  1               ; returns Y as index to [:] or [EOL]
002DB1  1               
002DB1  1               LAB_SNBS:
002DB1  1  A2 3A                LDX     #':'            ; set look for character = ":"
002DB3  1  2C                   .BYTE   $2C             ; makes next line BIT $00A2
002DB4  1               
002DB4  1               ; scan for next BASIC line
002DB4  1               ; returns Y as index to [EOL]
002DB4  1               
002DB4  1               LAB_SNBL:
002DB4  1  A2 00                LDX     #$00            ; set alt search character = [EOL]
002DB6  1  A0 00                LDY     #$00            ; set search character = [EOL]
002DB8  1  84 5C                STY     <Asrch          ; store search character
002DBA  1               LAB_1725:
002DBA  1  8A                   TXA                     ; get alt search character
002DBB  1  45 5C                EOR     <Asrch          ; toggle search character, effectively swap with $00
002DBD  1  85 5C                STA     <Asrch          ; save swapped search character
002DBF  1               LAB_172D:
002DBF  1  B1 C3                LDA     (<Bpntrl),Y     ; get next byte
002DC1  1  F0 EA                BEQ     LAB_1719        ; exit if null [EOL]
002DC3  1               
002DC3  1  C5 5C                CMP     <Asrch          ; compare with search character
002DC5  1  F0 E6                BEQ     LAB_1719        ; exit if found
002DC7  1               
002DC7  1  C8                   INY                     ; increment index
002DC8  1  C9 22                CMP     #$22            ; compare current character with open quote
002DCA  1  D0 F3                BNE     LAB_172D        ; if not open quote go get next character
002DCC  1               
002DCC  1  F0 EC                BEQ     LAB_1725        ; if found go swap search character for alt search character
002DCE  1               
002DCE  1               ; perform IF
002DCE  1               
002DCE  1               LAB_IF:
002DCE  1  20 42 33             JSR     LAB_EVEX        ; evaluate the expression
002DD1  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002DD5  1  C9 C5                CMP     #TK_THEN        ; compare with THEN token
002DD7  1  F0 12                BEQ     LAB_174B        ; if it was THEN go do IF
002DD9  1               
002DD9  1               ; wasn't IF .. THEN so must be IF .. GOTO
002DD9  1  C9 8B                CMP     #TK_GOTO        ; compare with GOTO token
002DDB  1  D0 D1                BNE     LAB_16FC        ; if it wasn't GOTO go do syntax error
002DDD  1               
002DDD  1  A6 C3                LDX     <Bpntrl         ; save the basic pointer low byte
002DDF  1  A4 C4                LDY     <Bpntrh         ; save the basic pointer high byte
002DE1  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002DE5  1  B0 C7                BCS     LAB_16FC        ; if not numeric go do syntax error
002DE7  1               
002DE7  1  86 C3                STX     <Bpntrl         ; restore the basic pointer low byte
002DE9  1  84 C4                STY     <Bpntrh         ; restore the basic pointer high byte
002DEB  1               LAB_174B:
002DEB  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
002DED  1  F0 1F                BEQ     LAB_174E        ; if the result was zero go look for an ELSE
002DEF  1               
002DEF  1  22 BC 00 00          JSL     LAB_IGBY        ; else increment and scan memory
002DF3  1  B0 03                BCS     LAB_174D        ; if not numeric go do var or keyword
002DF5  1               
002DF5  1               LAB_174C:
002DF5  1  4C FA 2C             JMP     LAB_GOTO        ; else was numeric so do GOTO n
002DF8  1               
002DF8  1               ; is var or keyword
002DF8  1               LAB_174D:
002DF8  1  C9 90                CMP     #TK_RETURN      ; compare the byte with the token for RETURN
002DFA  1  D0 03                BNE     LAB_174G        ; if it wasn't RETURN go interpret BASIC code from (<Bpntrl)
002DFC  1               ; and return to this code to process any following code
002DFC  1               
002DFC  1  4C FE 2B             JMP     LAB_1602        ; else it was RETURN so interpret BASIC code from (<Bpntrl)
002DFF  1               ; but don't return here
002DFF  1               
002DFF  1               LAB_174G:
002DFF  1  20 FC 2B             JSR     LAB_15FF        ; interpret BASIC code from (<Bpntrl)
002E02  1               
002E02  1               ; the IF was executed and there may be a following ELSE so the code needs to return
002E02  1               ; here to check and ignore the ELSE if present
002E02  1               
002E02  1  A0 00                LDY     #$00            ; clear the index
002E04  1  B1 C3                LDA     (<Bpntrl),Y     ; get the next BASIC byte
002E06  1  C9 C1                CMP     #TK_ELSE        ; compare it with the token for ELSE
002E08  1  D0 03                BNE     LAB_DATA_A
002E0A  1  4C A0 2D             JMP     LAB_DATA        ; if ELSE ignore the following statement
002E0D  1               
002E0D  1               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
002E0D  1               ; following ELSE will, correctly, cause a syntax error
002E0D  1               LAB_DATA_A:
002E0D  1  60                   RTS                     ; else return to the interpreter inner loop
002E0E  1               
002E0E  1               ; perform ELSE after IF
002E0E  1               
002E0E  1               LAB_174E:
002E0E  1  A0 00                LDY     #$00            ; clear the BASIC byte index
002E10  1  A2 01                LDX     #$01            ; clear the nesting depth
002E12  1               LAB_1750:
002E12  1  C8                   INY                     ; increment the BASIC byte index
002E13  1  B1 C3                LDA     (<Bpntrl),Y     ; get the next BASIC byte
002E15  1  F0 0F                BEQ     LAB_1753        ; if EOL go add the pointer and return
002E17  1               
002E17  1  C9 8D                CMP     #TK_IF          ; compare the byte with the token for IF
002E19  1  D0 03                BNE     LAB_1752        ; if not IF token skip the depth increment
002E1B  1               
002E1B  1  E8                   INX                     ; else increment the nesting depth ..
002E1C  1  D0 F4                BNE     LAB_1750        ; .. and continue looking
002E1E  1               
002E1E  1               LAB_1752:
002E1E  1  C9 C1                CMP     #TK_ELSE        ; compare the byte with the token for ELSE
002E20  1  D0 F0                BNE     LAB_1750        ; if not ELSE token continue looking
002E22  1               
002E22  1  CA                   DEX                     ; was ELSE so decrement the nesting depth
002E23  1  D0 ED                BNE     LAB_1750        ; loop if still nested
002E25  1               
002E25  1  C8                   INY                     ; increment the BASIC byte index past the ELSE
002E26  1               
002E26  1               ; found the matching ELSE, now do <{n|statement}>
002E26  1               
002E26  1               LAB_1753:
002E26  1  98                   TYA                     ; else copy line index to A
002E27  1  18                   CLC                     ; clear carry for add
002E28  1  65 C3                ADC     <Bpntrl         ; add the BASIC execute pointer low byte
002E2A  1  85 C3                STA     <Bpntrl         ; save the BASIC execute pointer low byte
002E2C  1  90 02                BCC     LAB_1754        ; branch if no overflow to high byte
002E2E  1               
002E2E  1  E6 C4                INC     <Bpntrh         ; else increment the BASIC execute pointer high byte
002E30  1               LAB_1754:
002E30  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002E34  1  90 BF                BCC     LAB_174C        ; if numeric do GOTO n
002E36  1               ; the code will return to the interpreter loop at the
002E36  1               ; tail end of the GOTO <n>
002E36  1               
002E36  1  4C FC 2B             JMP     LAB_15FF        ; interpret BASIC code from (<Bpntrl)
002E39  1               ; the code will return to the interpreter loop at the
002E39  1               ; tail end of the <statement>
002E39  1               
002E39  1               ; perform REM, skip (rest of) line
002E39  1               
002E39  1               LAB_REM:
002E39  1  20 B4 2D             JSR     LAB_SNBL        ; scan for next BASIC line
002E3C  1  4C A3 2D             JMP     LAB_170F        ; go set BASIC execute pointer and return, branch always
002E3F  1               
002E3F  1               LAB_16FD:
002E3F  1  4C 68 34             JMP     LAB_SNER        ; do syntax error then warm start
002E42  1               
002E42  1               ; perform ON
002E42  1               
002E42  1               LAB_ON:
002E42  1               LAB_NONM:
002E42  1  20 DE 3F             JSR     LAB_GTBY        ; get byte parameter
002E45  1  48                   PHA                     ; push GOTO/GOSUB token
002E46  1  C9 8F                CMP     #TK_GOSUB       ; compare with GOSUB token
002E48  1  F0 04                BEQ     LAB_176B        ; branch if GOSUB
002E4A  1               
002E4A  1  C9 8B                CMP     #TK_GOTO        ; compare with GOTO token
002E4C  1               LAB_1767:
002E4C  1  D0 F1                BNE     LAB_16FD        ; if not GOTO do syntax error then warm start
002E4E  1               
002E4E  1               
002E4E  1               ; next character was GOTO or GOSUB
002E4E  1               
002E4E  1               LAB_176B:
002E4E  1  C6 AF                DEC     <FAC1_3         ; decrement index (byte value)
002E50  1  D0 04                BNE     LAB_1773        ; branch if not zero
002E52  1               
002E52  1  68                   PLA                     ; pull GOTO/GOSUB token
002E53  1  4C FE 2B             JMP     LAB_1602        ; go execute it
002E56  1               
002E56  1               LAB_1773:
002E56  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002E5A  1  20 63 2E             JSR     LAB_GFPN        ; get fixed-point number into temp integer (skip this n)
002E5D  1               ; (we could LDX #',' and JSR LAB_SNBL+2, then we
002E5D  1               ; just BNE LAB_176B for the loop. should be quicker ..
002E5D  1               ; no we can't, what if we meet a colon or [EOL]?)
002E5D  1  C9 2C                CMP     #$2C            ; compare next character with ","
002E5F  1  F0 ED                BEQ     LAB_176B        ; loop if ","
002E61  1               
002E61  1               LAB_177E:
002E61  1  68                   PLA                     ; else pull keyword token (run out of options)
002E62  1               ; also dump +/-1 pointer low byte and exit
002E62  1               LAB_177F:
002E62  1  60                   RTS
002E63  1               
002E63  1               ; takes n * 106 + 11 cycles where n is the number of digits
002E63  1               
002E63  1               ; get fixed-point number into temp integer
002E63  1               
002E63  1               LAB_GFPN:
002E63  1  A2 00                LDX     #$00            ; clear reg
002E65  1  86 11                STX     <Itempl         ; clear temporary integer low byte
002E67  1               LAB_1785:
002E67  1  86 12                STX     <Itemph         ; save temporary integer high byte
002E69  1  B0 F7                BCS     LAB_177F        ; return if carry set, end of scan, character was
002E6B  1               ; not 0-9
002E6B  1               
002E6B  1  E0 19                CPX     #$19            ; compare high byte with $19
002E6D  1  A8                   TAY                     ; ensure Zb = 0 if the branch is taken
002E6E  1  B0 DC                BCS     LAB_1767        ; branch if >=, makes max line # 63999 because next
002E70  1               ; bit does *$0A, = 64000, compare at target will fail
002E70  1               ; and do syntax error
002E70  1               
002E70  1  E9 2F                SBC     #'0'-1          ; subtract "0", $2F + carry, from byte
002E72  1  A8                   TAY                     ; copy binary digit
002E73  1  A5 11                LDA     <Itempl         ; get temporary integer low byte
002E75  1  0A                   ASL     A               ; *2 low byte
002E76  1  26 12                ROL     <Itemph         ; *2 high byte
002E78  1  0A                   ASL     A               ; *2 low byte
002E79  1  26 12                ROL     <Itemph         ; *2 high byte, *4
002E7B  1  65 11                ADC     <Itempl         ; + low byte, *5
002E7D  1  85 11                STA     <Itempl         ; save it
002E7F  1  8A                   TXA                     ; get high byte copy to A
002E80  1  65 12                ADC     <Itemph         ; + high byte, *5
002E82  1  06 11                ASL     <Itempl         ; *2 low byte, *10d
002E84  1  2A                   ROL     A               ; *2 high byte, *10d
002E85  1  AA                   TAX                     ; copy high byte back to X
002E86  1  98                   TYA                     ; get binary digit back
002E87  1  65 11                ADC     <Itempl         ; add number low byte
002E89  1  85 11                STA     <Itempl         ; save number low byte
002E8B  1  90 01                BCC     LAB_17B3        ; if no overflow to high byte get next character
002E8D  1               
002E8D  1  E8                   INX                     ; else increment high byte
002E8E  1               LAB_17B3:
002E8E  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002E92  1  4C 67 2E             JMP     LAB_1785        ; loop for next character
002E95  1               
002E95  1               ; perform DEC
002E95  1               
002E95  1               LAB_DEC:
002E95  1  A9 9E                LDA     #<LAB_2AFD      ; set -1 pointer low byte
002E97  1  2C                   .BYTE   $2C             ; BIT abs to skip the LDA below
002E98  1               
002E98  1               ; perform INC
002E98  1               
002E98  1               LAB_INC:
002E98  1  A9 9A                LDA     #<LAB_259C      ; set 1 pointer low byte
002E9A  1               LAB_17B5:
002E9A  1  48                   PHA                     ; save +/-1 pointer low byte
002E9B  1               LAB_17B7:
002E9B  1  20 3F 36             JSR     LAB_GVAR        ; get var address
002E9E  1  A6 5F                LDX     <Dtypef         ; get data type flag, $FF=string, $00=numeric
002EA0  1  30 20                BMI     IncrErr         ; exit if string
002EA2  1               
002EA2  1  85 97                STA     <Lvarpl         ; save var address low byte
002EA4  1  84 98                STY     <Lvarph         ; save var address high byte
002EA6  1  20 BC 44             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
002EA9  1  68                   PLA                     ; get +/-1 pointer low byte
002EAA  1  48                   PHA                     ; save +/-1 pointer low byte
002EAB  1  A0 18                LDY     #>LAB_259C      ; set +/-1 pointer high byte (both the same)
002EAD  1  20 A7 41             JSR     LAB_246C        ; add (AY) to FAC1
002EB0  1  20 32 45             JSR     LAB_PFAC        ; pack FAC1 into variable (<Lvarpl)
002EB3  1               
002EB3  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
002EB7  1  C9 2C                CMP     #','            ; compare with ","
002EB9  1  D0 A6                BNE     LAB_177E        ; exit if not "," (either end or error)
002EBB  1               
002EBB  1               ; was "," so another INCR variable to do
002EBB  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
002EBF  1  4C 9B 2E             JMP     LAB_17B7        ; go do next var
002EC2  1               
002EC2  1               IncrErr:
002EC2  1  4C 3D 33             JMP     LAB_1ABC        ; do "Type mismatch" error then warm start
002EC5  1               
002EC5  1               ; perform LET
002EC5  1               
002EC5  1               LAB_LET:
002EC5  1  20 3F 36             JSR     LAB_GVAR        ; get var address
002EC8  1  85 97                STA     <Lvarpl         ; save var address low byte
002ECA  1  84 98                STY     <Lvarph         ; save var address high byte
002ECC  1  A9 D6                LDA     #TK_EQUAL       ; get = token
002ECE  1  20 55 34             JSR     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
002ED1  1  A5 5F                LDA     <Dtypef         ; get data type flag, $FF=string, $00=numeric
002ED3  1  48                   PHA                     ; push data type flag
002ED4  1  20 42 33             JSR     LAB_EVEX        ; evaluate expression
002ED7  1  68                   PLA                     ; pop data type flag
002ED8  1  2A                   ROL     A               ; set carry if type = string
002ED9  1  20 34 33             JSR     LAB_CKTM        ; type match check, set C for string
002EDC  1  D0 03                BNE     LAB_17D5        ; branch if string
002EDE  1               
002EDE  1  4C 32 45             JMP     LAB_PFAC        ; pack FAC1 into variable (<Lvarpl) and return
002EE1  1               
002EE1  1               ; string LET
002EE1  1               
002EE1  1               LAB_17D5:
002EE1  1  A0 02                LDY     #$02            ; set index to pointer high byte
002EE3  1  8B DA A2 01          LDAINDIRECTY des_pl     ; get string pointer high byte
002EE7  1  B5 AE C9 00  
002EEB  1  D0 04 A2 00  
002EF9  1  C5 82                CMP     <Sstorh         ; compare bottom of string space high byte
002EFB  1  90 2B                BCC     LAB_17F4        ; if less assign value and exit (was in program memory)
002EFD  1  D0 1B                BNE     LAB_17E6        ; branch if >
002EFF  1               ; else was equal so compare low bytes
002EFF  1  88                   DEY                     ; decrement index
002F00  1  8B DA A2 01          LDAINDIRECTY des_pl     ; get pointer low byte
002F04  1  B5 AE C9 00  
002F08  1  D0 04 A2 00  
002F16  1  C5 81                CMP     <Sstorl         ; compare bottom of string space low byte
002F18  1  90 0E                BCC     LAB_17F4        ; if less assign value and exit (was in program memory)
002F1A  1               
002F1A  1               ; pointer was >= to bottom of string space pointer
002F1A  1               LAB_17E6:
002F1A  1  A4 AF                LDY     <des_ph         ; get descriptor pointer high byte
002F1C  1  C4 7C                CPY     <Svarh          ; compare start of vars high byte
002F1E  1  90 08                BCC     LAB_17F4        ; branch if less (descriptor is on stack)
002F20  1               
002F20  1  D0 0D                BNE     LAB_17FB        ; branch if greater (descriptor is not on stack)
002F22  1               
002F22  1               ; else high bytes were equal so ..
002F22  1  A5 AE                LDA     <des_pl         ; get descriptor pointer low byte
002F24  1  C5 7B                CMP     <Svarl          ; compare start of vars low byte
002F26  1  B0 07                BCS     LAB_17FB        ; branch if >= (descriptor is not on stack)
002F28  1               
002F28  1               LAB_17F4:
002F28  1  A5 AE                LDA     <des_pl         ; get descriptor pointer low byte
002F2A  1  A4 AF                LDY     <des_ph         ; get descriptor pointer high byte
002F2C  1  4C 59 2F             JMP     LAB_1811        ; clean stack, copy descriptor to variable and return
002F2F  1               
002F2F  1               ; make space and copy string
002F2F  1               LAB_17FB:
002F2F  1               
002F2F  1  A0 00                LDY     #$00            ; index to length
002F31  1  8B DA A2 01          LDAINDIRECTY des_pl     ; get string length
002F35  1  B5 AE C9 00  
002F39  1  D0 04 A2 00  
002F47  1  20 66 3A             JSR     LAB_209C        ; copy string
002F4A  1  A5 9E                LDA     <des_2l         ; get descriptor pointer low byte
002F4C  1  A4 9F                LDY     <des_2h         ; get descriptor pointer high byte
002F4E  1  85 B8                STA     <ssptr_l        ; save descriptor pointer low byte
002F50  1  84 B9                STY     <ssptr_h        ; save descriptor pointer high byte
002F52  1  20 C4 3C             JSR     LAB_228A        ; copy string from descriptor (<sdescr) to (<Sutill)
002F55  1  A9 AC                LDA     #<FAC1_e        ; set descriptor pointer low byte
002F57  1  A0 00                LDY     #>FAC1_e        ; get descriptor pointer high byte
002F59  1               
002F59  1               ; clean stack and assign value to string variable
002F59  1               LAB_1811:
002F59  1  85 9E                STA     <des_2l         ; save descriptor_2 pointer low byte
002F5B  1  84 9F                STY     <des_2h         ; save descriptor_2 pointer high byte
002F5D  1  20 C6 3D             JSR     LAB_22EB        ; clean descriptor stack, YA = pointer
002F60  1  A0 00                LDY     #$00            ; index to length
002F62  1  8B DA A2 01          LDAINDIRECTY des_2l     ; get string length
002F66  1  B5 9E C9 00  
002F6A  1  D0 04 A2 00  
002F78  1  8B DA 48 A2          STAINDIRECTY Lvarpl     ; copy to let string variable
002F7C  1  01 B5 97 C9  
002F80  1  00 D0 04 A2  
002F8E  1  C8                   INY                     ; index to string pointer low byte
002F8F  1  8B DA A2 01          LDAINDIRECTY des_2l     ; get string pointer low byte
002F93  1  B5 9E C9 00  
002F97  1  D0 04 A2 00  
002FA5  1  8B DA 48 A2          STAINDIRECTY Lvarpl     ; copy to let string variable
002FA9  1  01 B5 97 C9  
002FAD  1  00 D0 04 A2  
002FBB  1  C8                   INY                     ; index to string pointer high byte
002FBC  1  8B DA A2 01          LDAINDIRECTY des_2l     ; get string pointer high byte
002FC0  1  B5 9E C9 00  
002FC4  1  D0 04 A2 00  
002FD2  1  8B DA 48 A2          STAINDIRECTY Lvarpl     ; copy to let string variable
002FD6  1  01 B5 97 C9  
002FDA  1  00 D0 04 A2  
002FE8  1  60                   RTS
002FE9  1               
002FE9  1               ; perform GET
002FE9  1               
002FE9  1               LAB_GET:
002FE9  1  20 3F 36             JSR     LAB_GVAR        ; get var address
002FEC  1  85 97                STA     <Lvarpl         ; save var address low byte
002FEE  1  84 98                STY     <Lvarph         ; save var address high byte
002FF0  1  20 CF 4C             JSR     INGET           ; get input byte
002FF3  1  A6 5F                LDX     <Dtypef         ; get data type flag, $FF=string, $00=numeric
002FF5  1  30 07                BMI     LAB_GETS        ; go get string character
002FF7  1               
002FF7  1               ; was numeric get
002FF7  1  A8                   TAY                     ; copy character to Y
002FF8  1  20 0A 39             JSR     LAB_1FD0        ; convert Y to byte in FAC1
002FFB  1  4C 32 45             JMP     LAB_PFAC        ; pack FAC1 into variable (<Lvarpl) and return
002FFE  1               
002FFE  1               LAB_GETS:
002FFE  1  48                   PHA                     ; save character
002FFF  1  A9 01                LDA     #$01            ; string is single byte
003001  1  B0 01                BCS     LAB_IsByte      ; branch if byte received
003003  1               
003003  1  68                   PLA                     ; string is null
003004  1               LAB_IsByte:
003004  1  20 6E 3A             JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
003007  1               ; X=$AD=<Sutill=ptr low byte, Y=$AE=<Sutilh=ptr high byte
003007  1  F0 19                BEQ     LAB_NoSt        ; skip store if null string
003009  1               
003009  1  68                   PLA                     ; get character back
00300A  1  A0 00                LDY     #$00            ; clear index
00300C  1  8B DA 48 A2          STAINDIRECTY str_pl     ; save byte in string (byte IS string!)
003010  1  01 B5 AD C9  
003014  1  00 D0 04 A2  
003022  1               LAB_NoSt:
003022  1  20 D1 3A             JSR     LAB_RTST        ; check for space on descriptor stack then put address
003025  1               ; and length on descriptor stack and update stack pointers
003025  1               
003025  1  4C E1 2E             JMP     LAB_17D5        ; do string LET and return
003028  1               
003028  1               ; perform PRINT
003028  1               
003028  1               LAB_1829:
003028  1  20 CD 30             JSR     LAB_18C6        ; print string from <Sutill/<Sutilh
00302B  1               LAB_182C:
00302B  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
00302F  1               
00302F  1               ; PRINT
00302F  1               
00302F  1               LAB_PRINT:
00302F  1  F0 51                BEQ     LAB_CRLF        ; if nothing following just print CR/LF
003031  1               
003031  1               LAB_1831:
003031  1  C9 C0                CMP     #TK_TAB         ; compare with TAB( token
003033  1  F0 6C                BEQ     LAB_18A2        ; go do TAB/SPC
003035  1               
003035  1  C9 C4                CMP     #TK_SPC         ; compare with SPC( token
003037  1  F0 68                BEQ     LAB_18A2        ; go do TAB/SPC
003039  1               
003039  1  C9 2C                CMP     #','            ; compare with ","
00303B  1  F0 4E                BEQ     LAB_188B        ; go do move to next TAB mark
00303D  1               
00303D  1  C9 3B                CMP     #$3B            ; compare with ";"
00303F  1  F0 7F                BEQ     LAB_18BD        ; if ";" continue with PRINT processing
003041  1               
003041  1  20 42 33             JSR     LAB_EVEX        ; evaluate expression
003044  1  24 5F                BIT     <Dtypef         ; test data type flag, $FF=string, $00=numeric
003046  1  30 E0                BMI     LAB_1829        ; branch if string
003048  1               
003048  1  20 F6 47             JSR     LAB_296E        ; convert FAC1 to string
00304B  1  20 78 3A             JSR     LAB_20AE        ; print " terminated string to <Sutill/<Sutilh
00304E  1  A0 00                LDY     #$00            ; clear index
003050  1               
003050  1               ; don't check fit if terminal width byte is zero
003050  1               
003050  1  A5 0F                LDA     <TWidth         ; get terminal width byte
003052  1  F0 20                BEQ     LAB_185E        ; skip check if zero
003054  1               
003054  1  8B 48 DA A2          FETCHINDIRECTY des_pl
003058  1  01 B5 AE C9  
00305C  1  00 D0 04 A2  
00306A  1  38                   SEC                     ; set carry for subtract
00306B  1  E5 0E                SBC     <TPos           ; subtract terminal position
00306D  1  E5 04                SBC     <TMPFLG         ; subtract string length
00306F  1  B0 03                BCS     LAB_185E        ; branch if less than terminal width
003071  1               
003071  1  20 82 30             JSR     LAB_CRLF        ; else print CR/LF
003074  1               LAB_185E:
003074  1  20 CD 30             JSR     LAB_18C6        ; print string from <Sutill/<Sutilh
003077  1  F0 B2                BEQ     LAB_182C        ; always go continue processing line
003079  1               
003079  1               ; CR/LF return to BASIC from BASIC input handler
003079  1               
003079  1               LAB_1866:
003079  1  A9 00                LDA     #$00            ; clear byte
00307B  1  9D 81 21             STA     Ibuffs,X        ; null terminate input
00307E  1  A2 81                LDX     #<Ibuffs        ; set X to buffer start-1 low byte
003080  1  A0 21                LDY     #>Ibuffs        ; set Y to buffer start-1 high byte
003082  1               ; print CR/LF
003082  1               
003082  1               LAB_CRLF:
003082  1  A9 0D                LDA     #$0D            ; load [CR]
003084  1  20 F8 30             JSR     LAB_PRNA        ; go print the character
003087  1  A9 0A                LDA     #$0A            ; load [LF]
003089  1  D0 6D                BNE     LAB_PRNA        ; go print the character and return, branch always
00308B  1               LAB_188B:
00308B  1  A5 0E                LDA     <TPos           ; get terminal position
00308D  1  C5 10                CMP     <Iclim          ; compare with input column limit
00308F  1  90 05                BCC     LAB_1897        ; branch if less
003091  1               
003091  1  20 82 30             JSR     LAB_CRLF        ; else print CR/LF (next line)
003094  1  D0 2A                BNE     LAB_18BD        ; continue with PRINT processing (branch always)
003096  1               
003096  1               LAB_1897:
003096  1  38                   SEC                     ; set carry for subtract
003097  1               LAB_1898:
003097  1  E5 64                SBC     <TabSiz         ; subtract TAB size
003099  1  B0 FC                BCS     LAB_1898        ; loop if result was +ve
00309B  1               
00309B  1  49 FF                EOR     #$FF            ; complement it
00309D  1  69 01                ADC     #$01            ; +1 (twos complement)
00309F  1  D0 15                BNE     LAB_18B6        ; always print A spaces (result is never $00)
0030A1  1               
0030A1  1               ; do TAB/SPC
0030A1  1               LAB_18A2:
0030A1  1  48                   PHA                     ; save token
0030A2  1  20 DA 3F             JSR     LAB_SGBY        ; scan and get byte parameter
0030A5  1  C9 29                CMP     #$29            ; is next character )
0030A7  1  F0 03                BEQ     LAB_18A2aa
0030A9  1               ;BNE	LAB_1910		; if not do syntax error then warm start
0030A9  1  4C 3F 31             JMP     LAB_1910        ; if not do syntax error then warm start
0030AC  1               LAB_18A2aa:
0030AC  1  68                   PLA                     ; get token back
0030AD  1  C9 C0                CMP     #TK_TAB         ; was it TAB ?
0030AF  1  D0 06                BNE     LAB_18B7        ; if not go do SPC
0030B1  1               
0030B1  1               ; calculate TAB offset
0030B1  1  8A                   TXA                     ; copy integer value to A
0030B2  1  E5 0E                SBC     <TPos           ; subtract terminal position
0030B4  1  90 0A                BCC     LAB_18BD        ; branch if result was < 0 (can't TAB backwards)
0030B6  1               
0030B6  1               ; print A spaces
0030B6  1               LAB_18B6:
0030B6  1  AA                   TAX                     ; copy result to X
0030B7  1               LAB_18B7:
0030B7  1  8A                   TXA                     ; set flags on size for SPC
0030B8  1  F0 06                BEQ     LAB_18BD        ; branch if result was = $0, already here
0030BA  1               
0030BA  1               ; print X spaces
0030BA  1               LAB_18BA:
0030BA  1  20 F3 30             JSR     LAB_18E0        ; print " "
0030BD  1  CA                   DEX                     ; decrement count
0030BE  1  D0 FA                BNE     LAB_18BA        ; loop if not all done
0030C0  1               
0030C0  1               ; continue with PRINT processing
0030C0  1               LAB_18BD:
0030C0  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0030C4  1  F0 03                BEQ     LAB_18BDA
0030C6  1  4C 31 30             JMP     LAB_1831        ; if more to print go do it
0030C9  1               LAB_18BDA:
0030C9  1  60                   RTS
0030CA  1               
0030CA  1               ; print null terminated string from memory
0030CA  1               
0030CA  1               LAB_18C3:
0030CA  1  20 78 3A             JSR     LAB_20AE        ; print " terminated string to <Sutill/<Sutilh
0030CD  1               
0030CD  1               ; print string from <Sutill/<Sutilh
0030CD  1               
0030CD  1               LAB_18C6:
0030CD  1  20 55 3D             JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
0030D0  1               ; space returns with A = length, X=$71=pointer low byte,
0030D0  1               ; Y=$72=pointer high byte
0030D0  1  A0 00                LDY     #$00            ; reset index
0030D2  1  AA                   TAX                     ; copy length to X
0030D3  1  F0 5D                BEQ     LAB_188C        ; exit (RTS) if null string
0030D5  1               LAB_18CD:
0030D5  1               
0030D5  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get next byte
0030D9  1  B5 71 C9 00  
0030DD  1  D0 04 A2 00  
0030EB  1  20 F8 30             JSR     LAB_PRNA        ; go print the character
0030EE  1  C8                   INY                     ; increment index
0030EF  1  CA                   DEX                     ; decrement count
0030F0  1  D0 E3                BNE     LAB_18CD        ; loop if not done yet
0030F2  1  60                   RTS
0030F3  1               
0030F3  1               ; Print single format character
0030F3  1               ; print " "
0030F3  1               
0030F3  1               LAB_18E0:
0030F3  1  A9 20                LDA     #$20            ; load " "
0030F5  1  2C                   .BYTE   $2C             ; change next line to BIT LAB_3FA9
0030F6  1               
0030F6  1               ; print "?" character
0030F6  1               
0030F6  1               LAB_18E3:
0030F6  1  A9 3F                LDA     #$3F            ; load "?" character
0030F8  1               
0030F8  1               ; print character in A
0030F8  1               ; now .includes the null handler
0030F8  1               ; also .includes infinite line length code
0030F8  1               ; note! some routines expect this one to exit with Zb=0
0030F8  1               
0030F8  1               LAB_PRNA:
0030F8  1  C9 20                CMP     #' '            ; compare with " "
0030FA  1  90 19                BCC     LAB_18F9        ; branch if less (non printing)
0030FC  1               
0030FC  1               ; else printable character
0030FC  1  48                   PHA                     ; save the character
0030FD  1               
0030FD  1               ; don't check fit if terminal width byte is zero
0030FD  1               
0030FD  1  A5 0F                LDA     <TWidth         ; get terminal width
0030FF  1  D0 0A                BNE     LAB_18F0        ; branch if not zero (not infinite length)
003101  1               
003101  1               ; is "infinite line" so check TAB position
003101  1               
003101  1  A5 0E                LDA     <TPos           ; get position
003103  1  E5 64                SBC     <TabSiz         ; subtract TAB size, carry set by CMP #$20 above
003105  1  D0 0B                BNE     LAB_18F7        ; skip reset if different
003107  1               
003107  1  85 0E                STA     <TPos           ; else reset position
003109  1  F0 07                BEQ     LAB_18F7        ; go print character
00310B  1               
00310B  1               LAB_18F0:
00310B  1  C5 0E                CMP     <TPos           ; compare with terminal character position
00310D  1  D0 03                BNE     LAB_18F7        ; branch if not at end of line
00310F  1               
00310F  1  20 82 30             JSR     LAB_CRLF        ; else print CR/LF
003112  1               LAB_18F7:
003112  1  E6 0E                INC     <TPos           ; increment terminal position
003114  1  68                   PLA                     ; get character back
003115  1               LAB_18F9:
003115  1  20 D0 18             JSR     V_OUTP          ; output byte via output vector
003118  1  C9 0D                CMP     #$0D            ; compare with [CR]
00311A  1  D0 14                BNE     LAB_188A        ; branch if not [CR]
00311C  1               
00311C  1               ; else print nullct nulls after the [CR]
00311C  1  86 78                STX     <TempB          ; save buffer index
00311E  1  A6 0D                LDX     <Nullct         ; get null count
003120  1  F0 0A                BEQ     LAB_1886        ; branch if no nulls
003122  1               
003122  1  A9 00                LDA     #$00            ; load [NULL]
003124  1               LAB_1880:
003124  1  20 F8 30             JSR     LAB_PRNA        ; go print the character
003127  1  CA                   DEX                     ; decrement count
003128  1  D0 FA                BNE     LAB_1880        ; loop if not all done
00312A  1               
00312A  1  A9 0D                LDA     #$0D            ; restore the character (and set the flags)
00312C  1               LAB_1886:
00312C  1  86 0E                STX     <TPos           ; clear terminal position (X always = zero when we get here)
00312E  1  A6 78                LDX     <TempB          ; restore buffer index
003130  1               LAB_188A:
003130  1  29 FF                AND     #$FF            ; set the flags
003132  1               LAB_188C:
003132  1  60                   RTS
003133  1               
003133  1               ; handle bad input data
003133  1               
003133  1               LAB_1904:
003133  1  A5 62                LDA     <Imode          ; get input mode flag, $00=INPUT, $00=READ
003135  1  10 0B                BPL     LAB_1913        ; branch if INPUT (go do redo)
003137  1               
003137  1  A5 8D                LDA     <Dlinel         ; get current DATA line low byte
003139  1  A4 8E                LDY     <Dlineh         ; get current DATA line high byte
00313B  1  85 87                STA     <Clinel         ; save current line low byte
00313D  1  84 88                STY     <Clineh         ; save current line high byte
00313F  1               LAB_1910:
00313F  1  4C 68 34             JMP     LAB_SNER        ; do syntax error then warm start
003142  1               
003142  1               ; mode was INPUT
003142  1               LAB_1913:
003142  1  A9 F6                LDA     #<LAB_REDO      ; point to redo message (low addr)
003144  1  A0 17                LDY     #>LAB_REDO      ; point to redo message (high addr)
003146  1  20 CA 30             JSR     LAB_18C3        ; print null terminated string from memory
003149  1  A5 8B                LDA     <Cpntrl         ; get continue pointer low byte
00314B  1  A4 8C                LDY     <Cpntrh         ; get continue pointer high byte
00314D  1  85 C3                STA     <Bpntrl         ; save BASIC execute pointer low byte
00314F  1  84 C4                STY     <Bpntrh         ; save BASIC execute pointer high byte
003151  1  60                   RTS
003152  1               
003152  1               ; perform INPUT
003152  1               
003152  1               LAB_INPUT:
003152  1  C9 22                CMP     #$22            ; compare next byte with open quote
003154  1  D0 0B                BNE     LAB_1934        ; branch if no prompt string
003156  1               
003156  1  20 21 34             JSR     LAB_1BC1        ; print "..." string
003159  1  A9 3B                LDA     #$3B            ; load A with ";"
00315B  1  20 55 34             JSR     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
00315E  1  20 CD 30             JSR     LAB_18C6        ; print string from <Sutill/<Sutilh
003161  1               
003161  1               ; done with prompt, now get data
003161  1               LAB_1934:
003161  1  20 0E 39             JSR     LAB_CKRN        ; check not Direct, back here if ok
003164  1  20 25 29             JSR     LAB_INLN        ; print "? " and get BASIC input
003167  1  A9 00                LDA     #$00            ; set mode = INPUT
003169  1               ;CMP	Ibuffs			; test first byte in buffer
003169  1  80 06                BRA     LAB_1953        ; branch if not null input
00316B  1               
00316B  1               ;CLC				; was null input so clear carry to exit program
00316B  1               ;JMP	LAB_1647		; go do BREAK exit
00316B  1               
00316B  1               ; perform READ
00316B  1               
00316B  1               LAB_READ:
00316B  1  A6 8F                LDX     <Dptrl          ; get DATA pointer low byte
00316D  1  A4 90                LDY     <Dptrh          ; get DATA pointer high byte
00316F  1  A9 80                LDA     #$80            ; set mode = READ
003171  1               
003171  1               LAB_1953:
003171  1  85 62                STA     <Imode          ; set input mode flag, $00=INPUT, $80=READ
003173  1  86 91                STX     <Rdptrl         ; save READ pointer low byte
003175  1  84 92                STY     <Rdptrh         ; save READ pointer high byte
003177  1               
003177  1               ; READ or INPUT next variable from list
003177  1               LAB_195B:
003177  1  20 3F 36             JSR     LAB_GVAR        ; get (var) address
00317A  1  85 97                STA     <Lvarpl         ; save address low byte
00317C  1  84 98                STY     <Lvarph         ; save address high byte
00317E  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte
003180  1  A4 C4                LDY     <Bpntrh         ; get BASIC execute pointer high byte
003182  1  85 11                STA     <Itempl         ; save as temporary integer low byte
003184  1  84 12                STY     <Itemph         ; save as temporary integer high byte
003186  1  A6 91                LDX     <Rdptrl         ; get READ pointer low byte
003188  1  A4 92                LDY     <Rdptrh         ; get READ pointer high byte
00318A  1  86 C3                STX     <Bpntrl         ; set BASIC execute pointer low byte
00318C  1  84 C4                STY     <Bpntrh         ; set BASIC execute pointer high byte
00318E  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
003192  1  D0 0C                BNE     LAB_1988        ; branch if not null
003194  1               
003194  1               ; pointer was to null entry
003194  1  24 62                BIT     <Imode          ; test input mode flag, $00=INPUT, $80=READ
003196  1  30 63                BMI     LAB_19DD        ; branch if READ
003198  1               
003198  1               ; mode was INPUT
003198  1               ;JSR	LAB_18E3		; print "?" character (double ? for extended input)
003198  1               ;JSR	LAB_INLN		; print "? " and get BASIC input
003198  1  86 C3                STX     <Bpntrl         ; set BASIC execute pointer low byte
00319A  1  84 C4                STY     <Bpntrh         ; set BASIC execute pointer high byte
00319C  1               LAB_1985:
00319C  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0031A0  1               LAB_1988:
0031A0  1  24 5F                BIT     <Dtypef         ; test data type flag, $FF=string, $00=numeric
0031A2  1  10 24                BPL     LAB_19B0        ; branch if numeric
0031A4  1               
0031A4  1               ; else get string
0031A4  1  85 5B                STA     <Srchc          ; save search character
0031A6  1  C9 22                CMP     #$22            ; was it " ?
0031A8  1  F0 07                BEQ     LAB_1999        ; branch if so
0031AA  1               
0031AA  1  A9 3A                LDA     #':'            ; else search character is ":"
0031AC  1  85 5B                STA     <Srchc          ; set new search character
0031AE  1  A9 2C                LDA     #','            ; other search character is ","
0031B0  1  18                   CLC                     ; clear carry for add
0031B1  1               LAB_1999:
0031B1  1  85 5C                STA     <Asrch          ; set second search character
0031B3  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte
0031B5  1  A4 C4                LDY     <Bpntrh         ; get BASIC execute pointer high byte
0031B7  1               
0031B7  1  69 00                ADC     #$00            ; c is =1 if we came via the BEQ LAB_1999, else =0
0031B9  1  90 01                BCC     LAB_19A4        ; branch if no execute pointer low byte rollover
0031BB  1               
0031BB  1  C8                   INY                     ; else increment high byte
0031BC  1               LAB_19A4:
0031BC  1  20 7E 3A             JSR     LAB_20B4        ; print <Srchc or <Asrch terminated string to <Sutill/<Sutilh
0031BF  1  20 60 40             JSR     LAB_23F3        ; restore BASIC execute pointer from temp (<Btmpl/<Btmph)
0031C2  1  20 E1 2E             JSR     LAB_17D5        ; go do string LET
0031C5  1  4C CE 31             JMP     LAB_19B6        ; go check string terminator
0031C8  1               
0031C8  1               ; get numeric INPUT
0031C8  1               LAB_19B0:
0031C8  1  20 E9 46             JSR     LAB_2887        ; get FAC1 from string
0031CB  1  20 32 45             JSR     LAB_PFAC        ; pack FAC1 into (<Lvarpl)
0031CE  1               LAB_19B6:
0031CE  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0031D2  1  F0 0B                BEQ     LAB_19C5        ; branch if null (last entry)
0031D4  1               
0031D4  1  C9 2C                CMP     #','            ; else compare with ","
0031D6  1  F0 03                BEQ     LAB_19C2        ; branch if ","
0031D8  1               
0031D8  1  4C 33 31             JMP     LAB_1904        ; else go handle bad input data
0031DB  1               
0031DB  1               ; got good input data
0031DB  1               LAB_19C2:
0031DB  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
0031DF  1               LAB_19C5:
0031DF  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
0031E1  1  A4 C4                LDY     <Bpntrh         ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
0031E3  1  85 91                STA     <Rdptrl         ; save for now
0031E5  1  84 92                STY     <Rdptrh         ; save for now
0031E7  1  A5 11                LDA     <Itempl         ; get temporary integer low byte (temp BASIC execute ptr)
0031E9  1  A4 12                LDY     <Itemph         ; get temporary integer high byte (temp BASIC execute ptr)
0031EB  1  85 C3                STA     <Bpntrl         ; set BASIC execute pointer low byte
0031ED  1  84 C4                STY     <Bpntrh         ; set BASIC execute pointer high byte
0031EF  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0031F3  1  F0 30                BEQ     LAB_1A03        ; if null go do extra ignored message
0031F5  1               
0031F5  1  20 64 34             JSR     LAB_1C01        ; else scan for "," , else do syntax error then warm start
0031F8  1  4C 77 31             JMP     LAB_195B        ; go INPUT next variable from list
0031FB  1               
0031FB  1               ; find next DATA statement or do "Out of DATA" error
0031FB  1               LAB_19DD:
0031FB  1  20 B1 2D             JSR     LAB_SNBS        ; scan for next BASIC statement ([:] or [EOL])
0031FE  1  C8                   INY                     ; increment index
0031FF  1  AA                   TAX                     ; copy character ([:] or [EOL])
003200  1  D0 15                BNE     LAB_19F6        ; branch if [:]
003202  1               
003202  1  A2 06                LDX     #$06            ; set for "Out of DATA" error
003204  1  C8                   INY                     ; increment index, now points to next line pointer high byte
003205  1  B1 C3                LDA     (<Bpntrl),Y     ; get next line pointer high byte
003207  1  D0 03                BNE     LAB_19DE        ; branch if NOT end (eventually does error X)
003209  1  4C C1 32             JMP     LAB_1A54
00320C  1               LAB_19DE:
00320C  1  C8                   INY                     ; increment index
00320D  1  B1 C3                LDA     (<Bpntrl),Y     ; get next line # low byte
00320F  1  85 8D                STA     <Dlinel         ; save current DATA line low byte
003211  1  C8                   INY                     ; increment index
003212  1  B1 C3                LDA     (<Bpntrl),Y     ; get next line # high byte
003214  1  C8                   INY                     ; increment index
003215  1  85 8E                STA     <Dlineh         ; save current DATA line high byte
003217  1               LAB_19F6:
003217  1  B1 C3                LDA     (<Bpntrl),Y     ; get byte
003219  1  C8                   INY                     ; increment index
00321A  1  AA                   TAX                     ; copy to X
00321B  1  20 A3 2D             JSR     LAB_170F        ; set BASIC execute pointer
00321E  1  E0 83                CPX     #TK_DATA        ; compare with "DATA" token
003220  1  D0 D9                BNE     LAB_19DD        ; go find next statement if not "DATA"
003222  1  4C 9C 31             JMP     LAB_1985        ; was "DATA" so go do next READ
003225  1               
003225  1               ; end of INPUT/READ routine
003225  1               
003225  1               LAB_1A03:
003225  1  A5 91                LDA     <Rdptrl         ; get temp READ pointer low byte
003227  1  A4 92                LDY     <Rdptrh         ; get temp READ pointer high byte
003229  1  A6 62                LDX     <Imode          ; get input mode flag, $00=INPUT, $80=READ
00322B  1  10 03                BPL     LAB_1A0E        ; branch if INPUT
00322D  1               
00322D  1  4C 5B 2C             JMP     LAB_1624        ; save AY as DATA pointer and return
003230  1               
003230  1               ; we were getting INPUT
003230  1               LAB_1A0E:
003230  1  A0 00                LDY     #$00            ; clear index
003232  1  8B DA A2 01          LDAINDIRECTY Rdptrl     ; get next byte
003236  1  B5 91 C9 00  
00323A  1  D0 04 A2 00  
003248  1  D0 01                BNE     LAB_1A1B        ; error if not end of INPUT
00324A  1               
00324A  1  60                   RTS
00324B  1               
00324B  1               ; user typed too much
00324B  1               LAB_1A1B:
00324B  1  A9 E5                LDA     #<LAB_IMSG      ; point to extra ignored message (low addr)
00324D  1  A0 17                LDY     #>LAB_IMSG      ; point to extra ignored message (high addr)
00324F  1  4C CA 30             JMP     LAB_18C3        ; print null terminated string from memory and return
003252  1               
003252  1               ; search the stack for FOR activity
003252  1               ; exit with z=1 if FOR else exit with z=0
003252  1               
003252  1               LAB_11A1:
003252  1  C2 10                INDEX16
003254  1  BA                   TSX                     ; copy stack pointer
003255  1  E8                   INX                     ; +1 pass return address
003256  1  E8                   INX                     ; +2 pass return address
003257  1  E8                   INX                     ; +3 pass calling routine return address
003258  1  E8                   INX                     ; +4 pass calling routine return address
003259  1               LAB_11A6:
003259  1  8B                   PHB
00325A  1  A9 00                LDA     #$00            ; WANT TO ACCESS ZERO BANK FOR STACK
00325C  1  48                   PHA
00325D  1  AB                   PLB
00325E  1  B5 01                LDA     1,X             ; get token byte from stack
003260  1  AB                   PLB
003261  1  C9 81                CMP     #TK_FOR         ; is it FOR token
003263  1  D0 43                BNE     LAB_11CE        ; exit if not FOR token
003265  1               
003265  1               ; was FOR token
003265  1  A5 98                LDA     <Frnxth         ; get var pointer for FOR/NEXT high byte
003267  1  D0 0E                BNE     LAB_11BB        ; branch if not null
003269  1               
003269  1  8B                   PHB
00326A  1  A9 00                LDA     #$00            ; WANT TO ACCESS ZERO BANK FOR STACK
00326C  1  48                   PHA
00326D  1  AB                   PLB
00326E  1  B5 02                LDA     2,X             ; get FOR variable pointer low byte
003270  1  85 97                STA     <Frnxtl         ; save var pointer for FOR/NEXT low byte
003272  1  B5 03                LDA     3,X             ; get FOR variable pointer high byte
003274  1  85 98                STA     <Frnxth         ; save var pointer for FOR/NEXT high byte
003276  1  AB                   PLB
003277  1               LAB_11BB:
003277  1  8B                   PHB
003278  1  A9 00                LDA     #$00            ; WANT TO ACCESS ZERO BANK FOR STACK
00327A  1  48                   PHA
00327B  1  AB                   PLB
00327C  1  B5 03                LDA     3,X
00327E  1  85 04                STA     <TMPFLG
003280  1  AB                   PLB
003281  1  C5 04                CMP     <TMPFLG         ; compare var pointer with stacked var pointer (high byte)
003283  1  D0 10                BNE     LAB_11C7        ; branch if no match
003285  1               
003285  1  A5 97                LDA     <Frnxtl         ; get var pointer for FOR/NEXT low byte
003287  1  8B                   PHB
003288  1  A9 00                LDA     #$00            ; WANT TO ACCESS ZERO BANK FOR STACK
00328A  1  48                   PHA
00328B  1  AB                   PLB
00328C  1  B5 02                LDA     2,X
00328E  1  85 04                STA     <TMPFLG
003290  1  AB                   PLB
003291  1  C5 04                CMP     <TMPFLG         ; compare var pointer with stacked var pointer (high byte)
003293  1  F0 13                BEQ     LAB_11CE        ; exit if match found
003295  1               
003295  1               LAB_11C7:
003295  1  E8                   INX
003296  1  E8                   INX
003297  1  E8                   INX
003298  1  E8                   INX
003299  1  E8                   INX
00329A  1  E8                   INX
00329B  1  E8                   INX
00329C  1  E8                   INX
00329D  1  E8                   INX
00329E  1  E8                   INX
00329F  1  E8                   INX
0032A0  1  E8                   INX
0032A1  1  E8                   INX
0032A2  1  E8                   INX
0032A3  1  E8                   INX
0032A4  1  E8                   INX
0032A5  1  9A                   TXS                     ; copy back to index
0032A6  1  D0 B1                BNE     LAB_11A6        ; loop if not at start of stack
0032A8  1               LAB_11CE:
0032A8  1  86 FD                STX     <TEMPW
0032AA  1  E2 10                INDEX8
0032AC  1  60                   RTS
0032AD  1               
0032AD  1               ; perform NEXT
0032AD  1               
0032AD  1               LAB_NEXT:
0032AD  1  D0 04                BNE     LAB_1A46        ; branch if NEXT var
0032AF  1               
0032AF  1  A0 00                LDY     #$00            ; else clear Y
0032B1  1  F0 03                BEQ     LAB_1A49        ; branch always (no variable to search for)
0032B3  1               
0032B3  1               ; NEXT var
0032B3  1               
0032B3  1               LAB_1A46:
0032B3  1  20 3F 36             JSR     LAB_GVAR        ; get variable address
0032B6  1               LAB_1A49:
0032B6  1  85 97                STA     <Frnxtl         ; store variable pointer low byte
0032B8  1  84 98                STY     <Frnxth         ; store variable pointer high byte
0032BA  1               ; (both cleared if no variable defined)
0032BA  1  20 52 32             JSR     LAB_11A1        ; search the stack for FOR activity
0032BD  1  F0 04                BEQ     LAB_1A56        ; branch if found
0032BF  1               
0032BF  1  A2 00                LDX     #$00            ; else set error $00 ("NEXT without FOR" error)
0032C1  1               LAB_1A54:
0032C1  1  F0 7C                BEQ     LAB_1ABE        ; do error #X, then warm start
0032C3  1               
0032C3  1               
0032C3  1               LAB_1A56:
0032C3  1  C2 30                ACCUMULATORINDEX16
0032C5  1  A6 FD                LDX     <TEMPW
0032C7  1  9A                   TXS                     ; set stack pointer, X set by search, dumps return addresses
0032C8  1  8A                   TXA                     ; copy stack pointer
0032C9  1  18                   CLC                     ; CLEAR carry
0032CA  1               
0032CA  1  69 09 00             ADC     #$0009          ; point to TO var
0032CD  1  85 73                STA     <ut2_pl         ; save pointer to TO var for compare
0032CF  1  38                   SEC
0032D0  1  E9 05 00             SBC     #$0005          ; point to STEP var
0032D3  1  85 FD                STA     <TEMPW
0032D5  1               
0032D5  1  E2 30                ACCUMULATORINDEX8
0032D7  1  A4 FE                LDY     <TEMPW+1        ; point to stack page high byte
0032D9  1               
0032D9  1  8B                   PHB                     ; ensure UNPACK works in stack bank not data bank
0032DA  1  DA                   PHX
0032DB  1  A2 00                LDX     #$00
0032DD  1  DA                   PHX
0032DE  1  AB                   PLB
0032DF  1  FA                   PLX
0032E0  1  20 BC 44             JSR     LAB_UFAC        ; unpack memory (STEP value) into FAC1
0032E3  1  AB                   PLB
0032E4  1               
0032E4  1  A3 08                LDA     8,S             ; get step sign
0032E6  1  85 B0                STA     <FAC1_s         ; save FAC1 sign (b7)
0032E8  1  A5 97                LDA     <Frnxtl         ; get FOR variable pointer low byte
0032EA  1  A4 98                LDY     <Frnxth         ; get FOR variable pointer high byte
0032EC  1  20 A7 41             JSR     LAB_246C        ; add (FOR variable) to FAC1
0032EF  1  20 32 45             JSR     LAB_PFAC        ; pack FAC1 into (FOR variable)
0032F2  1  A4 FE                LDY     <TEMPW+1        ; point to stack page high byte
0032F4  1               
0032F4  1  8B                   PHB                     ; ensure compare works in stack bank not data bank
0032F5  1  DA                   PHX
0032F6  1  A2 00                LDX     #$00
0032F8  1  DA                   PHX
0032F9  1  AB                   PLB
0032FA  1  FA                   PLX
0032FB  1               
0032FB  1  20 F8 45             JSR     LAB_27FA        ; compare FAC1 with (Y,<ut2_pl) (TO value)
0032FE  1  AB                   PLB
0032FF  1               
0032FF  1               
0032FF  1  C3 08                CMP     8,S             ; compare step sign
003301  1  F0 13                BEQ     LAB_1A9B        ; branch if = (loop complete)
003303  1               ;
003303  1               ;					; loop back and do it all again
003303  1  A3 0D                LDA     $0D,S           ; get FOR line low byte
003305  1  85 87                STA     <Clinel         ; save current line low byte
003307  1  A3 0E                LDA     $0E,S           ; get FOR line high byte
003309  1  85 88                STA     <Clineh         ; save current line high byte
00330B  1  A3 10                LDA     $10,S           ; get BASIC execute pointer low byte
00330D  1  85 C3                STA     <Bpntrl         ; save BASIC execute pointer low byte
00330F  1  A3 0F                LDA     $0F,S           ; get BASIC execute pointer high byte
003311  1  85 C4                STA     <Bpntrh         ; save BASIC execute pointer high byte
003313  1               LAB_1A98:
003313  1  4C BB 2B             JMP     LAB_15C2        ; go do interpreter inner loop
003316  1               ;
003316  1               ;					; loop complete so carry on
003316  1               LAB_1A9B:
003316  1               
003316  1               
003316  1  C2 30                ACCUMULATORINDEX16
003318  1  3B                   TSC                     ; stack copy to A
003319  1               ;;;;;;;;;;;;;;;;;;; THIS MAY NOT BE RIGHT !@#$%^&* TAG
003319  1  69 0F 00             ADC     #$000F          ; add $10 ($0F+carry) to dump FOR structure
00331C  1  1B                   TCS                     ; copy back to index
00331D  1  E2 30                ACCUMULATORINDEX8
00331F  1               
00331F  1               
00331F  1               
00331F  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
003323  1  C9 2C                CMP     #','            ; compare with ","
003325  1  D0 EC                BNE     LAB_1A98        ; branch if not "," (go do interpreter inner loop)
003327  1               
003327  1               ; was "," so another NEXT variable to do
003327  1  22 BC 00 00          JSL     LAB_IGBY        ; else increment and scan memory
00332B  1  20 B3 32             JSR     LAB_1A46        ; do NEXT (var)
00332E  1               
00332E  1               ; evaluate expression and check is numeric, else do type mismatch
00332E  1               
00332E  1               LAB_EVNM:
00332E  1  20 42 33             JSR     LAB_EVEX        ; evaluate expression
003331  1               
003331  1               ; check if source is numeric, else do type mismatch
003331  1               
003331  1               LAB_CTNM:
003331  1  18                   CLC                     ; destination is numeric
003332  1  24                   .BYTE   $24             ; makes next line BIT $38
003333  1               
003333  1               ; check if source is string, else do type mismatch
003333  1               
003333  1               LAB_CTST:
003333  1  38                   SEC                     ; required type is string
003334  1               
003334  1               ; type match check, set C for string, clear C for numeric
003334  1               
003334  1               LAB_CKTM:
003334  1  24 5F                BIT     <Dtypef         ; test data type flag, $FF=string, $00=numeric
003336  1  30 03                BMI     LAB_1ABA        ; branch if data type is string
003338  1               
003338  1               ; else data type was numeric
003338  1  B0 03                BCS     LAB_1ABC        ; if required type is string do type mismatch error
00333A  1               LAB_1AB9:
00333A  1  60                   RTS
00333B  1               
00333B  1               ; data type was string, now check required type
00333B  1               LAB_1ABA:
00333B  1  B0 FD                BCS     LAB_1AB9        ; exit if required type is string
00333D  1               
00333D  1               ; else do type mismatch error
00333D  1               LAB_1ABC:
00333D  1  A2 18                LDX     #$18            ; error code $18 ("Type mismatch" error)
00333F  1               LAB_1ABE:
00333F  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
003342  1               
003342  1               ; evaluate expression
003342  1               
003342  1               LAB_EVEX:
003342  1  A6 C3                LDX     <Bpntrl         ; get BASIC execute pointer low byte
003344  1  D0 02                BNE     LAB_1AC7        ; skip next if not zero
003346  1               
003346  1  C6 C4                DEC     <Bpntrh         ; else decrement BASIC execute pointer high byte
003348  1               LAB_1AC7:
003348  1  C6 C3                DEC     <Bpntrl         ; decrement BASIC execute pointer low byte
00334A  1               
00334A  1               LAB_EVEZ:
00334A  1  A9 00                LDA     #$00            ; set null precedence (flag done)
00334C  1               LAB_1ACC:
00334C  1  48                   PHA                     ; push precedence byte
00334D  1  A9 02                LDA     #$02            ; 2 bytes
00334F  1  20 BF 27             JSR     LAB_1212        ; check room on stack for A bytes
003352  1  20 30 34             JSR     LAB_GVAL        ; get value from line
003355  1  A9 00                LDA     #$00            ; clear A
003357  1  85 9B                STA     <comp_f         ; clear compare function flag
003359  1               LAB_1ADB:
003359  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
00335D  1               LAB_1ADE:
00335D  1  38                   SEC                     ; set carry for subtract
00335E  1  E9 D5                SBC     #TK_GT          ; subtract token for > (lowest comparison function)
003360  1  90 18                BCC     LAB_1AFA        ; branch if < TK_GT
003362  1               
003362  1  C9 03                CMP     #$03            ; compare with ">" to "<" tokens
003364  1  B0 14                BCS     LAB_1AFA        ; branch if >= TK_SGN (highest evaluation function +1)
003366  1               
003366  1               ; was token for > = or < (A = 0, 1 or 2)
003366  1  C9 01                CMP     #$01            ; compare with token for =
003368  1  2A                   ROL     A               ; *2, b0 = carry (=1 if token was = or <)
003369  1               ; (A = 0, 3 or 5)
003369  1  49 01                EOR     #$01            ; toggle b0
00336B  1               ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
00336B  1  45 9B                EOR     <comp_f         ; EOR with compare function flag bits
00336D  1  C5 9B                CMP     <comp_f         ; compare with compare function flag
00336F  1  90 68                BCC     LAB_1B53        ; if <(<comp_f) do syntax error then warm start
003371  1               ; was more than one <, = or >)
003371  1               
003371  1  85 9B                STA     <comp_f         ; save new compare function flag
003373  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003377  1  4C 5D 33             JMP     LAB_1ADE        ; go do next character
00337A  1               
00337A  1               ; token is < ">" or > "<" tokens
00337A  1               LAB_1AFA:
00337A  1  A6 9B                LDX     <comp_f         ; get compare function flag
00337C  1  D0 2C                BNE     LAB_1B2A        ; branch if compare function
00337E  1               
00337E  1  B0 79                BCS     LAB_1B78        ; go do functions
003380  1               
003380  1               ; else was <  TK_GT so is operator or lower
003380  1  69 0A                ADC     #TK_GT-TK_PLUS  ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
003382  1  90 75                BCC     LAB_1B78        ; branch if < + operator
003384  1               
003384  1               ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
003384  1  D0 07                BNE     LAB_1B0B        ; branch if not + token
003386  1               
003386  1  24 5F                BIT     <Dtypef         ; test data type flag, $FF=string, $00=numeric
003388  1  10 03                BPL     LAB_1B0B        ; branch if not string
00338A  1               
00338A  1               ; will only be $00 if type is string and token was +
00338A  1  4C 5C 3C             JMP     LAB_224D        ; add strings, string 1 is in descriptor <des_pl, string 2
00338D  1               ; is in line, and return
00338D  1               
00338D  1               LAB_1B0B:
00338D  1  85 71                STA     <ut1_pl         ; save it
00338F  1  0A                   ASL     A               ; *2
003390  1  65 71                ADC     <ut1_pl         ; *3
003392  1  A8                   TAY                     ; copy to index
003393  1               LAB_1B13:
003393  1  68                   PLA                     ; pull previous precedence
003394  1  D9 4C 11             CMP     LAB_OPPT,Y      ; compare with precedence byte
003397  1  B0 65                BCS     LAB_1B7D        ; branch if A >=
003399  1               
003399  1  20 31 33             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
00339C  1               LAB_1B1C:
00339C  1  48                   PHA                     ; save precedence
00339D  1               LAB_1B1D:
00339D  1  20 C5 33             JSR     LAB_1B43        ; get vector, execute function then continue evaluation
0033A0  1  68                   PLA                     ; restore precedence
0033A1  1  A4 99                LDY     <prstk          ; get precedence stacked flag
0033A3  1  10 19                BPL     LAB_1B3C        ; branch if stacked values
0033A5  1               
0033A5  1  AA                   TAX                     ; copy precedence (set flags)
0033A6  1  F0 76                BEQ     LAB_1B9D        ; exit if done
0033A8  1               
0033A8  1  D0 5D                BNE     LAB_1B86        ; else pop FAC2 and return, branch always
0033AA  1               
0033AA  1               LAB_1B2A:
0033AA  1  26 5F                ROL     <Dtypef         ; shift data type flag into Cb
0033AC  1  8A                   TXA                     ; copy compare function flag
0033AD  1  85 5F                STA     <Dtypef         ; clear data type flag, X is 0xxx xxxx
0033AF  1  2A                   ROL     A               ; shift data type into compare function byte b0
0033B0  1  A6 C3                LDX     <Bpntrl         ; get BASIC execute pointer low byte
0033B2  1  D0 02                BNE     LAB_1B34        ; branch if no underflow
0033B4  1               
0033B4  1  C6 C4                DEC     <Bpntrh         ; else decrement BASIC execute pointer high byte
0033B6  1               LAB_1B34:
0033B6  1  C6 C3                DEC     <Bpntrl         ; decrement BASIC execute pointer low byte
0033B8  1               TK_LT_PLUS      = TK_LT-TK_PLUS
0033B8  1  A0 24                LDY     #TK_LT_PLUS*3   ; set offset to last operator entry
0033BA  1  85 9B                STA     <comp_f         ; save new compare function flag
0033BC  1  D0 D5                BNE     LAB_1B13        ; branch always
0033BE  1               
0033BE  1               LAB_1B3C:
0033BE  1  D9 4C 11             CMP     LAB_OPPT,Y      ;.compare with stacked function precedence
0033C1  1  B0 44                BCS     LAB_1B86        ; branch if A >=, pop FAC2 and return
0033C3  1               
0033C3  1  90 D7                BCC     LAB_1B1C        ; branch always
0033C5  1               
0033C5  1               ;.get vector, execute function then continue evaluation
0033C5  1               
0033C5  1               LAB_1B43:
0033C5  1  B9 4E 11             LDA     LAB_OPPT+2,Y    ; get function vector high byte
0033C8  1  48                   PHA                     ; onto stack
0033C9  1  B9 4D 11             LDA     LAB_OPPT+1,Y    ; get function vector low byte
0033CC  1  48                   PHA                     ; onto stack
0033CD  1               ; now push sign, round FAC1 and put on stack
0033CD  1  20 DC 33             JSR     LAB_1B5B        ; function will return here, then the next RTS will call
0033D0  1               ; the function
0033D0  1  A5 9B                LDA     <comp_f         ; get compare function flag
0033D2  1  48                   PHA                     ; push compare evaluation byte
0033D3  1  B9 4C 11             LDA     LAB_OPPT,Y      ; get precedence byte
0033D6  1  4C 4C 33             JMP     LAB_1ACC        ; continue evaluating expression
0033D9  1               
0033D9  1               LAB_1B53:
0033D9  1  4C 68 34             JMP     LAB_SNER        ; do syntax error then warm start
0033DC  1               
0033DC  1               ; push sign, round FAC1 and put on stack
0033DC  1               
0033DC  1               LAB_1B5B:
0033DC  1  68                   PLA                     ; get return addr low byte
0033DD  1  85 71                STA     <ut1_pl         ; save it
0033DF  1  E6 71                INC     <ut1_pl         ; increment it (was ret-1 pushed? yes!)
0033E1  1               ; note! no check is made on the high byte! if the calling
0033E1  1               ; routine assembles to a page edge then this all goes
0033E1  1               ; horribly wrong !!!
0033E1  1  68                   PLA                     ; get return addr high byte
0033E2  1  85 72                STA     <ut1_ph         ; save it
0033E4  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
0033E6  1  48                   PHA                     ; push sign
0033E7  1               
0033E7  1               ; round FAC1 and put on stack
0033E7  1               
0033E7  1               LAB_1B66:
0033E7  1  20 B8 45             JSR     LAB_27BA        ; round FAC1
0033EA  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
0033EC  1  48                   PHA                     ; push on stack
0033ED  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
0033EF  1  48                   PHA                     ; push on stack
0033F0  1  A5 AD                LDA     <FAC1_1         ; get FAC1 mantissa1
0033F2  1  48                   PHA                     ; push on stack
0033F3  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
0033F5  1  48                   PHA                     ; push on stack
0033F6  1  6C 71 00             JMP     (ut1_pl)        ; return, sort of
0033F9  1               
0033F9  1               ; do functions
0033F9  1               
0033F9  1               LAB_1B78:
0033F9  1  A0 FF                LDY     #$FF            ; flag function
0033FB  1  68                   PLA                     ; pull precedence byte
0033FC  1               LAB_1B7B:
0033FC  1  F0 20                BEQ     LAB_1B9D        ; exit if done
0033FE  1               
0033FE  1               LAB_1B7D:
0033FE  1  C9 64                CMP     #$64            ; compare previous precedence with $64
003400  1  F0 03                BEQ     LAB_1B84        ; branch if was $64 (< function)
003402  1               
003402  1  20 31 33             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
003405  1               LAB_1B84:
003405  1  84 99                STY     <prstk          ; save precedence stacked flag
003407  1               
003407  1               ; pop FAC2 and return
003407  1               LAB_1B86:
003407  1  68                   PLA                     ; pop byte
003408  1  4A                   LSR     A               ; shift out comparison evaluation lowest bit
003409  1  85 63                STA     <Cflag          ; save comparison evaluation flag
00340B  1  68                   PLA                     ; pop exponent
00340C  1  85 B3                STA     <FAC2_e         ; save FAC2 exponent
00340E  1  68                   PLA                     ; pop mantissa1
00340F  1  85 B4                STA     <FAC2_1         ; save FAC2 mantissa1
003411  1  68                   PLA                     ; pop mantissa2
003412  1  85 B5                STA     <FAC2_2         ; save FAC2 mantissa2
003414  1  68                   PLA                     ; pop mantissa3
003415  1  85 B6                STA     <FAC2_3         ; save FAC2 mantissa3
003417  1  68                   PLA                     ; pop sign
003418  1  85 B7                STA     <FAC2_s         ; save FAC2 sign (b7)
00341A  1  45 B0                EOR     <FAC1_s         ; EOR FAC1 sign (b7)
00341C  1  85 B8                STA     <FAC_sc         ; save sign compare (FAC1 EOR FAC2)
00341E  1               LAB_1B9D:
00341E  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
003420  1  60                   RTS
003421  1               
003421  1               ; print "..." string to string util area
003421  1               
003421  1               LAB_1BC1:
003421  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte
003423  1  A4 C4                LDY     <Bpntrh         ; get BASIC execute pointer high byte
003425  1  69 00                ADC     #$00            ; add carry to low byte
003427  1  90 01                BCC     LAB_1BCA        ; branch if no overflow
003429  1               
003429  1  C8                   INY                     ; increment high byte
00342A  1               LAB_1BCA:
00342A  1  20 78 3A             JSR     LAB_20AE        ; print " terminated string to <Sutill/<Sutilh
00342D  1  4C 60 40             JMP     LAB_23F3        ; restore BASIC execute pointer from temp and return
003430  1               
003430  1               ; get value from line
003430  1               
003430  1               LAB_GVAL:
003430  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003434  1  B0 03                BCS     LAB_1BAC        ; branch if not numeric character
003436  1               
003436  1               ; else numeric string found (e.g. 123)
003436  1               LAB_1BA9:
003436  1  4C E9 46             JMP     LAB_2887        ; get FAC1 from string and return
003439  1               
003439  1               ; get value from line .. continued
003439  1               
003439  1               ; wasn't a number so ..
003439  1               LAB_1BAC:
003439  1  AA                   TAX                     ; set the flags
00343A  1  30 31                BMI     LAB_1BD0        ; if -ve go test token values
00343C  1               
00343C  1               ; else it is either a string, number, variable or (<expr>)
00343C  1  C9 24                CMP     #'$'            ; compare with "$"
00343E  1  F0 F6                BEQ     LAB_1BA9        ; branch if "$", hex number
003440  1               
003440  1  C9 25                CMP     #'%'            ; else compare with "%"
003442  1  F0 F2                BEQ     LAB_1BA9        ; branch if "%", binary number
003444  1               
003444  1  C9 2E                CMP     #'.'            ; compare with "."
003446  1  F0 EE                BEQ     LAB_1BA9        ; if so get FAC1 from string and return (e.g. was .123)
003448  1               
003448  1               ; it wasn't any sort of number so ..
003448  1  C9 22                CMP     #$22            ; compare with "
00344A  1  F0 D5                BEQ     LAB_1BC1        ; branch if open quote
00344C  1               
00344C  1               ; wasn't any sort of number so ..
00344C  1               
00344C  1               ; evaluate expression within parentheses
00344C  1               
00344C  1  C9 28                CMP     #'('            ; compare with "("
00344E  1  D0 51                BNE     LAB_1C18        ; if not "(" get (var), return value in FAC1 and $ flag
003450  1               
003450  1               LAB_1BF7:
003450  1  20 4A 33             JSR     LAB_EVEZ        ; evaluate expression, no decrement
003453  1               
003453  1               ; all the 'scan for' routines return the character after the sought character
003453  1               
003453  1               ; scan for ")" , else do syntax error then warm start
003453  1               
003453  1               LAB_1BFB:
003453  1  A9 29                LDA     #$29            ; load A with ")"
003455  1               
003455  1               ; scan for CHR$(A) , else do syntax error then warm start
003455  1               
003455  1               LAB_SCCA:
003455  1  A0 00                LDY     #$00            ; clear index
003457  1  D1 C3                CMP     (<Bpntrl),Y     ; check next byte is = A
003459  1  D0 0D                BNE     LAB_SNER        ; if not do syntax error then warm start
00345B  1               
00345B  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory then return
00345F  1  60                   RTS
003460  1               ; scan for "(" , else do syntax error then warm start
003460  1               
003460  1               LAB_1BFE:
003460  1  A9 28                LDA     #$28            ; load A with "("
003462  1  D0 F1                BNE     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
003464  1               ; (branch always)
003464  1               
003464  1               ; scan for "," , else do syntax error then warm start
003464  1               
003464  1               LAB_1C01:
003464  1  A9 2C                LDA     #$2C            ; load A with ","
003466  1  D0 ED                BNE     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
003468  1               ; (branch always)
003468  1               
003468  1               ; syntax error then warm start
003468  1               
003468  1               LAB_SNER:
003468  1  A2 02                LDX     #$02            ; error code $02 ("Syntax" error)
00346A  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
00346D  1               
00346D  1               ; get value from line .. continued
00346D  1               ; do tokens
00346D  1               
00346D  1               LAB_1BD0:
00346D  1  C9 CC                CMP     #TK_MINUS       ; compare with token for -
00346F  1  F0 29                BEQ     LAB_1C11        ; branch if - token (do set-up for functions)
003471  1               
003471  1               ; wasn't -n so ..
003471  1  C9 CB                CMP     #TK_PLUS        ; compare with token for +
003473  1  F0 BB                BEQ     LAB_GVAL        ; branch if + token (+n = n so ignore leading +)
003475  1               
003475  1  C9 C6                CMP     #TK_NOT         ; compare with token for NOT
003477  1  D0 13                BNE     LAB_1BE7        ; branch if not token for NOT
003479  1               
003479  1               ; was NOT token
003479  1               TK_EQUAL_PLUS   = TK_EQUAL-TK_PLUS
003479  1  A0 21                LDY     #TK_EQUAL_PLUS*3; offset to NOT function
00347B  1  D0 1F                BNE     LAB_1C13        ; do set-up for function then execute (branch always)
00347D  1               
00347D  1               ; do = compare
00347D  1               
00347D  1               LAB_EQUAL:
00347D  1  20 40 37             JSR     LAB_EVIR        ; evaluate integer expression (no sign check)
003480  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
003482  1  49 FF                EOR     #$FF            ; invert it
003484  1  A8                   TAY                     ; copy it
003485  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
003487  1  49 FF                EOR     #$FF            ; invert it
003489  1  4C FD 38             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
00348C  1               
00348C  1               ; get value from line .. continued
00348C  1               
00348C  1               ; wasn't +, -, or NOT so ..
00348C  1               LAB_1BE7:
00348C  1  C9 C3                CMP     #TK_FN          ; compare with token for FN
00348E  1  D0 03                BNE     LAB_1BEE        ; branch if not token for FN
003490  1               
003490  1  4C 5B 39             JMP     LAB_201E        ; go evaluate FNx
003493  1               
003493  1               ; get value from line .. continued
003493  1               
003493  1               ; wasn't +, -, NOT or FN so ..
003493  1               LAB_1BEE:
003493  1  E9 D8                SBC     #TK_SGN         ; subtract with token for SGN
003495  1  B0 19                BCS     LAB_1C27        ; if a function token go do it
003497  1               
003497  1  4C 68 34             JMP     LAB_SNER        ; else do syntax error
00349A  1               
00349A  1               ; set-up for functions
00349A  1               
00349A  1               LAB_1C11:
00349A  1               TK_GT_PLUS      = TK_GT-TK_PLUS
00349A  1  A0 1E                LDY     #TK_GT_PLUS*3   ; set offset from base to > operator
00349C  1               LAB_1C13:
00349C  1  68                   PLA                     ; dump return address low byte
00349D  1  68                   PLA                     ; dump return address high byte
00349E  1  4C 9D 33             JMP     LAB_1B1D        ; execute function then continue evaluation
0034A1  1               
0034A1  1               ; variable name set-up
0034A1  1               ; get (var), return value in FAC_1 and $ flag
0034A1  1               
0034A1  1               LAB_1C18:
0034A1  1  20 3F 36             JSR     LAB_GVAR        ; get (var) address
0034A4  1  85 AE                STA     <FAC1_2         ; save address low byte in FAC1 mantissa2
0034A6  1  84 AF                STY     <FAC1_3         ; save address high byte in FAC1 mantissa3
0034A8  1  A6 5F                LDX     <Dtypef         ; get data type flag, $FF=string, $00=numeric
0034AA  1  30 03                BMI     LAB_1C25        ; if string then return (does RTS)
0034AC  1               
0034AC  1               LAB_1C24:
0034AC  1  4C BC 44             JMP     LAB_UFAC        ; unpack memory (AY) into FAC1
0034AF  1               
0034AF  1               LAB_1C25:
0034AF  1  60                   RTS
0034B0  1               
0034B0  1               ; get value from line .. continued
0034B0  1               ; only functions left so ..
0034B0  1               
0034B0  1               ; set up function references
0034B0  1               
0034B0  1               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
0034B0  1               ; to process function calls. now the function vector is computed and pushed on the stack
0034B0  1               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
0034B0  1               ; is calculated and the routine called, if not this routine just does RTS. whichever
0034B0  1               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
0034B0  1               ; the function code
0034B0  1               
0034B0  1               ; this also removes some less than elegant code that was used to bypass type checking
0034B0  1               ; for functions that returned strings
0034B0  1               
0034B0  1               LAB_1C27:
0034B0  1  0A                   ASL     A               ; *2 (2 bytes per function address)
0034B1  1  A8                   TAY                     ; copy to index
0034B2  1               
0034B2  1  B9 03 11             LDA     LAB_FTBM,Y      ; get function jump vector high byte
0034B5  1  48                   PHA                     ; push functions jump vector high byte
0034B6  1  B9 02 11             LDA     LAB_FTBL,Y      ; get function jump vector low byte
0034B9  1  48                   PHA                     ; push functions jump vector low byte
0034BA  1               
0034BA  1  B9 B9 10             LDA     LAB_FTPM,Y      ; get function pre process vector high byte
0034BD  1  F0 05                BEQ     LAB_1C56        ; skip pre process if null vector
0034BF  1               
0034BF  1  48                   PHA                     ; push functions pre process vector high byte
0034C0  1  B9 B8 10             LDA     LAB_FTPL,Y      ; get function pre process vector low byte
0034C3  1  48                   PHA                     ; push functions pre process vector low byte
0034C4  1               
0034C4  1               LAB_1C56:
0034C4  1  60                   RTS                     ; do function, or pre process, call
0034C5  1               
0034C5  1               ; process string expression in parenthesis
0034C5  1               
0034C5  1               LAB_PPFS:
0034C5  1  20 50 34             JSR     LAB_1BF7        ; process expression in parenthesis
0034C8  1  4C 33 33             JMP     LAB_CTST        ; check if source is string then do function,
0034CB  1               ; else do type mismatch
0034CB  1               
0034CB  1               ; process numeric expression in parenthesis
0034CB  1               
0034CB  1               LAB_PPFN:
0034CB  1  20 50 34             JSR     LAB_1BF7        ; process expression in parenthesis
0034CE  1  4C 31 33             JMP     LAB_CTNM        ; check if source is numeric then do function,
0034D1  1               ; else do type mismatch
0034D1  1               
0034D1  1               ; set numeric data type and increment BASIC execute pointer
0034D1  1               
0034D1  1               LAB_PPBI:
0034D1  1  46 5F                LSR     <Dtypef         ; clear data type flag, $FF=string, $00=numeric
0034D3  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory then do function
0034D7  1  60                   RTS
0034D8  1               ; process string for LEFT$, RIGHT$ or MID$
0034D8  1               
0034D8  1               LAB_LRMS:
0034D8  1  20 4A 33             JSR     LAB_EVEZ        ; evaluate (should be string) expression
0034DB  1  20 64 34             JSR     LAB_1C01        ; scan for ",", else do syntax error then warm start
0034DE  1  20 33 33             JSR     LAB_CTST        ; check if source is string, else do type mismatch
0034E1  1               
0034E1  1  68                   PLA                     ; get function jump vector low byte
0034E2  1  AA                   TAX                     ; save functions jump vector low byte
0034E3  1  68                   PLA                     ; get function jump vector high byte
0034E4  1  A8                   TAY                     ; save functions jump vector high byte
0034E5  1  A5 AF                LDA     <des_ph         ; get descriptor pointer high byte
0034E7  1  48                   PHA                     ; push string pointer high byte
0034E8  1  A5 AE                LDA     <des_pl         ; get descriptor pointer low byte
0034EA  1  48                   PHA                     ; push string pointer low byte
0034EB  1  98                   TYA                     ; get function jump vector high byte back
0034EC  1  48                   PHA                     ; save functions jump vector high byte
0034ED  1  8A                   TXA                     ; get function jump vector low byte back
0034EE  1  48                   PHA                     ; save functions jump vector low byte
0034EF  1  20 DE 3F             JSR     LAB_GTBY        ; get byte parameter
0034F2  1  8A                   TXA                     ; copy byte parameter to A
0034F3  1  60                   RTS                     ; go do function
0034F4  1               
0034F4  1               ; process numeric expression(s) for BIN$ or HEX$
0034F4  1               
0034F4  1               LAB_BHSS:
0034F4  1  20 4A 33             JSR     LAB_EVEZ        ; process expression
0034F7  1  20 31 33             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
0034FA  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
0034FC  1  C9 98                CMP     #$98            ; compare with exponent = 2^24
0034FE  1  B0 22                BCS     LAB_BHER        ; branch if n>=2^24 (is too big)
003500  1               
003500  1  20 93 46             JSR     LAB_2831        ; convert FAC1 floating-to-fixed
003503  1  A2 02                LDX     #$02            ; 3 bytes to do
003505  1               LAB_CFAC:
003505  1  B5 AD                LDA     <FAC1_1,X       ; get byte from FAC1
003507  1  95 11                STA     <nums_1,X       ; save byte to temp
003509  1  CA                   DEX                     ; decrement index
00350A  1  10 F9                BPL     LAB_CFAC        ; copy FAC1 mantissa to temp
00350C  1               
00350C  1  22 C2 00 00          JSL     LAB_GBYT        ; get next BASIC byte
003510  1  A2 00                LDX     #$00            ; set default to no leading "0"s
003512  1  C9 29                CMP     #')'            ; compare with close bracket
003514  1  F0 0B                BEQ     LAB_1C54        ; if ")" go do rest of function
003516  1               
003516  1  20 6F 40             JSR     LAB_SCGB        ; scan for "," and get byte
003519  1  22 C2 00 00          JSL     LAB_GBYT        ; get last byte back
00351D  1  C9 29                CMP     #')'            ; is next character )
00351F  1  D0 01                BNE     LAB_BHER        ; if not ")" go do error
003521  1               
003521  1               LAB_1C54:
003521  1  60                   RTS                     ; else do function
003522  1               
003522  1               LAB_BHER:
003522  1  4C C7 37             JMP     LAB_FCER        ; do function call error then warm start
003525  1               
003525  1               ; perform EOR
003525  1               
003525  1               ; added operator format is the same as AND or OR, precedence is the same as OR
003525  1               
003525  1               ; this bit worked first time but it took a while to sort out the operator table
003525  1               ; pointers and offsets afterwards!
003525  1               
003525  1               LAB_EOR:
003525  1  20 4C 35             JSR     GetFirst        ; get first integer expression (no sign check)
003528  1  45 5B                EOR     <XOAw_l         ; EOR with expression 1 low byte
00352A  1  A8                   TAY                     ; save in Y
00352B  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
00352D  1  45 5C                EOR     <XOAw_h         ; EOR with expression 1 high byte
00352F  1  4C FD 38             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
003532  1               
003532  1               ; perform OR
003532  1               
003532  1               LAB_OR:
003532  1  20 4C 35             JSR     GetFirst        ; get first integer expression (no sign check)
003535  1  05 5B                ORA     <XOAw_l         ; OR with expression 1 low byte
003537  1  A8                   TAY                     ; save in Y
003538  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
00353A  1  05 5C                ORA     <XOAw_h         ; OR with expression 1 high byte
00353C  1  4C FD 38             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
00353F  1               
00353F  1               ; perform AND
00353F  1               
00353F  1               LAB_AND:
00353F  1  20 4C 35             JSR     GetFirst        ; get first integer expression (no sign check)
003542  1  25 5B                AND     <XOAw_l         ; AND with expression 1 low byte
003544  1  A8                   TAY                     ; save in Y
003545  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
003547  1  25 5C                AND     <XOAw_h         ; AND with expression 1 high byte
003549  1  4C FD 38             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
00354C  1               
00354C  1               ; get first value for OR, AND or EOR
00354C  1               
00354C  1               GetFirst:
00354C  1  20 40 37             JSR     LAB_EVIR        ; evaluate integer expression (no sign check)
00354F  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
003551  1  85 5C                STA     <XOAw_h         ; save it
003553  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
003555  1  85 5B                STA     <XOAw_l         ; save it
003557  1  20 AC 41             JSR     LAB_279B        ; copy FAC2 to FAC1 (get 2nd value in expression)
00355A  1  20 40 37             JSR     LAB_EVIR        ; evaluate integer expression (no sign check)
00355D  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
00355F  1               LAB_1C95:
00355F  1  60                   RTS
003560  1               
003560  1               ; perform comparisons
003560  1               
003560  1               ; do < compare
003560  1               
003560  1               LAB_LTHAN:
003560  1  20 34 33             JSR     LAB_CKTM        ; type match check, set C for string
003563  1  B0 13                BCS     LAB_1CAE        ; branch if string
003565  1               
003565  1               ; do numeric < compare
003565  1  A5 B7                LDA     <FAC2_s         ; get FAC2 sign (b7)
003567  1  09 7F                ORA     #$7F            ; set all non sign bits
003569  1  25 B4                AND     <FAC2_1         ; and FAC2 mantissa1 (AND in sign bit)
00356B  1  85 B4                STA     <FAC2_1         ; save FAC2 mantissa1
00356D  1  A9 B3                LDA     #<FAC2_e        ; set pointer low byte to FAC2
00356F  1  A0 00                LDY     #>FAC2_e        ; set pointer high byte to FAC2
003571  1  20 F6 45             JSR     LAB_27F8        ; compare FAC1 with FAC2 (AY)
003574  1  AA                   TAX                     ; copy result
003575  1  4C A9 35             JMP     LAB_1CE1        ; go evaluate result
003578  1               
003578  1               ; do string < compare
003578  1               LAB_1CAE:
003578  1  46 5F                LSR     <Dtypef         ; clear data type flag, $FF=string, $00=numeric
00357A  1  C6 9B                DEC     <comp_f         ; clear < bit in compare function flag
00357C  1  20 55 3D             JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
00357F  1               ; space returns with A = length, X=pointer low byte,
00357F  1               ; Y=pointer high byte
00357F  1  85 AC                STA     <str_ln         ; save length
003581  1  86 AD                STX     <str_pl         ; save string pointer low byte
003583  1  84 AE                STY     <str_ph         ; save string pointer high byte
003585  1  A5 B5                LDA     <FAC2_2         ; get descriptor pointer low byte
003587  1  A4 B6                LDY     <FAC2_3         ; get descriptor pointer high byte
003589  1  20 59 3D             JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
00358C  1               ; returns with A = length, X=pointer low byte,
00358C  1               ; Y=pointer high byte
00358C  1  86 B5                STX     <FAC2_2         ; save string pointer low byte
00358E  1  84 B6                STY     <FAC2_3         ; save string pointer high byte
003590  1  AA                   TAX                     ; copy length
003591  1  38                   SEC                     ; set carry for subtract
003592  1  E5 AC                SBC     <str_ln         ; subtract string 1 length
003594  1  F0 08                BEQ     LAB_1CD6        ; branch if str 1 length = string 2 length
003596  1               
003596  1  A9 01                LDA     #$01            ; set str 1 length > string 2 length
003598  1  90 04                BCC     LAB_1CD6        ; branch if so
00359A  1               
00359A  1  A6 AC                LDX     <str_ln         ; get string 1 length
00359C  1  A9 FF                LDA     #$FF            ; set str 1 length < string 2 length
00359E  1               LAB_1CD6:
00359E  1  85 B0                STA     <FAC1_s         ; save length compare
0035A0  1  A0 FF                LDY     #$FF            ; set index
0035A2  1  E8                   INX                     ; adjust for loop
0035A3  1               LAB_1CDB:
0035A3  1  C8                   INY                     ; increment index
0035A4  1  CA                   DEX                     ; decrement count
0035A5  1  D0 07                BNE     LAB_1CE6        ; branch if still bytes to do
0035A7  1               
0035A7  1  A6 B0                LDX     <FAC1_s         ; get length compare back
0035A9  1               LAB_1CE1:
0035A9  1  30 39                BMI     LAB_1CF2        ; branch if str 1 < str 2
0035AB  1               
0035AB  1  18                   CLC                     ; flag str 1 <= str 2
0035AC  1  90 36                BCC     LAB_1CF2        ; go evaluate result
0035AE  1               
0035AE  1               LAB_1CE6:
0035AE  1  8B DA A2 01          LDAINDIRECTY FAC2_2     ; get string 2 byte
0035B2  1  B5 B5 C9 00  
0035B6  1  D0 04 A2 00  
0035C4  1  8B 48 DA A2          CMPINDIRECTY FAC1_1     ; compare with string 1 byte
0035C8  1  01 B5 AD C9  
0035CC  1  00 D0 04 A2  
0035DC  1  F0 C5                BEQ     LAB_1CDB        ; loop if bytes =
0035DE  1               
0035DE  1  A2 FF                LDX     #$FF            ; set str 1 < string 2
0035E0  1  B0 02                BCS     LAB_1CF2        ; branch if so
0035E2  1               
0035E2  1  A2 01                LDX     #$01            ;  set str 1 > string 2
0035E4  1               LAB_1CF2:
0035E4  1  E8                   INX                     ; x = 0, 1 or 2
0035E5  1  8A                   TXA                     ; copy to A
0035E6  1  2A                   ROL     A               ; *2 (1, 2 or 4)
0035E7  1  25 63                AND     <Cflag          ; AND with comparison evaluation flag
0035E9  1  F0 02                BEQ     LAB_1CFB        ; branch if 0 (compare is false)
0035EB  1               
0035EB  1  A9 FF                LDA     #$FF            ; else set result true
0035ED  1               LAB_1CFB:
0035ED  1  4C D9 45             JMP     LAB_27DB        ; save A as integer byte and return
0035F0  1               
0035F0  1               LAB_1CFE:
0035F0  1  20 64 34             JSR     LAB_1C01        ; scan for ",", else do syntax error then warm start
0035F3  1               
0035F3  1               ; perform DIM
0035F3  1               
0035F3  1               LAB_DIM:
0035F3  1  AA                   TAX                     ; copy "DIM" flag to X
0035F4  1  20 45 36             JSR     LAB_1D10        ; search for variable
0035F7  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0035FB  1  D0 F3                BNE     LAB_1CFE        ; scan for "," and loop if not null
0035FD  1               
0035FD  1  60                   RTS
0035FE  1               
0035FE  1               ; perform << (left shift)
0035FE  1               
0035FE  1               LAB_LSHIFT:
0035FE  1  20 34 36             JSR     GetPair         ; get integer expression and byte (no sign check)
003601  1  A5 AE                LDA     <FAC1_2         ; get expression high byte
003603  1  A6 78                LDX     <TempB          ; get shift count
003605  1  F0 22                BEQ     NoShift         ; branch if zero
003607  1               
003607  1  E0 10                CPX     #$10            ; compare bit count with 16d
003609  1  B0 23                BCS     TooBig          ; branch if >=
00360B  1               
00360B  1               Ls_loop:
00360B  1  06 AF                ASL     <FAC1_3         ; shift low byte
00360D  1  2A                   ROL     A               ; shift high byte
00360E  1  CA                   DEX                     ; decrement bit count
00360F  1  D0 FA                BNE     Ls_loop         ; loop if shift not complete
003611  1               
003611  1  A4 AF                LDY     <FAC1_3         ; get expression low byte
003613  1  4C FD 38             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
003616  1               
003616  1               ; perform >> (right shift)
003616  1               
003616  1               LAB_RSHIFT:
003616  1  20 34 36             JSR     GetPair         ; get integer expression and byte (no sign check)
003619  1  A5 AE                LDA     <FAC1_2         ; get expression high byte
00361B  1  A6 78                LDX     <TempB          ; get shift count
00361D  1  F0 0A                BEQ     NoShift         ; branch if zero
00361F  1               
00361F  1  E0 10                CPX     #$10            ; compare bit count with 16d
003621  1  B0 0B                BCS     TooBig          ; branch if >=
003623  1               
003623  1               Rs_loop:
003623  1  4A                   LSR     A               ; shift high byte
003624  1  66 AF                ROR     <FAC1_3         ; shift low byte
003626  1  CA                   DEX                     ; decrement bit count
003627  1  D0 FA                BNE     Rs_loop         ; loop if shift not complete
003629  1               
003629  1               NoShift:
003629  1  A4 AF                LDY     <FAC1_3         ; get expression low byte
00362B  1  4C FD 38             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
00362E  1               
00362E  1               TooBig:
00362E  1  A9 00                LDA     #$00            ; clear high byte
003630  1  A8                   TAY                     ; copy to low byte
003631  1  4C FD 38             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
003634  1               
003634  1               GetPair:
003634  1  20 E1 3F             JSR     LAB_EVBY        ; evaluate byte expression, result in X
003637  1  86 78                STX     <TempB          ; save it
003639  1  20 AC 41             JSR     LAB_279B        ; copy FAC2 to FAC1 (get 2nd value in expression)
00363C  1  4C 40 37             JMP     LAB_EVIR        ; evaluate integer expression (no sign check)
00363F  1               
00363F  1               ; search for variable
00363F  1               
00363F  1               ; return pointer to variable in <Cvaral/<Cvarah
00363F  1               
00363F  1               LAB_GVAR:
00363F  1  A2 00                LDX     #$00            ; set DIM flag = $00
003641  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory (1st character)
003645  1               LAB_1D10:
003645  1  86 5E                STX     <Defdim         ; save DIM flag
003647  1               LAB_1D12:
003647  1  85 93                STA     <Varnm1         ; save 1st character
003649  1  29 7F                AND     #$7F            ; clear FN flag bit
00364B  1  20 B7 36             JSR     LAB_CASC        ; check byte, return C=0 if<"A" or >"Z"
00364E  1  B0 03                BCS     LAB_1D1F        ; branch if ok
003650  1               
003650  1  4C 68 34             JMP     LAB_SNER        ; else syntax error then warm start
003653  1               
003653  1               ; was variable name so ..
003653  1               LAB_1D1F:
003653  1  A2 00                LDX     #$00            ; clear 2nd character temp
003655  1  86 5F                STX     <Dtypef         ; clear data type flag, $FF=string, $00=numeric
003657  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory (2nd character)
00365B  1  90 05                BCC     LAB_1D2D        ; branch if character = "0"-"9" (ok)
00365D  1               
00365D  1               ; 2nd character wasn't "0" to "9" so ..
00365D  1  20 B7 36             JSR     LAB_CASC        ; check byte, return C=0 if<"A" or >"Z"
003660  1  90 0C                BCC     LAB_1D38        ; branch if <"A" or >"Z" (go check if string)
003662  1               
003662  1               LAB_1D2D:
003662  1  AA                   TAX                     ; copy 2nd character
003663  1               
003663  1               ; ignore further (valid) characters in the variable name
003663  1               LAB_1D2E:
003663  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory (3rd character)
003667  1  90 FA                BCC     LAB_1D2E        ; loop if character = "0"-"9" (ignore)
003669  1               
003669  1  20 B7 36             JSR     LAB_CASC        ; check byte, return C=0 if<"A" or >"Z"
00366C  1  B0 F5                BCS     LAB_1D2E        ; loop if character = "A"-"Z" (ignore)
00366E  1               
00366E  1               ; check if string variable
00366E  1               LAB_1D38:
00366E  1  C9 24                CMP     #'$'            ; compare with "$"
003670  1  D0 0C                BNE     LAB_1D47        ; branch if not string
003672  1               
003672  1               ; to introduce a new variable type (% suffix for integers say) then this branch
003672  1               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
003672  1               
003672  1               ; type is string
003672  1  A9 FF                LDA     #$FF            ; set data type = string
003674  1  85 5F                STA     <Dtypef         ; set data type flag, $FF=string, $00=numeric
003676  1  8A                   TXA                     ; get 2nd character back
003677  1  09 80                ORA     #$80            ; set top bit (indicate string var)
003679  1  AA                   TAX                     ; copy back to 2nd character temp
00367A  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
00367E  1               
00367E  1               ; after we have determined the variable type we need to come back here to determine
00367E  1               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
00367E  1               
00367E  1               
00367E  1               LAB_1D47:                       ; gets here with character after var name in A
00367E  1  86 94                STX     <Varnm2         ; save 2nd character
003680  1  05 61                ORA     <Sufnxf         ; or with subscript/FNX flag (or FN name)
003682  1  C9 28                CMP     #'('            ; compare with "("
003684  1  D0 03                BNE     LAB_1D53        ; branch if not "("
003686  1               
003686  1  4C 52 37             JMP     LAB_1E17        ; go find, or make, array
003689  1               
003689  1               ; either find or create var
003689  1               ; var name (1st two characters only!) is in <Varnm1,<Varnm2
003689  1               
003689  1               ; variable name wasn't var(... so look for plain var
003689  1               LAB_1D53:
003689  1  A9 00                LDA     #$00            ; clear A
00368B  1  85 61                STA     <Sufnxf         ; clear subscript/FNX flag
00368D  1  A5 7B                LDA     <Svarl          ; get start of vars low byte
00368F  1  A6 7C                LDX     <Svarh          ; get start of vars high byte
003691  1  A0 00                LDY     #$00            ; clear index
003693  1               LAB_1D5D:
003693  1  86 AB                STX     <Vrschh         ; save search address high byte
003695  1               LAB_1D5F:
003695  1  85 AA                STA     <Vrschl         ; save search address low byte
003697  1  E4 7E                CPX     <Sarryh         ; compare high address with var space end
003699  1  D0 04                BNE     LAB_1D69        ; skip next compare if <>
00369B  1               
00369B  1               ; high addresses were = so compare low addresses
00369B  1  C5 7D                CMP     <Sarryl         ; compare low address with var space end
00369D  1  F0 2C                BEQ     LAB_1D8B        ; if not found go make new var
00369F  1               
00369F  1               LAB_1D69:
00369F  1  A5 93                LDA     <Varnm1         ; get 1st character of var to find
0036A1  1  D1 AA                CMP     (<Vrschl),Y     ; compare with variable name 1st character
0036A3  1  D0 08                BNE     LAB_1D77        ; branch if no match
0036A5  1               
0036A5  1               ; 1st characters match so compare 2nd characters
0036A5  1  A5 94                LDA     <Varnm2         ; get 2nd character of var to find
0036A7  1  C8                   INY                     ; index to point to variable name 2nd character
0036A8  1  D1 AA                CMP     (<Vrschl),Y     ; compare with variable name 2nd character
0036AA  1  F0 69                BEQ     LAB_1DD7        ; branch if match (found var)
0036AC  1               
0036AC  1  88                   DEY                     ; else decrement index (now = $00)
0036AD  1               LAB_1D77:
0036AD  1  18                   CLC                     ; clear carry for add
0036AE  1  A5 AA                LDA     <Vrschl         ; get search address low byte
0036B0  1  69 06                ADC     #$06            ; +6 (offset to next var name)
0036B2  1  90 E1                BCC     LAB_1D5F        ; loop if no overflow to high byte
0036B4  1               
0036B4  1  E8                   INX                     ; else increment high byte
0036B5  1  D0 DC                BNE     LAB_1D5D        ; loop always (RAM doesn't extend to $FFFF !)
0036B7  1               
0036B7  1               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
0036B7  1               
0036B7  1               LAB_CASC:
0036B7  1  C9 61                CMP     #'a'            ; compare with "a"
0036B9  1  B0 0A                BCS     LAB_1D83        ; go check <"z"+1
0036BB  1               
0036BB  1               ; check byte, return C=0 if<"A" or >"Z"
0036BB  1               
0036BB  1               LAB_1D82:
0036BB  1  C9 41                CMP     #'A'            ; compare with "A"
0036BD  1  90 05                BCC     LAB_1D8A        ; exit if less
0036BF  1               
0036BF  1               ; carry is set
0036BF  1  E9 5B                SBC     #$5B            ; subtract "Z"+1
0036C1  1  38                   SEC                     ; set carry
0036C2  1  E9 A5                SBC     #$A5            ; subtract $A5 (restore byte)
0036C4  1               ; carry clear if byte>$5A
0036C4  1               LAB_1D8A:
0036C4  1  60                   RTS
0036C5  1               
0036C5  1               LAB_1D83:
0036C5  1  E9 7B                SBC     #$7B            ; subtract "z"+1
0036C7  1  38                   SEC                     ; set carry
0036C8  1  E9 85                SBC     #$85            ; subtract $85 (restore byte)
0036CA  1               ; carry clear if byte>$7A
0036CA  1  60                   RTS
0036CB  1               
0036CB  1               ; reached end of variable mem without match
0036CB  1               ; .. so create new variable
0036CB  1               LAB_1D8B:
0036CB  1  68                   PLA                     ; pop return address low byte
0036CC  1  48                   PHA                     ; push return address low byte
0036CD  1               LAB_1C18p2      = LAB_1C18+2
0036CD  1  C9 A3                CMP     #<LAB_1C18p2    ; compare with expected calling routine return low byte
0036CF  1  D0 05                BNE     LAB_1D98        ; if not get (var) go create new var
0036D1  1               
0036D1  1               ; This will only drop through if the call was from LAB_1C18 and is only called
0036D1  1               ; from there if it is searching for a variable from the RHS of a LET a=b statement
0036D1  1               ; it prevents the creation of variables not assigned a value.
0036D1  1               
0036D1  1               ; value returned by this is either numeric zero (exponent byte is $00) or null string
0036D1  1               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
0036D1  1               
0036D1  1               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
0036D1  1               
0036D1  1               ; this is where you would put the undefined variable error call e.g.
0036D1  1               
0036D1  1               ;					; variable doesn't exist so flag error
0036D1  1               ;	LDX	#$24			; error code $24 ("undefined variable" error)
0036D1  1               ;	JMP	LAB_XERR		; do error #X then warm start
0036D1  1               
0036D1  1               ; the above code has been tested and works a treat! (it replaces the three code lines
0036D1  1               ; below)
0036D1  1               
0036D1  1               ; else return dummy null value
0036D1  1  A9 9B                LDA     #<LAB_1D96      ; low byte point to $00,$00
0036D3  1               ; (uses part of misc constants table)
0036D3  1  A0 18                LDY     #>LAB_1D96      ; high byte point to $00,$00
0036D5  1  60                   RTS
0036D6  1               
0036D6  1               ; create new numeric variable
0036D6  1               LAB_1D98:
0036D6  1  A5 7D                LDA     <Sarryl         ; get var mem end low byte
0036D8  1  A4 7E                LDY     <Sarryh         ; get var mem end high byte
0036DA  1  85 AA                STA     <Ostrtl         ; save old block start low byte
0036DC  1  84 AB                STY     <Ostrth         ; save old block start high byte
0036DE  1  A5 7F                LDA     <Earryl         ; get array mem end low byte
0036E0  1  A4 80                LDY     <Earryh         ; get array mem end high byte
0036E2  1  85 A6                STA     <Obendl         ; save old block end low byte
0036E4  1  84 A7                STY     <Obendh         ; save old block end high byte
0036E6  1  18                   CLC                     ; clear carry for add
0036E7  1  69 06                ADC     #$06            ; +6 (space for one var)
0036E9  1  90 01                BCC     LAB_1DAE        ; branch if no overflow to high byte
0036EB  1               
0036EB  1  C8                   INY                     ; else increment high byte
0036EC  1               LAB_1DAE:
0036EC  1  85 A4                STA     <Nbendl         ; set new block end low byte
0036EE  1  84 A5                STY     <Nbendh         ; set new block end high byte
0036F0  1  20 2D 27             JSR     LAB_11CF        ; open up space in memory
0036F3  1  A5 A4                LDA     <Nbendl         ; get new start low byte
0036F5  1  A4 A5                LDY     <Nbendh         ; get new start high byte (-$100)
0036F7  1  C8                   INY                     ; correct high byte
0036F8  1  85 7D                STA     <Sarryl         ; save new var mem end low byte
0036FA  1  84 7E                STY     <Sarryh         ; save new var mem end high byte
0036FC  1  A0 00                LDY     #$00            ; clear index
0036FE  1  A5 93                LDA     <Varnm1         ; get var name 1st character
003700  1  91 AA                STA     (<Vrschl),Y     ; save var name 1st character
003702  1  C8                   INY                     ; increment index
003703  1  A5 94                LDA     <Varnm2         ; get var name 2nd character
003705  1  91 AA                STA     (<Vrschl),Y     ; save var name 2nd character
003707  1  A9 00                LDA     #$00            ; clear A
003709  1  C8                   INY                     ; increment index
00370A  1  91 AA                STA     (<Vrschl),Y     ; initialise var byte
00370C  1  C8                   INY                     ; increment index
00370D  1  91 AA                STA     (<Vrschl),Y     ; initialise var byte
00370F  1  C8                   INY                     ; increment index
003710  1  91 AA                STA     (<Vrschl),Y     ; initialise var byte
003712  1  C8                   INY                     ; increment index
003713  1  91 AA                STA     (<Vrschl),Y     ; initialise var byte
003715  1               
003715  1               ; found a match for var ((<Vrschl) = ptr)
003715  1               LAB_1DD7:
003715  1  A5 AA                LDA     <Vrschl         ; get var address low byte
003717  1  18                   CLC                     ; clear carry for add
003718  1  69 02                ADC     #$02            ; +2 (offset past var name bytes)
00371A  1  A4 AB                LDY     <Vrschh         ; get var address high byte
00371C  1  90 01                BCC     LAB_1DE1        ; branch if no overflow from add
00371E  1               
00371E  1  C8                   INY                     ; else increment high byte
00371F  1               LAB_1DE1:
00371F  1  85 95                STA     <Cvaral         ; save current var address low byte
003721  1  84 96                STY     <Cvarah         ; save current var address high byte
003723  1  60                   RTS
003724  1               
003724  1               ; set-up array pointer (<Adatal/h) to first element in array
003724  1               ; set <Adatal,<Adatah to <Astrtl,<Astrth+2*<Dimcnt+#$05
003724  1               
003724  1               LAB_1DE6:
003724  1  A5 5D                LDA     <Dimcnt         ; get # of dimensions (1, 2 or 3)
003726  1  0A                   ASL     A               ; *2 (also clears the carry !)
003727  1  69 05                ADC     #$05            ; +5 (result is 7, 9 or 11 here)
003729  1  65 AA                ADC     <Astrtl         ; add array start pointer low byte
00372B  1  A4 AB                LDY     <Astrth         ; get array pointer high byte
00372D  1  90 01                BCC     LAB_1DF2        ; branch if no overflow
00372F  1               
00372F  1  C8                   INY                     ; else increment high byte
003730  1               LAB_1DF2:
003730  1  85 A4                STA     <Adatal         ; save array data pointer low byte
003732  1  84 A5                STY     <Adatah         ; save array data pointer high byte
003734  1  60                   RTS
003735  1               
003735  1               ; evaluate integer expression
003735  1               
003735  1               LAB_EVIN:
003735  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003739  1  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
00373C  1               ; else do type mismatch
00373C  1               
00373C  1               ; evaluate integer expression (no check)
00373C  1               
00373C  1               LAB_EVPI:
00373C  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
00373E  1  30 0D                BMI     LAB_1E12        ; do function call error if -ve
003740  1               
003740  1               ; evaluate integer expression (no sign check)
003740  1               
003740  1               LAB_EVIR:
003740  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
003742  1  C9 90                CMP     #$90            ; compare with exponent = 2^16 (n>2^15)
003744  1  90 09                BCC     LAB_1E14        ; branch if n<2^16 (is ok)
003746  1               
003746  1  A9 A2                LDA     #<LAB_1DF7      ; set pointer low byte to -32768
003748  1  A0 18                LDY     #>LAB_1DF7      ; set pointer high byte to -32768
00374A  1  20 F6 45             JSR     LAB_27F8        ; compare FAC1 with (AY)
00374D  1               LAB_1E12:
00374D  1  D0 78                BNE     LAB_FCER        ; if <> do function call error then warm start
00374F  1               
00374F  1               LAB_1E14:
00374F  1  4C 93 46             JMP     LAB_2831        ; convert FAC1 floating-to-fixed and return
003752  1               
003752  1               ; find or make array
003752  1               
003752  1               LAB_1E17:
003752  1  A5 5E                LDA     <Defdim         ; get DIM flag
003754  1  48                   PHA                     ; push it
003755  1  A5 5F                LDA     <Dtypef         ; get data type flag, $FF=string, $00=numeric
003757  1  48                   PHA                     ; push it
003758  1  A0 00                LDY     #$00            ; clear dimensions count
00375A  1               
00375A  1               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
00375A  1               
00375A  1               LAB_1E1F:
00375A  1  98                   TYA                     ; copy dimensions count
00375B  1  48                   PHA                     ; save it
00375C  1  A5 94                LDA     <Varnm2         ; get array name 2nd byte
00375E  1  48                   PHA                     ; save it
00375F  1  A5 93                LDA     <Varnm1         ; get array name 1st byte
003761  1  48                   PHA                     ; save it
003762  1  20 35 37             JSR     LAB_EVIN        ; evaluate integer expression
003765  1  68                   PLA                     ; pull array name 1st byte
003766  1  85 93                STA     <Varnm1         ; restore array name 1st byte
003768  1  68                   PLA                     ; pull array name 2nd byte
003769  1  85 94                STA     <Varnm2         ; restore array name 2nd byte
00376B  1  68                   PLA                     ; pull dimensions count
00376C  1  A8                   TAY                     ; restore it
00376D  1  A3 02                LDA     2,S             ; get DIM flag
00376F  1  85 FD                STA     <TEMPW          ; push it
003771  1  A3 01                LDA     1,S             ; get data type flag
003773  1  85 FE                STA     <TEMPW+1        ; push it
003775  1  A5 AE                LDA     <FAC1_2         ; get this dimension size high byte
003777  1  83 02                STA     2,S             ; stack before flag bytes
003779  1  A5 AF                LDA     <FAC1_3         ; get this dimension size low byte
00377B  1  83 01                STA     1,S             ; stack before flag bytes
00377D  1  A5 FD                LDA     <TEMPW
00377F  1  48                   PHA
003780  1  A5 FE                LDA     <TEMPW+1
003782  1  48                   PHA
003783  1  C8                   INY                     ; increment dimensions count
003784  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
003788  1  C9 2C                CMP     #','            ; compare with ","
00378A  1  F0 CE                BEQ     LAB_1E1F        ; if found go do next dimension
00378C  1               
00378C  1  84 5D                STY     <Dimcnt         ; store dimensions count
00378E  1  20 53 34             JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
003791  1  68                   PLA                     ; pull data type flag
003792  1  85 5F                STA     <Dtypef         ; restore data type flag, $FF=string, $00=numeric
003794  1  68                   PLA                     ; pull DIM flag
003795  1  85 5E                STA     <Defdim         ; restore DIM flag
003797  1  A6 7D                LDX     <Sarryl         ; get array mem start low byte
003799  1  A5 7E                LDA     <Sarryh         ; get array mem start high byte
00379B  1               
00379B  1               ; now check to see if we are at the end of array memory (we would be if there were
00379B  1               ; no arrays).
00379B  1               
00379B  1               LAB_1E5C:
00379B  1  86 AA                STX     <Astrtl         ; save as array start pointer low byte
00379D  1  85 AB                STA     <Astrth         ; save as array start pointer high byte
00379F  1  C5 80                CMP     <Earryh         ; compare with array mem end high byte
0037A1  1  D0 04                BNE     LAB_1E68        ; branch if not reached array mem end
0037A3  1               
0037A3  1  E4 7F                CPX     <Earryl         ; else compare with array mem end low byte
0037A5  1  F0 39                BEQ     LAB_1EA1        ; go build array if not found
0037A7  1               
0037A7  1               ; search for array
0037A7  1               LAB_1E68:
0037A7  1  A0 00                LDY     #$00            ; clear index
0037A9  1  B1 AA                LDA     (<Astrtl),Y     ; get array name first byte
0037AB  1  C8                   INY                     ; increment index to second name byte
0037AC  1  C5 93                CMP     <Varnm1         ; compare with this array name first byte
0037AE  1  D0 06                BNE     LAB_1E77        ; branch if no match
0037B0  1               
0037B0  1  A5 94                LDA     <Varnm2         ; else get this array name second byte
0037B2  1  D1 AA                CMP     (<Astrtl),Y     ; compare with array name second byte
0037B4  1  F0 16                BEQ     LAB_1E8D        ; array found so branch
0037B6  1               
0037B6  1               ; no match
0037B6  1               LAB_1E77:
0037B6  1  C8                   INY                     ; increment index
0037B7  1  B1 AA                LDA     (<Astrtl),Y     ; get array size low byte
0037B9  1  18                   CLC                     ; clear carry for add
0037BA  1  65 AA                ADC     <Astrtl         ; add array start pointer low byte
0037BC  1  AA                   TAX                     ; copy low byte to X
0037BD  1  C8                   INY                     ; increment index
0037BE  1  B1 AA                LDA     (<Astrtl),Y     ; get array size high byte
0037C0  1  65 AB                ADC     <Astrth         ; add array mem pointer high byte
0037C2  1  90 D7                BCC     LAB_1E5C        ; if no overflow go check next array
0037C4  1               ; do array bounds error
0037C4  1               
0037C4  1               LAB_1E85:
0037C4  1  A2 10                LDX     #$10            ; error code $10 ("Array bounds" error)
0037C6  1  2C                   .BYTE   $2C             ; makes next bit BIT LAB_08A2
0037C7  1               
0037C7  1               ; do function call error
0037C7  1               
0037C7  1               LAB_FCER:
0037C7  1  A2 08                LDX     #$08            ; error code $08 ("Function call" error)
0037C9  1               LAB_1E8A:
0037C9  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
0037CC  1               
0037CC  1               ; found array, are we trying to dimension it?
0037CC  1               LAB_1E8D:
0037CC  1  A2 12                LDX     #$12            ; set error $12 ("Double dimension" error)
0037CE  1  A5 5E                LDA     <Defdim         ; get DIM flag
0037D0  1  D0 F7                BNE     LAB_1E8A        ; if we are trying to dimension it do error #X, then warm
0037D2  1               ; start
0037D2  1               
0037D2  1               ; found the array and we're not dimensioning it so we must find an element in it
0037D2  1               
0037D2  1  20 24 37             JSR     LAB_1DE6        ; set-up array pointer (<Adatal/h) to first element in array
0037D5  1               ; (<Astrtl,<Astrth points to start of array)
0037D5  1  A5 5D                LDA     <Dimcnt         ; get dimensions count
0037D7  1  A0 04                LDY     #$04            ; set index to array's # of dimensions
0037D9  1  D1 AA                CMP     (<Astrtl),Y     ; compare with no of dimensions
0037DB  1  D0 E7                BNE     LAB_1E85        ; if wrong do array bounds error, could do "Wrong
0037DD  1               ; dimensions" error here .. if we want a different
0037DD  1               ; error message
0037DD  1               
0037DD  1  4C 63 38             JMP     LAB_1F28        ; found array so go get element
0037E0  1               ; (could jump to LAB_1F28 as all LAB_1F24 does is take
0037E0  1               ; <Dimcnt and save it at (<Astrtl),Y which is already the
0037E0  1               ; same or we would have taken the BNE)
0037E0  1               
0037E0  1               ; array not found, so build it
0037E0  1               LAB_1EA1:
0037E0  1  20 24 37             JSR     LAB_1DE6        ; set-up array pointer (<Adatal/h) to first element in array
0037E3  1               ; (<Astrtl,<Astrth points to start of array)
0037E3  1  20 D7 27             JSR     LAB_121F        ; check available memory, "Out of memory" error if no room
0037E6  1               ; addr to check is in AY (low/high)
0037E6  1  A0 00                LDY     #$00            ; clear Y (don't need to clear A)
0037E8  1  84 BB                STY     <Aspth          ; clear array data size high byte
0037EA  1  A5 93                LDA     <Varnm1         ; get variable name 1st byte
0037EC  1  91 AA                STA     (<Astrtl),Y     ; save array name 1st byte
0037EE  1  C8                   INY                     ; increment index
0037EF  1  A5 94                LDA     <Varnm2         ; get variable name 2nd byte
0037F1  1  91 AA                STA     (<Astrtl),Y     ; save array name 2nd byte
0037F3  1  A5 5D                LDA     <Dimcnt         ; get dimensions count
0037F5  1  A0 04                LDY     #$04            ; index to dimension count
0037F7  1  84 BA                STY     <Asptl          ; set array data size low byte (four bytes per element)
0037F9  1  91 AA                STA     (<Astrtl),Y     ; set array's dimensions count
0037FB  1               
0037FB  1               ; now calculate the size of the data space for the array
0037FB  1  18                   CLC                     ; clear carry for add (clear on subsequent loops)
0037FC  1               LAB_1EC0:
0037FC  1  A2 0B                LDX     #$0B            ; set default dimension value low byte
0037FE  1  A9 00                LDA     #$00            ; set default dimension value high byte
003800  1  24 5E                BIT     <Defdim         ; test default DIM flag
003802  1  50 07                BVC     LAB_1ED0        ; branch if b6 of <Defdim is clear
003804  1               
003804  1  68                   PLA                     ; else pull dimension value low byte
003805  1  69 01                ADC     #$01            ; +1 (allow for zeroeth element)
003807  1  AA                   TAX                     ; copy low byte to X
003808  1  68                   PLA                     ; pull dimension value high byte
003809  1  69 00                ADC     #$00            ; add carry from low byte
00380B  1               
00380B  1               LAB_1ED0:
00380B  1  C8                   INY                     ; index to dimension value high byte
00380C  1  91 AA                STA     (<Astrtl),Y     ; save dimension value high byte
00380E  1  C8                   INY                     ; index to dimension value high byte
00380F  1  8A                   TXA                     ; get dimension value low byte
003810  1  91 AA                STA     (<Astrtl),Y     ; save dimension value low byte
003812  1  20 B2 38             JSR     LAB_1F7C        ; does XY = (<Astrtl),Y * (<Asptl)
003815  1  86 BA                STX     <Asptl          ; save array data size low byte
003817  1  85 BB                STA     <Aspth          ; save array data size high byte
003819  1  A4 71                LDY     <ut1_pl         ; restore index (saved by subroutine)
00381B  1  C6 5D                DEC     <Dimcnt         ; decrement dimensions count
00381D  1  D0 DD                BNE     LAB_1EC0        ; loop while not = 0
00381F  1               
00381F  1  65 A5                ADC     <Adatah         ; add size high byte to first element high byte
003821  1               ; (carry is always clear here)
003821  1  B0 5D                BCS     LAB_1F45        ; if overflow go do "Out of memory" error
003823  1               
003823  1  85 A5                STA     <Adatah         ; save end of array high byte
003825  1  A8                   TAY                     ; copy end high byte to Y
003826  1  8A                   TXA                     ; get array size low byte
003827  1  65 A4                ADC     <Adatal         ; add array start low byte
003829  1  90 03                BCC     LAB_1EF3        ; branch if no carry
00382B  1               
00382B  1  C8                   INY                     ; else increment end of array high byte
00382C  1  F0 52                BEQ     LAB_1F45        ; if overflow go do "Out of memory" error
00382E  1               
00382E  1               ; set-up mostly complete, now zero the array
00382E  1               LAB_1EF3:
00382E  1  20 D7 27             JSR     LAB_121F        ; check available memory, "Out of memory" error if no room
003831  1               ; addr to check is in AY (low/high)
003831  1  85 7F                STA     <Earryl         ; save array mem end low byte
003833  1  84 80                STY     <Earryh         ; save array mem end high byte
003835  1  A9 00                LDA     #$00            ; clear byte for array clear
003837  1  E6 BB                INC     <Aspth          ; increment array size high byte (now block count)
003839  1  A4 BA                LDY     <Asptl          ; get array size low byte (now index to block)
00383B  1  F0 05                BEQ     LAB_1F07        ; branch if low byte = $00
00383D  1               
00383D  1               LAB_1F02:
00383D  1  88                   DEY                     ; decrement index (do 0 to n-1)
00383E  1  91 A4                STA     (<Adatal),Y     ; zero byte
003840  1  D0 FB                BNE     LAB_1F02        ; loop until this block done
003842  1               
003842  1               LAB_1F07:
003842  1  C6 A5                DEC     <Adatah         ; decrement array pointer high byte
003844  1  C6 BB                DEC     <Aspth          ; decrement block count high byte
003846  1  D0 F5                BNE     LAB_1F02        ; loop until all blocks done
003848  1               
003848  1  E6 A5                INC     <Adatah         ; correct for last loop
00384A  1  38                   SEC                     ; set carry for subtract
00384B  1  A0 02                LDY     #$02            ; index to array size low byte
00384D  1  A5 7F                LDA     <Earryl         ; get array mem end low byte
00384F  1  E5 AA                SBC     <Astrtl         ; subtract array start low byte
003851  1  91 AA                STA     (<Astrtl),Y     ; save array size low byte
003853  1  C8                   INY                     ; index to array size high byte
003854  1  A5 80                LDA     <Earryh         ; get array mem end high byte
003856  1  E5 AB                SBC     <Astrth         ; subtract array start high byte
003858  1  91 AA                STA     (<Astrtl),Y     ; save array size high byte
00385A  1  A5 5E                LDA     <Defdim         ; get default DIM flag
00385C  1  D0 53                BNE     LAB_1F7B        ; exit (RET) if this was a DIM command
00385E  1               ; else, find element
00385E  1  C8                   INY                     ; index to # of dimensions
00385F  1               
00385F  1               LAB_1F24:
00385F  1  B1 AA                LDA     (<Astrtl),Y     ; get array's dimension count
003861  1  85 5D                STA     <Dimcnt         ; save it
003863  1               
003863  1               ; we have found, or built, the array. now we need to find the element
003863  1               
003863  1               LAB_1F28:
003863  1  A9 00                LDA     #$00            ; clear byte
003865  1  85 BA                STA     <Asptl          ; clear array data pointer low byte
003867  1               LAB_1F2C:
003867  1  85 BB                STA     <Aspth          ; save array data pointer high byte
003869  1  C8                   INY                     ; increment index (point to array bound high byte)
00386A  1  68                   PLA                     ; pull array index low byte
00386B  1  AA                   TAX                     ; copy to X
00386C  1  85 AE                STA     <FAC1_2         ; save index low byte to FAC1 mantissa2
00386E  1  68                   PLA                     ; pull array index high byte
00386F  1  85 AF                STA     <FAC1_3         ; save index high byte to FAC1 mantissa3
003871  1  D1 AA                CMP     (<Astrtl),Y     ; compare with array bound high byte
003873  1  90 0E                BCC     LAB_1F48        ; branch if within bounds
003875  1               
003875  1  D0 06                BNE     LAB_1F42        ; if outside bounds do array bounds error
003877  1               
003877  1               ; else high byte was = so test low bytes
003877  1  C8                   INY                     ; index to array bound low byte
003878  1  8A                   TXA                     ; get array index low byte
003879  1  D1 AA                CMP     (<Astrtl),Y     ; compare with array bound low byte
00387B  1  90 07                BCC     LAB_1F49        ; branch if within bounds
00387D  1               
00387D  1               LAB_1F42:
00387D  1  4C C4 37             JMP     LAB_1E85        ; else do array bounds error
003880  1               
003880  1               LAB_1F45:
003880  1  4C 06 28             JMP     LAB_OMER        ; do "Out of memory" error then warm start
003883  1               
003883  1               LAB_1F48:
003883  1  C8                   INY                     ; index to array bound low byte
003884  1               LAB_1F49:
003884  1  A5 BB                LDA     <Aspth          ; get array data pointer high byte
003886  1  05 BA                ORA     <Asptl          ; OR with array data pointer low byte
003888  1  F0 0A                BEQ     LAB_1F5A        ; branch if array data pointer = null (skip multiply)
00388A  1               
00388A  1  20 B2 38             JSR     LAB_1F7C        ; does XY = (<Astrtl),Y * (<Asptl)
00388D  1  8A                   TXA                     ; get result low byte
00388E  1  65 AE                ADC     <FAC1_2         ; add index low byte from FAC1 mantissa2
003890  1  AA                   TAX                     ; save result low byte
003891  1  98                   TYA                     ; get result high byte
003892  1  A4 71                LDY     <ut1_pl         ; restore index
003894  1               LAB_1F5A:
003894  1  65 AF                ADC     <FAC1_3         ; add index high byte from FAC1 mantissa3
003896  1  86 BA                STX     <Asptl          ; save array data pointer low byte
003898  1  C6 5D                DEC     <Dimcnt         ; decrement dimensions count
00389A  1  D0 CB                BNE     LAB_1F2C        ; loop if dimensions still to do
00389C  1               
00389C  1  06 BA                ASL     <Asptl          ; array data pointer low byte * 2
00389E  1  2A                   ROL     A               ; array data pointer high byte * 2
00389F  1  06 BA                ASL     <Asptl          ; array data pointer low byte * 4
0038A1  1  2A                   ROL     A               ; array data pointer high byte * 4
0038A2  1  A8                   TAY                     ; copy high byte
0038A3  1  A5 BA                LDA     <Asptl          ; get low byte
0038A5  1  65 A4                ADC     <Adatal         ; add array data start pointer low byte
0038A7  1  85 95                STA     <Cvaral         ; save as current var address low byte
0038A9  1  98                   TYA                     ; get high byte back
0038AA  1  65 A5                ADC     <Adatah         ; add array data start pointer high byte
0038AC  1  85 96                STA     <Cvarah         ; save as current var address high byte
0038AE  1  A8                   TAY                     ; copy high byte to Y
0038AF  1  A5 95                LDA     <Cvaral         ; get current var address low byte
0038B1  1               LAB_1F7B:
0038B1  1  60                   RTS
0038B2  1               
0038B2  1               ; does XY = (<Astrtl),Y * (<Asptl)
0038B2  1               
0038B2  1               LAB_1F7C:
0038B2  1  84 71                STY     <ut1_pl         ; save index
0038B4  1  B1 AA                LDA     (<Astrtl),Y     ; get dimension size low byte
0038B6  1  85 76                STA     <dims_l         ; save dimension size low byte
0038B8  1  88                   DEY                     ; decrement index
0038B9  1  B1 AA                LDA     (<Astrtl),Y     ; get dimension size high byte
0038BB  1  85 77                STA     <dims_h         ; save dimension size high byte
0038BD  1               
0038BD  1  A9 10                LDA     #$10            ; count = $10 (16 bit multiply)
0038BF  1  85 A8                STA     <numbit         ; save bit count
0038C1  1  A2 00                LDX     #$00            ; clear result low byte
0038C3  1  A0 00                LDY     #$00            ; clear result high byte
0038C5  1               LAB_1F8F:
0038C5  1  8A                   TXA                     ; get result low byte
0038C6  1  0A                   ASL     A               ; *2
0038C7  1  AA                   TAX                     ; save result low byte
0038C8  1  98                   TYA                     ; get result high byte
0038C9  1  2A                   ROL     A               ; *2
0038CA  1  A8                   TAY                     ; save result high byte
0038CB  1  B0 B3                BCS     LAB_1F45        ; if overflow go do "Out of memory" error
0038CD  1               
0038CD  1  06 BA                ASL     <Asptl          ; shift multiplier low byte
0038CF  1  26 BB                ROL     <Aspth          ; shift multiplier high byte
0038D1  1  90 11                BCC     LAB_1FA8        ; skip add if no carry
0038D3  1               
0038D3  1  18                   CLC                     ; else clear carry for add
0038D4  1  8A                   TXA                     ; get result low byte
0038D5  1  65 76                ADC     <dims_l         ; add dimension size low byte
0038D7  1  AA                   TAX                     ; save result low byte
0038D8  1  98                   TYA                     ; get result high byte
0038D9  1  65 77                ADC     <dims_h         ; add dimension size high byte
0038DB  1  A8                   TAY                     ; save result high byte
0038DC  1  B0 03                BCS     LAB_1F45_1      ; if overflow go do "Out of memory" error
0038DE  1  4C E4 38             JMP     LAB_1FA8
0038E1  1               LAB_1F45_1:
0038E1  1  4C 80 38             JMP     LAB_1F45
0038E4  1               LAB_1FA8:
0038E4  1  C6 A8                DEC     <numbit         ; decrement bit count
0038E6  1  D0 DD                BNE     LAB_1F8F        ; loop until all done
0038E8  1               
0038E8  1  60                   RTS
0038E9  1               
0038E9  1               ; perform FRE()
0038E9  1               
0038E9  1               LAB_FRE:
0038E9  1  A5 5F                LDA     <Dtypef         ; get data type flag, $FF=string, $00=numeric
0038EB  1  10 03                BPL     LAB_1FB4        ; branch if numeric
0038ED  1               
0038ED  1  20 55 3D             JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
0038F0  1               ; space returns with A = length, X=$71=pointer low byte,
0038F0  1               ; Y=$72=pointer high byte
0038F0  1               
0038F0  1               ; FRE(n) was numeric so do this
0038F0  1               LAB_1FB4:
0038F0  1  20 2B 3B             JSR     LAB_GARB        ; go do garbage collection
0038F3  1  38                   SEC                     ; set carry for subtract
0038F4  1  A5 81                LDA     <Sstorl         ; get bottom of string space low byte
0038F6  1  E5 7F                SBC     <Earryl         ; subtract array mem end low byte
0038F8  1  A8                   TAY                     ; copy result to Y
0038F9  1  A5 82                LDA     <Sstorh         ; get bottom of string space high byte
0038FB  1  E5 80                SBC     <Earryh         ; subtract array mem end high byte
0038FD  1               
0038FD  1               ; save and convert integer AY to FAC1
0038FD  1               
0038FD  1               LAB_AYFC:
0038FD  1  46 5F                LSR     <Dtypef         ; clear data type flag, $FF=string, $00=numeric
0038FF  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
003901  1  84 AE                STY     <FAC1_2         ; save FAC1 mantissa2
003903  1  A2 90                LDX     #$90            ; set exponent=2^16 (integer)
003905  1  4C E1 45             JMP     LAB_27E3        ; set exp=X, clear <FAC1_3, normalise and return
003908  1               
003908  1               ; perform POS()
003908  1               
003908  1               LAB_POS:
003908  1  A4 0E                LDY     <TPos           ; get terminal position
00390A  1               
00390A  1               ; convert Y to byte in FAC1
00390A  1               
00390A  1               LAB_1FD0:
00390A  1  A9 00                LDA     #$00            ; clear high byte
00390C  1  F0 EF                BEQ     LAB_AYFC        ; always save and convert integer AY to FAC1 and return
00390E  1               
00390E  1               ; check not Direct (used by DEF and INPUT)
00390E  1               
00390E  1               LAB_CKRN:
00390E  1  A6 88                LDX     <Clineh         ; get current line high byte
003910  1  E8                   INX                     ; increment it
003911  1  F0 03                BEQ     LAB_1FD9
003913  1  4C B1 38             JMP     LAB_1F7B        ; return if can continue not direct mode
003916  1               
003916  1               ; else do illegal direct error
003916  1               LAB_1FD9:
003916  1  A2 16                LDX     #$16            ; error code $16 ("Illegal direct" error)
003918  1               LAB_1FDB:
003918  1  4C 08 28             JMP     LAB_XERR        ; go do error #X, then warm start
00391B  1               
00391B  1               ; perform DEF
00391B  1               
00391B  1               LAB_DEF:
00391B  1  20 4C 39             JSR     LAB_200B        ; check FNx syntax
00391E  1  85 9C                STA     <func_l         ; save function pointer low byte
003920  1  84 9D                STY     <func_h         ; save function pointer high byte
003922  1  20 0E 39             JSR     LAB_CKRN        ; check not Direct (back here if ok)
003925  1  20 60 34             JSR     LAB_1BFE        ; scan for "(" , else do syntax error then warm start
003928  1  A9 80                LDA     #$80            ; set flag for FNx
00392A  1  85 61                STA     <Sufnxf         ; save subscript/FNx flag
00392C  1  20 3F 36             JSR     LAB_GVAR        ; get (var) address
00392F  1  20 31 33             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
003932  1  20 53 34             JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
003935  1  A9 D6                LDA     #TK_EQUAL       ; get = token
003937  1  20 55 34             JSR     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
00393A  1  A5 96                LDA     <Cvarah         ; get current var address high byte
00393C  1  48                   PHA                     ; push it
00393D  1  A5 95                LDA     <Cvaral         ; get current var address low byte
00393F  1  48                   PHA                     ; push it
003940  1  A5 C4                LDA     <Bpntrh         ; get BASIC execute pointer high byte
003942  1  48                   PHA                     ; push it
003943  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte
003945  1  48                   PHA                     ; push it
003946  1  20 A0 2D             JSR     LAB_DATA        ; go perform DATA
003949  1  4C F8 39             JMP     LAB_207A        ; put execute pointer and variable pointer into function
00394C  1               ; and return
00394C  1               
00394C  1               ; check FNx syntax
00394C  1               
00394C  1               LAB_200B:
00394C  1  A9 C3                LDA     #TK_FN          ; get FN" token
00394E  1  20 55 34             JSR     LAB_SCCA        ; scan for CHR$(A) , else do syntax error then warm start
003951  1               ; return character after A
003951  1  09 80                ORA     #$80            ; set FN flag bit
003953  1  85 61                STA     <Sufnxf         ; save FN flag so array variable test fails
003955  1  20 47 36             JSR     LAB_1D12        ; search for FN variable
003958  1  4C 31 33             JMP     LAB_CTNM        ; check if source is numeric and return, else do type
00395B  1               ; mismatch
00395B  1               
00395B  1               ; Evaluate FNx
00395B  1               LAB_201E:
00395B  1  20 4C 39             JSR     LAB_200B        ; check FNx syntax
00395E  1  48                   PHA                     ; push function pointer low byte
00395F  1  98                   TYA                     ; copy function pointer high byte
003960  1  48                   PHA                     ; push function pointer high byte
003961  1  20 60 34             JSR     LAB_1BFE        ; scan for "(", else do syntax error then warm start
003964  1  20 42 33             JSR     LAB_EVEX        ; evaluate expression
003967  1  20 53 34             JSR     LAB_1BFB        ; scan for ")", else do syntax error then warm start
00396A  1  20 31 33             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
00396D  1  68                   PLA                     ; pop function pointer high byte
00396E  1  85 9D                STA     <func_h         ; restore it
003970  1  68                   PLA                     ; pop function pointer low byte
003971  1  85 9C                STA     <func_l         ; restore it
003973  1  A2 20                LDX     #$20            ; error code $20 ("Undefined function" error)
003975  1  A0 03                LDY     #$03            ; index to variable pointer high byte
003977  1  B1 9C                LDA     (<func_l),Y     ; get variable pointer high byte
003979  1  F0 9D                BEQ     LAB_1FDB        ; if zero go do undefined function error
00397B  1               
00397B  1  85 96                STA     <Cvarah         ; save variable address high byte
00397D  1  88                   DEY                     ; index to variable address low byte
00397E  1  B1 9C                LDA     (<func_l),Y     ; get variable address low byte
003980  1  85 95                STA     <Cvaral         ; save variable address low byte
003982  1  AA                   TAX                     ; copy address low byte
003983  1               
003983  1               ; now stack the function variable value before use
003983  1  C8                   INY                     ; index to mantissa_3
003984  1               LAB_2043:
003984  1  8B DA A2 01          LDAINDIRECTY Cvaral     ; get byte from variable
003988  1  B5 95 C9 00  
00398C  1  D0 04 A2 00  
00399A  1  48                   PHA                     ; stack it
00399B  1  88                   DEY                     ; decrement index
00399C  1  10 E6                BPL     LAB_2043        ; loop until variable stacked
00399E  1               
00399E  1  A4 96                LDY     <Cvarah         ; get variable address high byte
0039A0  1  20 36 45             JSR     LAB_2778        ; pack FAC1 (function expression value) into (XY)
0039A3  1               ; (function variable), return Y=0, always
0039A3  1  A5 C4                LDA     <Bpntrh         ; get BASIC execute pointer high byte
0039A5  1  48                   PHA                     ; push it
0039A6  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte
0039A8  1  48                   PHA                     ; push it
0039A9  1  8B DA A2 01          LDAINDIRECTY func_l     ; get function execute pointer low byte
0039AD  1  B5 9C C9 00  
0039B1  1  D0 04 A2 00  
0039BF  1  85 C3                STA     <Bpntrl         ; save as BASIC execute pointer low byte
0039C1  1  C8                   INY                     ; index to high byte
0039C2  1  8B DA A2 01          LDAINDIRECTY func_l     ; get function execute pointer high byte
0039C6  1  B5 9C C9 00  
0039CA  1  D0 04 A2 00  
0039D8  1  85 C4                STA     <Bpntrh         ; save as BASIC execute pointer high byte
0039DA  1  A5 96                LDA     <Cvarah         ; get variable address high byte
0039DC  1  48                   PHA                     ; push it
0039DD  1  A5 95                LDA     <Cvaral         ; get variable address low byte
0039DF  1  48                   PHA                     ; push it
0039E0  1  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
0039E3  1               ; else do type mismatch
0039E3  1  68                   PLA                     ; pull variable address low byte
0039E4  1  85 9C                STA     <func_l         ; save variable address low byte
0039E6  1  68                   PLA                     ; pull variable address high byte
0039E7  1  85 9D                STA     <func_h         ; save variable address high byte
0039E9  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
0039ED  1  F0 03                BEQ     LAB_2074        ; branch if null (should be [EOL] marker)
0039EF  1               
0039EF  1  4C 68 34             JMP     LAB_SNER        ; else syntax error then warm start
0039F2  1               
0039F2  1               ; restore <Bpntrl,<Bpntrh and function variable from stack
0039F2  1               
0039F2  1               LAB_2074:
0039F2  1  68                   PLA                     ; pull BASIC execute pointer low byte
0039F3  1  85 C3                STA     <Bpntrl         ; restore BASIC execute pointer low byte
0039F5  1  68                   PLA                     ; pull BASIC execute pointer high byte
0039F6  1  85 C4                STA     <Bpntrh         ; restore BASIC execute pointer high byte
0039F8  1               
0039F8  1               ; put execute pointer and variable pointer into function
0039F8  1               
0039F8  1               LAB_207A:
0039F8  1  A0 00                LDY     #$00            ; clear index
0039FA  1  68                   PLA                     ; pull BASIC execute pointer low byte
0039FB  1  8B DA 48 A2          STAINDIRECTY func_l     ; save to function
0039FF  1  01 B5 9C C9  
003A03  1  00 D0 04 A2  
003A11  1  C8                   INY                     ; increment index
003A12  1  68                   PLA                     ; pull BASIC execute pointer high byte
003A13  1  8B DA 48 A2          STAINDIRECTY func_l     ; save to function
003A17  1  01 B5 9C C9  
003A1B  1  00 D0 04 A2  
003A29  1  C8                   INY                     ; increment index
003A2A  1  68                   PLA                     ; pull current var address low byte
003A2B  1  8B DA 48 A2          STAINDIRECTY func_l     ; save to function
003A2F  1  01 B5 9C C9  
003A33  1  00 D0 04 A2  
003A41  1  C8                   INY                     ; increment index
003A42  1  68                   PLA                     ; pull current var address high byte
003A43  1  8B DA 48 A2          STAINDIRECTY func_l     ; save to function
003A47  1  01 B5 9C C9  
003A4B  1  00 D0 04 A2  
003A59  1  60                   RTS
003A5A  1               
003A5A  1               ; perform STR$()
003A5A  1               
003A5A  1               LAB_STRS:
003A5A  1  20 31 33             JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
003A5D  1  20 F6 47             JSR     LAB_296E        ; convert FAC1 to string
003A60  1  A9 F0                LDA     #<Decssp1       ; set result string low pointer
003A62  1  A0 00                LDY     #>Decssp1       ; set result string high pointer
003A64  1  F0 12                BEQ     LAB_20AE        ; print null terminated string to <Sutill/<Sutilh
003A66  1               
003A66  1               ; Do string vector
003A66  1               ; copy <des_pl/h to <des_2l/h and make string space A bytes long
003A66  1               
003A66  1               LAB_209C:
003A66  1  A6 AE                LDX     <des_pl         ; get descriptor pointer low byte
003A68  1  A4 AF                LDY     <des_ph         ; get descriptor pointer high byte
003A6A  1  86 9E                STX     <des_2l         ; save descriptor pointer low byte
003A6C  1  84 9F                STY     <des_2h         ; save descriptor pointer high byte
003A6E  1               
003A6E  1               ; make string space A bytes long
003A6E  1               ; A=length, X=<Sutill=ptr low byte, Y=<Sutilh=ptr high byte
003A6E  1               
003A6E  1               LAB_MSSP:
003A6E  1  20 F9 3A             JSR     LAB_2115        ; make space in string memory for string A long
003A71  1               ; return X=<Sutill=ptr low byte, Y=<Sutilh=ptr high byte
003A71  1  86 AD                STX     <str_pl         ; save string pointer low byte
003A73  1  84 AE                STY     <str_ph         ; save string pointer high byte
003A75  1  85 AC                STA     <str_ln         ; save length
003A77  1  60                   RTS
003A78  1               
003A78  1               ; Scan, set up string
003A78  1               ; print " terminated string to <Sutill/<Sutilh
003A78  1               
003A78  1               LAB_20AE:
003A78  1  A2 22                LDX     #$22            ; set terminator to "
003A7A  1  86 5B                STX     <Srchc          ; set search character (terminator 1)
003A7C  1  86 5C                STX     <Asrch          ; set terminator 2
003A7E  1               
003A7E  1               ; print [<Srchc] or [<Asrch] terminated string to <Sutill/<Sutilh
003A7E  1               ; source is AY
003A7E  1               
003A7E  1               LAB_20B4:
003A7E  1  85 B8                STA     <ssptr_l        ; store string start low byte
003A80  1  84 B9                STY     <ssptr_h        ; store string start high byte
003A82  1  85 AD                STA     <str_pl         ; save string pointer low byte
003A84  1  84 AE                STY     <str_ph         ; save string pointer high byte
003A86  1  A0 FF                LDY     #$FF            ; set length to -1
003A88  1               LAB_20BE:
003A88  1  C8                   INY                     ; increment length
003A89  1               
003A89  1  8B DA A2 01          LDAINDIRECTY ssptr_l    ; get byte from string
003A8D  1  B5 B8 C9 00  
003A91  1  D0 04 A2 00  
003A9F  1  C9 00                CMP     #$00
003AA1  1  F0 0C                BEQ     LAB_20CF        ; exit loop if null byte [EOS]
003AA3  1               
003AA3  1  C5 5B                CMP     <Srchc          ; compare with search character (terminator 1)
003AA5  1  F0 04                BEQ     LAB_20CB        ; branch if terminator
003AA7  1               
003AA7  1  C5 5C                CMP     <Asrch          ; compare with terminator 2
003AA9  1  D0 DD                BNE     LAB_20BE        ; loop if not terminator 2
003AAB  1               
003AAB  1               LAB_20CB:
003AAB  1  C9 22                CMP     #$22            ; compare with "
003AAD  1  F0 01                BEQ     LAB_20D0        ; branch if " (carry set if = !)
003AAF  1               
003AAF  1               LAB_20CF:
003AAF  1  18                   CLC                     ; clear carry for add (only if [EOL] terminated string)
003AB0  1               LAB_20D0:
003AB0  1  84 AC                STY     <str_ln         ; save length in FAC1 exponent
003AB2  1  98                   TYA                     ; copy length to A
003AB3  1  65 B8                ADC     <ssptr_l        ; add string start low byte
003AB5  1  85 BA                STA     <Sendl          ; save string end low byte
003AB7  1  A6 B9                LDX     <ssptr_h        ; get string start high byte
003AB9  1  90 01                BCC     LAB_20DC        ; branch if no low byte overflow
003ABB  1               
003ABB  1  E8                   INX                     ; else increment high byte
003ABC  1               LAB_20DC:
003ABC  1  86 BB                STX     <Sendh          ; save string end high byte
003ABE  1  A5 B9                LDA     <ssptr_h        ; get string start high byte
003AC0  1               
003AC0  1               
003AC0  1               ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
003AC0  1               ; *** replace
003AC0  1               ;      CMP	#((BASICBEGIN&$FF00)>>8)  ; compare with BASICBEGIN, FORMERLY (>Ram_base) start of program memory
003AC0  1               ;      BCS   LAB_RTST          ; branch if not in utility area
003AC0  1               ; *** with
003AC0  1  F0 04                BEQ     LAB_MVST        ; fix STR$() using page zero via LAB_296E
003AC2  1  C9 21                CMP     #>Ibuffs        ; compare with location of input buffer page
003AC4  1  D0 0B                BNE     LAB_RTST        ; branch if not in utility area
003AC6  1               LAB_MVST:
003AC6  1               ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
003AC6  1               
003AC6  1               
003AC6  1  98                   TYA                     ; copy length to A
003AC7  1  20 66 3A             JSR     LAB_209C        ; copy <des_pl/h to <des_2l/h and make string space A bytes
003ACA  1               ; long
003ACA  1  A6 B8                LDX     <ssptr_l        ; get string start low byte
003ACC  1  A4 B9                LDY     <ssptr_h        ; get string start high byte
003ACE  1  20 0E 3D             JSR     LAB_2298        ; store string A bytes long from XY to (<Sutill)
003AD1  1               ; check for space on descriptor stack then ..
003AD1  1               ; put string address and length on descriptor stack and update stack pointers
003AD1  1               
003AD1  1               LAB_RTST:
003AD1  1  A6 65                LDX     <next_s         ; get string stack pointer
003AD3  1  E0 71                CPX     #<des_sk+$09    ; compare with max+1
003AD5  1  D0 05                BNE     LAB_20F8        ; branch if space on string stack
003AD7  1               
003AD7  1               ; else do string too complex error
003AD7  1  A2 1C                LDX     #$1C            ; error code $1C ("String too complex" error)
003AD9  1               LAB_20F5:
003AD9  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
003ADC  1               
003ADC  1               ; put string address and length on descriptor stack and update stack pointers
003ADC  1               
003ADC  1               LAB_20F8:
003ADC  1  A5 AC                LDA     <str_ln         ; get string length
003ADE  1  95 00                STA     <PLUS_0,X       ; put on string stack
003AE0  1  A5 AD                LDA     <str_pl         ; get string pointer low byte
003AE2  1  95 01                STA     <PLUS_1,X       ; put on string stack
003AE4  1  A5 AE                LDA     <str_ph         ; get string pointer high byte
003AE6  1  95 02                STA     <PLUS_2,X       ; put on string stack
003AE8  1  A0 00                LDY     #$00            ; clear Y
003AEA  1  86 AE                STX     <des_pl         ; save string descriptor pointer low byte
003AEC  1  84 AF                STY     <des_ph         ; save string descriptor pointer high byte (always $00)
003AEE  1  88                   DEY                     ; Y = $FF
003AEF  1  84 5F                STY     <Dtypef         ; save data type flag, $FF=string
003AF1  1  86 66                STX     <last_sl        ; save old stack pointer (current top item)
003AF3  1  E8                   INX                     ; update stack pointer
003AF4  1  E8                   INX                     ; update stack pointer
003AF5  1  E8                   INX                     ; update stack pointer
003AF6  1  86 65                STX     <next_s         ; save new top item value
003AF8  1  60                   RTS
003AF9  1               
003AF9  1               ; Build descriptor
003AF9  1               ; make space in string memory for string A long
003AF9  1               ; return X=<Sutill=ptr low byte, Y=<Sutill=ptr high byte
003AF9  1               
003AF9  1               LAB_2115:
003AF9  1  46 60                LSR     <Gclctd         ; clear garbage collected flag (b7)
003AFB  1               
003AFB  1               ; make space for string A long
003AFB  1               LAB_2117:
003AFB  1  48                   PHA                     ; save string length
003AFC  1  49 FF                EOR     #$FF            ; complement it
003AFE  1  38                   SEC                     ; set carry for subtract (twos comp add)
003AFF  1  65 81                ADC     <Sstorl         ; add bottom of string space low byte (subtract length)
003B01  1  A4 82                LDY     <Sstorh         ; get bottom of string space high byte
003B03  1  B0 01                BCS     LAB_2122        ; skip decrement if no underflow
003B05  1               
003B05  1  88                   DEY                     ; decrement bottom of string space high byte
003B06  1               LAB_2122:
003B06  1  C4 80                CPY     <Earryh         ; compare with array mem end high byte
003B08  1  90 11                BCC     LAB_2137        ; do out of memory error if less
003B0A  1               
003B0A  1  D0 04                BNE     LAB_212C        ; if not = skip next test
003B0C  1               
003B0C  1  C5 7F                CMP     <Earryl         ; compare with array mem end low byte
003B0E  1  90 0B                BCC     LAB_2137        ; do out of memory error if less
003B10  1               
003B10  1               LAB_212C:
003B10  1  85 81                STA     <Sstorl         ; save bottom of string space low byte
003B12  1  84 82                STY     <Sstorh         ; save bottom of string space high byte
003B14  1  85 83                STA     <Sutill         ; save string utility ptr low byte
003B16  1  84 84                STY     <Sutilh         ; save string utility ptr high byte
003B18  1  AA                   TAX                     ; copy low byte to X
003B19  1  68                   PLA                     ; get string length back
003B1A  1  60                   RTS
003B1B  1               
003B1B  1               LAB_2137:
003B1B  1  A2 0C                LDX     #$0C            ; error code $0C ("Out of memory" error)
003B1D  1  A5 60                LDA     <Gclctd         ; get garbage collected flag
003B1F  1  30 B8                BMI     LAB_20F5        ; if set then do error code X
003B21  1               
003B21  1  20 2B 3B             JSR     LAB_GARB        ; else go do garbage collection
003B24  1  A9 80                LDA     #$80            ; flag for garbage collected
003B26  1  85 60                STA     <Gclctd         ; set garbage collected flag
003B28  1  68                   PLA                     ; pull length
003B29  1  D0 D0                BNE     LAB_2117        ; go try again (loop always, length should never be = $00)
003B2B  1               
003B2B  1               ; garbage collection routine
003B2B  1               
003B2B  1               LAB_GARB:
003B2B  1  A6 85                LDX     <Ememl          ; get end of mem low byte
003B2D  1  A5 86                LDA     <Ememh          ; get end of mem high byte
003B2F  1               
003B2F  1               ; re-run routine from last ending
003B2F  1               
003B2F  1               LAB_214B:
003B2F  1  86 81                STX     <Sstorl         ; set string storage low byte
003B31  1  85 82                STA     <Sstorh         ; set string storage high byte
003B33  1  A0 00                LDY     #$00            ; clear index
003B35  1  84 9D                STY     <garb_h         ; clear working pointer high byte (flag no strings to move)
003B37  1  A5 7F                LDA     <Earryl         ; get array mem end low byte
003B39  1  A6 80                LDX     <Earryh         ; get array mem end high byte
003B3B  1  85 AA                STA     <Histrl         ; save as highest string low byte
003B3D  1  86 AB                STX     <Histrh         ; save as highest string high byte
003B3F  1  A9 68                LDA     #<des_sk        ; set descriptor stack pointer
003B41  1  85 71                STA     <ut1_pl         ; save descriptor stack pointer low byte
003B43  1  84 72                STY     <ut1_ph         ; save descriptor stack pointer high byte ($00)
003B45  1               LAB_2161:
003B45  1  C5 65                CMP     <next_s         ; compare with descriptor stack pointer
003B47  1  F0 05                BEQ     LAB_216A        ; branch if =
003B49  1               
003B49  1  20 AF 3B             JSR     LAB_21D7        ; go garbage collect descriptor stack
003B4C  1  F0 F7                BEQ     LAB_2161        ; loop always
003B4E  1               
003B4E  1               ; done stacked strings, now do string vars
003B4E  1               LAB_216A:
003B4E  1  06 A0                ASL     <g_step         ; set step size = $06
003B50  1  A5 7B                LDA     <Svarl          ; get start of vars low byte
003B52  1  A6 7C                LDX     <Svarh          ; get start of vars high byte
003B54  1  85 71                STA     <ut1_pl         ; save as pointer low byte
003B56  1  86 72                STX     <ut1_ph         ; save as pointer high byte
003B58  1               LAB_2176:
003B58  1  E4 7E                CPX     <Sarryh         ; compare start of arrays high byte
003B5A  1  D0 04                BNE     LAB_217E        ; branch if no high byte match
003B5C  1               
003B5C  1  C5 7D                CMP     <Sarryl         ; else compare start of arrays low byte
003B5E  1  F0 05                BEQ     LAB_2183        ; branch if = var mem end
003B60  1               
003B60  1               LAB_217E:
003B60  1  20 A9 3B             JSR     LAB_21D1        ; go garbage collect strings
003B63  1  F0 F3                BEQ     LAB_2176        ; loop always
003B65  1               
003B65  1               ; done string vars, now do string arrays
003B65  1               LAB_2183:
003B65  1  85 A4                STA     <Nbendl         ; save start of arrays low byte as working pointer
003B67  1  86 A5                STX     <Nbendh         ; save start of arrays high byte as working pointer
003B69  1  A9 04                LDA     #$04            ; set step size
003B6B  1  85 A0                STA     <g_step         ; save step size
003B6D  1               LAB_218B:
003B6D  1  A5 A4                LDA     <Nbendl         ; get pointer low byte
003B6F  1  A6 A5                LDX     <Nbendh         ; get pointer high byte
003B71  1               LAB_218F:
003B71  1  E4 80                CPX     <Earryh         ; compare with array mem end high byte
003B73  1  D0 04                BNE     LAB_219A        ; branch if not at end
003B75  1               
003B75  1  C5 7F                CMP     <Earryl         ; else compare with array mem end low byte
003B77  1  F0 75                BEQ     LAB_2216        ; tidy up and exit if at end
003B79  1               
003B79  1               LAB_219A:
003B79  1  85 71                STA     <ut1_pl         ; save pointer low byte
003B7B  1  86 72                STX     <ut1_ph         ; save pointer high byte
003B7D  1  A0 02                LDY     #$02            ; set index
003B7F  1  B1 71                LDA     (<ut1_pl),Y     ; get array size low byte
003B81  1  65 A4                ADC     <Nbendl         ; add start of this array low byte
003B83  1  85 A4                STA     <Nbendl         ; save start of next array low byte
003B85  1  C8                   INY                     ; increment index
003B86  1  B1 71                LDA     (<ut1_pl),Y     ; get array size high byte
003B88  1  65 A5                ADC     <Nbendh         ; add start of this array high byte
003B8A  1  85 A5                STA     <Nbendh         ; save start of next array high byte
003B8C  1  A0 01                LDY     #$01            ; set index
003B8E  1  B1 71                LDA     (<ut1_pl),Y     ; get name second byte
003B90  1  10 DB                BPL     LAB_218B        ; skip if not string array
003B92  1               
003B92  1               ; was string array so ..
003B92  1               
003B92  1  A0 04                LDY     #$04            ; set index
003B94  1  B1 71                LDA     (<ut1_pl),Y     ; get # of dimensions
003B96  1  0A                   ASL     A               ; *2
003B97  1  69 05                ADC     #$05            ; +5 (array header size)
003B99  1  20 E1 3B             JSR     LAB_2208        ; go set up for first element
003B9C  1               LAB_21C4:
003B9C  1  E4 A5                CPX     <Nbendh         ; compare with start of next array high byte
003B9E  1  D0 04                BNE     LAB_21CC        ; branch if <> (go do this array)
003BA0  1               
003BA0  1  C5 A4                CMP     <Nbendl         ; else compare element pointer low byte with next array
003BA2  1               ; low byte
003BA2  1  F0 CD                BEQ     LAB_218F        ; if equal then go do next array
003BA4  1               
003BA4  1               LAB_21CC:
003BA4  1  20 AF 3B             JSR     LAB_21D7        ; go defrag array strings
003BA7  1  F0 F3                BEQ     LAB_21C4        ; go do next array string (loop always)
003BA9  1               
003BA9  1               ; defrag string variables
003BA9  1               ; enter with XA = variable pointer
003BA9  1               ; return with XA = next variable pointer
003BA9  1               
003BA9  1               LAB_21D1:
003BA9  1  C8                   INY                     ; increment index (Y was $00)
003BAA  1  B1 71                LDA     (<ut1_pl),Y     ; get var name byte 2
003BAC  1  10 30                BPL     LAB_2206        ; if not string, step pointer to next var and return
003BAE  1               
003BAE  1  C8                   INY                     ; else increment index
003BAF  1               LAB_21D7:
003BAF  1  B1 71                LDA     (<ut1_pl),Y     ; get string length
003BB1  1  F0 2B                BEQ     LAB_2206        ; if null, step pointer to next string and return
003BB3  1               
003BB3  1  C8                   INY                     ; else increment index
003BB4  1  B1 71                LDA     (<ut1_pl),Y     ; get string pointer low byte
003BB6  1  AA                   TAX                     ; copy to X
003BB7  1  C8                   INY                     ; increment index
003BB8  1  B1 71                LDA     (<ut1_pl),Y     ; get string pointer high byte
003BBA  1  C5 82                CMP     <Sstorh         ; compare bottom of string space high byte
003BBC  1  90 06                BCC     LAB_21EC        ; branch if less
003BBE  1               
003BBE  1  D0 1E                BNE     LAB_2206        ; if greater, step pointer to next string and return
003BC0  1               
003BC0  1               ; high bytes were = so compare low bytes
003BC0  1  E4 81                CPX     <Sstorl         ; compare bottom of string space low byte
003BC2  1  B0 1A                BCS     LAB_2206        ; if >=, step pointer to next string and return
003BC4  1               
003BC4  1               ; string pointer is < string storage pointer (pos in mem)
003BC4  1               LAB_21EC:
003BC4  1  C5 AB                CMP     <Histrh         ; compare to highest string high byte
003BC6  1  90 17                BCC     LAB_2207        ; if <, step pointer to next string and return
003BC8  1               
003BC8  1  D0 04                BNE     LAB_21F6        ; if > update pointers, step to next and return
003BCA  1               
003BCA  1               ; high bytes were = so compare low bytes
003BCA  1  E4 AA                CPX     <Histrl         ; compare to highest string low byte
003BCC  1  90 11                BCC     LAB_2207        ; if <, step pointer to next string and return
003BCE  1               
003BCE  1               ; string is in string memory space
003BCE  1               LAB_21F6:
003BCE  1  86 AA                STX     <Histrl         ; save as new highest string low byte
003BD0  1  85 AB                STA     <Histrh         ; save as new highest string high byte
003BD2  1  A5 71                LDA     <ut1_pl         ; get start of vars(descriptors) low byte
003BD4  1  A6 72                LDX     <ut1_ph         ; get start of vars(descriptors) high byte
003BD6  1  85 9C                STA     <garb_l         ; save as working pointer low byte
003BD8  1  86 9D                STX     <garb_h         ; save as working pointer high byte
003BDA  1  88                   DEY                     ; decrement index DIFFERS
003BDB  1  88                   DEY                     ; decrement index (should point to descriptor start)
003BDC  1  84 A2                STY     <g_indx         ; save index pointer
003BDE  1               
003BDE  1               ; step pointer to next string
003BDE  1               LAB_2206:
003BDE  1  18                   CLC                     ; clear carry for add
003BDF  1               LAB_2207:
003BDF  1  A5 A0                LDA     <g_step         ; get step size
003BE1  1               LAB_2208:
003BE1  1  65 71                ADC     <ut1_pl         ; add pointer low byte
003BE3  1  85 71                STA     <ut1_pl         ; save pointer low byte
003BE5  1  90 02                BCC     LAB_2211        ; branch if no overflow
003BE7  1               
003BE7  1  E6 72                INC     <ut1_ph         ; else increment high byte
003BE9  1               LAB_2211:
003BE9  1  A6 72                LDX     <ut1_ph         ; get pointer high byte
003BEB  1  A0 00                LDY     #$00            ; clear Y
003BED  1  60                   RTS
003BEE  1               
003BEE  1               ; search complete, now either exit or set-up and move string
003BEE  1               
003BEE  1               LAB_2216:
003BEE  1  C6 A0                DEC     <g_step         ; decrement step size (now $03 for descriptor stack)
003BF0  1  A6 9D                LDX     <garb_h         ; get string to move high byte
003BF2  1  F0 F5                BEQ     LAB_2211        ; exit if nothing to move
003BF4  1               
003BF4  1  A4 A2                LDY     <g_indx         ; get index byte back (points to descriptor)
003BF6  1  18                   CLC                     ; clear carry for add
003BF7  1  8B DA A2 01          LDAINDIRECTY garb_l     ; get string length
003BFB  1  B5 9C C9 00  
003BFF  1  D0 04 A2 00  
003C0D  1  65 AA                ADC     <Histrl         ; add highest string low byte
003C0F  1  85 A6                STA     <Obendl         ; save old block end low pointer
003C11  1  A5 AB                LDA     <Histrh         ; get highest string high byte
003C13  1  69 00                ADC     #$00            ; add any carry
003C15  1  85 A7                STA     <Obendh         ; save old block end high byte
003C17  1  A5 81                LDA     <Sstorl         ; get bottom of string space low byte
003C19  1  A6 82                LDX     <Sstorh         ; get bottom of string space high byte
003C1B  1  85 A4                STA     <Nbendl         ; save new block end low byte
003C1D  1  86 A5                STX     <Nbendh         ; save new block end high byte
003C1F  1  20 34 27             JSR     LAB_11D6        ; open up space in memory, don't set array end
003C22  1  A4 A2                LDY     <g_indx         ; get index byte
003C24  1  C8                   INY                     ; point to descriptor low byte
003C25  1  A5 A4                LDA     <Nbendl         ; get string pointer low byte
003C27  1  8B DA 48 A2          STAINDIRECTY garb_l     ; save new string pointer low byte
003C2B  1  01 B5 9C C9  
003C2F  1  00 D0 04 A2  
003C3D  1  AA                   TAX                     ; copy string pointer low byte
003C3E  1  E6 A5                INC     <Nbendh         ; correct high byte (move sets high byte -1)
003C40  1  A5 A5                LDA     <Nbendh         ; get new string pointer high byte
003C42  1  C8                   INY                     ; point to descriptor high byte
003C43  1  8B DA 48 A2          STAINDIRECTY garb_l     ; save new string pointer high byte
003C47  1  01 B5 9C C9  
003C4B  1  00 D0 04 A2  
003C59  1  4C 2F 3B             JMP     LAB_214B        ; re-run routine from last ending
003C5C  1               ; (but don't collect this string)
003C5C  1               
003C5C  1               ; concatenate
003C5C  1               ; add strings, string 1 is in descriptor <des_pl, string 2 is in line
003C5C  1               
003C5C  1               LAB_224D:
003C5C  1  A5 AF                LDA     <des_ph         ; get descriptor pointer high byte
003C5E  1  48                   PHA                     ; put on stack
003C5F  1  A5 AE                LDA     <des_pl         ; get descriptor pointer low byte
003C61  1  48                   PHA                     ; put on stack
003C62  1  20 30 34             JSR     LAB_GVAL        ; get value from line
003C65  1  20 33 33             JSR     LAB_CTST        ; check if source is string, else do type mismatch
003C68  1  68                   PLA                     ; get descriptor pointer low byte back
003C69  1  85 B8                STA     <ssptr_l        ; set pointer low byte
003C6B  1  68                   PLA                     ; get descriptor pointer high byte back
003C6C  1  85 B9                STA     <ssptr_h        ; set pointer high byte
003C6E  1  A0 00                LDY     #$00            ; clear index
003C70  1  8B DA A2 01          LDAINDIRECTY ssptr_l    ; get length_1 from descriptor
003C74  1  B5 B8 C9 00  
003C78  1  D0 04 A2 00  
003C86  1  18                   CLC                     ; clear carry for add
003C87  1  8B 48 DA A2          ADCINDIRECTY des_pl     ; add length_2
003C8B  1  01 B5 AE C9  
003C8F  1  00 D0 04 A2  
003CA0  1  90 05                BCC     LAB_226D        ; branch if no overflow
003CA2  1               
003CA2  1  A2 1A                LDX     #$1A            ; else set error code $1A ("String too long" error)
003CA4  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
003CA7  1               
003CA7  1               LAB_226D:
003CA7  1  20 66 3A             JSR     LAB_209C        ; copy <des_pl/h to <des_2l/h and make string space A bytes
003CAA  1               ; long
003CAA  1  20 C4 3C             JSR     LAB_228A        ; copy string from descriptor (<sdescr) to (<Sutill)
003CAD  1  A5 9E                LDA     <des_2l         ; get descriptor pointer low byte
003CAF  1  A4 9F                LDY     <des_2h         ; get descriptor pointer high byte
003CB1  1  20 59 3D             JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
003CB4  1               ; returns with A = length, <ut1_pl = pointer low byte,
003CB4  1               ; <ut1_ph = pointer high byte
003CB4  1  20 12 3D             JSR     LAB_229C        ; store string A bytes long from (<ut1_pl) to (<Sutill)
003CB7  1  A5 B8                LDA     <ssptr_l        ;.set descriptor pointer low byte
003CB9  1  A4 B9                LDY     <ssptr_h        ;.set descriptor pointer high byte
003CBB  1  20 59 3D             JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
003CBE  1               ; returns with A = length, X=<ut1_pl=pointer low byte,
003CBE  1               ; Y=<ut1_ph=pointer high byte
003CBE  1  20 D1 3A             JSR     LAB_RTST        ; check for space on descriptor stack then put string
003CC1  1               ; address and length on descriptor stack and update stack
003CC1  1               ; pointers
003CC1  1  4C 59 33             JMP     LAB_1ADB        ;.continue evaluation
003CC4  1               
003CC4  1               ; copy string from descriptor (<sdescr) to (<Sutill)
003CC4  1               
003CC4  1               LAB_228A:
003CC4  1  A0 00                LDY     #$00            ; clear index
003CC6  1  8B DA A2 01          LDAINDIRECTY sdescr     ; get string length
003CCA  1  B5 B8 C9 00  
003CCE  1  D0 04 A2 00  
003CDC  1  48                   PHA                     ; save on stack
003CDD  1  C8                   INY                     ; increment index
003CDE  1  8B DA A2 01          LDAINDIRECTY sdescr     ; get source string pointer low byte
003CE2  1  B5 B8 C9 00  
003CE6  1  D0 04 A2 00  
003CF4  1  AA                   TAX                     ; copy to X
003CF5  1  C8                   INY                     ; increment index
003CF6  1  8B DA A2 01          LDAINDIRECTY sdescr     ; get source string pointer high byte
003CFA  1  B5 B8 C9 00  
003CFE  1  D0 04 A2 00  
003D0C  1  A8                   TAY                     ; copy to Y
003D0D  1  68                   PLA                     ; get length back
003D0E  1               
003D0E  1               ; store string A bytes long from YX to (<Sutill)
003D0E  1               
003D0E  1               LAB_2298:
003D0E  1  86 71                STX     <ut1_pl         ; save source string pointer low byte
003D10  1  84 72                STY     <ut1_ph         ; save source string pointer high byte
003D12  1               
003D12  1               ; store string A bytes long from (<ut1_pl) to (<Sutill)
003D12  1               
003D12  1               LAB_229C:
003D12  1  AA                   TAX                     ; copy length to index (don't count with Y)
003D13  1  F0 3C                BEQ     LAB_22B2        ; branch if = $0 (null string) no need to add zero length
003D15  1               
003D15  1  A0 00                LDY     #$00            ; zero pointer (copy forward)
003D17  1               LAB_22A0:
003D17  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get source byte
003D1B  1  B5 71 C9 00  
003D1F  1  D0 04 A2 00  
003D2D  1  8B DA 48 A2          STAINDIRECTY Sutill     ; save destination byte
003D31  1  01 B5 83 C9  
003D35  1  00 D0 04 A2  
003D43  1               
003D43  1  C8                   INY                     ; increment index
003D44  1  CA                   DEX                     ; decrement counter
003D45  1  D0 D0                BNE     LAB_22A0        ; loop while <> 0
003D47  1               
003D47  1  98                   TYA                     ; restore length from Y
003D48  1               LAB_22A9:
003D48  1  18                   CLC                     ; clear carry for add
003D49  1  65 83                ADC     <Sutill         ; add string utility ptr low byte
003D4B  1  85 83                STA     <Sutill         ; save string utility ptr low byte
003D4D  1  90 02                BCC     LAB_22B2        ; branch if no carry
003D4F  1               
003D4F  1  E6 84                INC     <Sutilh         ; else increment string utility ptr high byte
003D51  1               LAB_22B2:
003D51  1  60                   RTS
003D52  1               
003D52  1               ; evaluate string
003D52  1               
003D52  1               LAB_EVST:
003D52  1  20 33 33             JSR     LAB_CTST        ; check if source is string, else do type mismatch
003D55  1               
003D55  1               ; pop string off descriptor stack, or from top of string space
003D55  1               ; returns with A = length, X=pointer low byte, Y=pointer high byte
003D55  1               
003D55  1               LAB_22B6:
003D55  1  A5 AE                LDA     <des_pl         ; get descriptor pointer low byte
003D57  1  A4 AF                LDY     <des_ph         ; get descriptor pointer high byte
003D59  1               
003D59  1               ; pop (YA) descriptor off stack or from top of string space
003D59  1               ; returns with A = length, X=<ut1_pl=pointer low byte, Y=<ut1_ph=pointer high byte
003D59  1               
003D59  1               LAB_22BA:
003D59  1  85 71                STA     <ut1_pl         ; save descriptor pointer low byte
003D5B  1  84 72                STY     <ut1_ph         ; save descriptor pointer high byte
003D5D  1  20 C6 3D             JSR     LAB_22EB        ; clean descriptor stack, YA = pointer
003D60  1  08                   PHP                     ; save status flags
003D61  1  A0 00                LDY     #$00            ; clear index
003D63  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get length from string descriptor
003D67  1  B5 71 C9 00  
003D6B  1  D0 04 A2 00  
003D79  1  48                   PHA                     ; put on stack
003D7A  1  C8                   INY                     ; increment index
003D7B  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get string pointer low byte from descriptor
003D7F  1  B5 71 C9 00  
003D83  1  D0 04 A2 00  
003D91  1  AA                   TAX                     ; copy to X
003D92  1  C8                   INY                     ; increment index
003D93  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get string pointer high byte from descriptor
003D97  1  B5 71 C9 00  
003D9B  1  D0 04 A2 00  
003DA9  1  A8                   TAY                     ; copy to Y
003DAA  1  68                   PLA                     ; get string length back
003DAB  1  28                   PLP                     ; restore status
003DAC  1  D0 13                BNE     LAB_22E6        ; branch if pointer <> <last_sl,<last_sh
003DAE  1               
003DAE  1  C4 82                CPY     <Sstorh         ; compare bottom of string space high byte
003DB0  1  D0 0F                BNE     LAB_22E6        ; branch if <>
003DB2  1               
003DB2  1  E4 81                CPX     <Sstorl         ; else compare bottom of string space low byte
003DB4  1  D0 0B                BNE     LAB_22E6        ; branch if <>
003DB6  1               
003DB6  1  48                   PHA                     ; save string length
003DB7  1  18                   CLC                     ; clear carry for add
003DB8  1  65 81                ADC     <Sstorl         ; add bottom of string space low byte
003DBA  1  85 81                STA     <Sstorl         ; save bottom of string space low byte
003DBC  1  90 02                BCC     LAB_22E5        ; skip increment if no overflow
003DBE  1               
003DBE  1  E6 82                INC     <Sstorh         ; increment bottom of string space high byte
003DC0  1               LAB_22E5:
003DC0  1  68                   PLA                     ; restore string length
003DC1  1               LAB_22E6:
003DC1  1  86 71                STX     <ut1_pl         ; save string pointer low byte
003DC3  1  84 72                STY     <ut1_ph         ; save string pointer high byte
003DC5  1  60                   RTS
003DC6  1               
003DC6  1               ; clean descriptor stack, YA = pointer
003DC6  1               ; checks if AY is on the descriptor stack, if so does a stack discard
003DC6  1               
003DC6  1               LAB_22EB:
003DC6  1  C4 67                CPY     <last_sh        ; compare pointer high byte
003DC8  1  D0 0C                BNE     LAB_22FB        ; exit if <>
003DCA  1               
003DCA  1  C5 66                CMP     <last_sl        ; compare pointer low byte
003DCC  1  D0 08                BNE     LAB_22FB        ; exit if <>
003DCE  1               
003DCE  1  85 65                STA     <next_s         ; save descriptor stack pointer
003DD0  1  E9 03                SBC     #$03            ; -3
003DD2  1  85 66                STA     <last_sl        ; save low byte -3
003DD4  1  A0 00                LDY     #$00            ; clear high byte
003DD6  1               LAB_22FB:
003DD6  1  60                   RTS
003DD7  1               
003DD7  1               ; perform CHR$()
003DD7  1               
003DD7  1               LAB_CHRS:
003DD7  1  20 E1 3F             JSR     LAB_EVBY        ; evaluate byte expression, result in X
003DDA  1  8A                   TXA                     ; copy to A
003DDB  1  48                   PHA                     ; save character
003DDC  1  A9 01                LDA     #$01            ; string is single byte
003DDE  1  20 6E 3A             JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
003DE1  1               ; X=$AD=<Sutill=ptr low byte, Y=$AE=<Sutilh=ptr high byte
003DE1  1  68                   PLA                     ; get character back
003DE2  1  A0 00                LDY     #$00            ; clear index
003DE4  1  8B DA 48 A2          STAINDIRECTY str_pl     ; save byte in string (byte IS string!)
003DE8  1  01 B5 AD C9  
003DEC  1  00 D0 04 A2  
003DFA  1  4C D1 3A             JMP     LAB_RTST        ; check for space on descriptor stack then put string
003DFD  1               ; address and length on descriptor stack and update stack
003DFD  1               ; pointers
003DFD  1               
003DFD  1               ; perform LEFT$()
003DFD  1               
003DFD  1               LAB_LEFT:
003DFD  1  48                   PHA                     ; push byte parameter
003DFE  1  20 B5 3E             JSR     LAB_236F        ; pull string data and byte parameter from stack
003E01  1               ; return pointer in <des_2l/h, byte in A (and X), Y=0
003E01  1  8B 48 DA A2          CMPINDIRECTY des_2l     ; compare byte parameter with string length
003E05  1  01 B5 9E C9  
003E09  1  00 D0 04 A2  
003E19  1  98                   TYA                     ; clear A
003E1A  1  F0 1F                BEQ     LAB_2316        ; go do string copy (branch always)
003E1C  1               
003E1C  1               ; perform RIGHT$()
003E1C  1               
003E1C  1               LAB_RIGHT:
003E1C  1  48                   PHA                     ; push byte parameter
003E1D  1  20 B5 3E             JSR     LAB_236F        ; pull string data and byte parameter from stack
003E20  1               ; return pointer in <des_2l/h, byte in A (and X), Y=0
003E20  1  8B 48 DA A2          FETCHINDIRECTY des_2l   ; subtract string length
003E24  1  01 B5 9E C9  
003E28  1  00 D0 04 A2  
003E36  1  18                   CLC                     ; clear carry for add-1
003E37  1  E5 04                SBC     <TMPFLG         ; REDO SBC WITH CARRY CLEARED (ARTIFACT FROM 816 CONVERSION)
003E39  1  49 FF                EOR     #$FF            ; invert it (A=LEN(expression$)-l)
003E3B  1               
003E3B  1               LAB_2316:
003E3B  1  90 18                BCC     LAB_231C        ; branch if string length > byte parameter
003E3D  1               
003E3D  1  8B DA A2 01          LDAINDIRECTY des_2l     ; else make parameter = length
003E41  1  B5 9E C9 00  
003E45  1  D0 04 A2 00  
003E53  1  AA                   TAX                     ; copy to byte parameter copy
003E54  1  98                   TYA                     ; clear string start offset
003E55  1               LAB_231C:
003E55  1  48                   PHA                     ; save string start offset
003E56  1               LAB_231D:
003E56  1  8A                   TXA                     ; copy byte parameter (or string length if <)
003E57  1               LAB_231E:
003E57  1  48                   PHA                     ; save string length
003E58  1  20 6E 3A             JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
003E5B  1               ; X=$AD=<Sutill=ptr low byte, Y=$AE=<Sutilh=ptr high byte
003E5B  1  A5 9E                LDA     <des_2l         ; get descriptor pointer low byte
003E5D  1  A4 9F                LDY     <des_2h         ; get descriptor pointer high byte
003E5F  1  20 59 3D             JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
003E62  1               ; returns with A = length, X=<ut1_pl=pointer low byte,
003E62  1               ; Y=<ut1_ph=pointer high byte
003E62  1  68                   PLA                     ; get string length back
003E63  1  A8                   TAY                     ; copy length to Y
003E64  1  68                   PLA                     ; get string start offset back
003E65  1  18                   CLC                     ; clear carry for add
003E66  1  65 71                ADC     <ut1_pl         ; add start offset to string start pointer low byte
003E68  1  85 71                STA     <ut1_pl         ; save string start pointer low byte
003E6A  1  90 02                BCC     LAB_2335        ; branch if no overflow
003E6C  1               
003E6C  1  E6 72                INC     <ut1_ph         ; else increment string start pointer high byte
003E6E  1               LAB_2335:
003E6E  1  98                   TYA                     ; copy length to A
003E6F  1  20 12 3D             JSR     LAB_229C        ; store string A bytes long from (<ut1_pl) to (<Sutill)
003E72  1  4C D1 3A             JMP     LAB_RTST        ; check for space on descriptor stack then put string
003E75  1               ; address and length on descriptor stack and update stack
003E75  1               ; pointers
003E75  1               
003E75  1               ; perform MID$()
003E75  1               
003E75  1               LAB_MIDS:
003E75  1  48                   PHA                     ; push byte parameter
003E76  1  A9 FF                LDA     #$FF            ; set default length = 255
003E78  1  85 AF                STA     <mids_l         ; save default length
003E7A  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
003E7E  1  C9 29                CMP     #')'            ; compare with ")"
003E80  1  F0 06                BEQ     LAB_2358        ; branch if = ")" (skip second byte get)
003E82  1               
003E82  1  20 64 34             JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
003E85  1  20 DE 3F             JSR     LAB_GTBY        ; get byte parameter (use copy in <mids_l)
003E88  1               LAB_2358:
003E88  1  20 B5 3E             JSR     LAB_236F        ; pull string data and byte parameter from stack
003E8B  1               ; return pointer in <des_2l/h, byte in A (and X), Y=0
003E8B  1  CA                   DEX                     ; decrement start index
003E8C  1  8A                   TXA                     ; copy to A
003E8D  1  48                   PHA                     ; save string start offset
003E8E  1  8B 48 DA A2          FETCHINDIRECTY des_2l
003E92  1  01 B5 9E C9  
003E96  1  00 D0 04 A2  
003EA4  1  18                   CLC                     ; clear carry for sub-1
003EA5  1  A2 00                LDX     #$00            ; clear output string length
003EA7  1  E5 04                SBC     <TMPFLG         ; subtract string length
003EA9  1  B0 AB                BCS     LAB_231D        ; if start>string length go do null string
003EAB  1               
003EAB  1  49 FF                EOR     #$FF            ; complement -length
003EAD  1  C5 AF                CMP     <mids_l         ; compare byte parameter
003EAF  1  90 A6                BCC     LAB_231E        ; if length>remaining string go do RIGHT$
003EB1  1               
003EB1  1  A5 AF                LDA     <mids_l         ; get length byte
003EB3  1  B0 A2                BCS     LAB_231E        ; go do string copy (branch always)
003EB5  1               
003EB5  1               ; pull string data and byte parameter from stack
003EB5  1               ; return pointer in <des_2l/h, byte in A (and X), Y=0
003EB5  1               
003EB5  1               LAB_236F:
003EB5  1  20 53 34             JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
003EB8  1  68                   PLA                     ; pull return address low byte (return address)
003EB9  1  85 A2                STA     <Fnxjpl         ; save functions jump vector low byte
003EBB  1  68                   PLA                     ; pull return address high byte (return address)
003EBC  1  85 A3                STA     <Fnxjph         ; save functions jump vector high byte
003EBE  1  68                   PLA                     ; pull byte parameter
003EBF  1  AA                   TAX                     ; copy byte parameter to X
003EC0  1  68                   PLA                     ; pull string pointer low byte
003EC1  1  85 9E                STA     <des_2l         ; save it
003EC3  1  68                   PLA                     ; pull string pointer high byte
003EC4  1  85 9F                STA     <des_2h         ; save it
003EC6  1  A0 00                LDY     #$00            ; clear index
003EC8  1  8A                   TXA                     ; copy byte parameter
003EC9  1  D0 03 4C D7          LBEQ    LAB_23A8        ; if null do function call error then warm start
003ECD  1  3F           
003ECE  1               
003ECE  1  E6 A2                INC     <Fnxjpl         ; increment function jump vector low byte
003ED0  1               ; (JSR pushes return addr-1. this is all very nice
003ED0  1               ; but will go tits up if either call is on a page
003ED0  1               ; boundary!)
003ED0  1  6C A2 00             JMP     (Fnxjpl)        ; in effect, RTS
003ED3  1               
003ED3  1               ; perform LCASE$()
003ED3  1               
003ED3  1               LAB_LCASE:
003ED3  1  20 52 3D             JSR     LAB_EVST        ; evaluate string
003ED6  1  85 AC                STA     <str_ln         ; set string length
003ED8  1  A8                   TAY                     ; copy length to Y
003ED9  1  D0 03 4C 66          LBEQ    NoString        ; branch if null string
003EDD  1  3F           
003EDE  1               
003EDE  1  20 6E 3A             JSR     LAB_MSSP        ; make string space A bytes long A=length,
003EE1  1               ; X=<Sutill=ptr low byte, Y=<Sutilh=ptr high byte
003EE1  1  86 AD                STX     <str_pl         ; save string pointer low byte
003EE3  1  84 AE                STY     <str_ph         ; save string pointer high byte
003EE5  1  A8                   TAY                     ; get string length back
003EE6  1               
003EE6  1               LC_loop:
003EE6  1  88                   DEY                     ; decrement index
003EE7  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get byte from string
003EEB  1  B5 71 C9 00  
003EEF  1  D0 04 A2 00  
003EFD  1  20 BB 36             JSR     LAB_1D82        ; is character "A" to "Z"
003F00  1  90 02                BCC     NoUcase         ; branch if not upper case alpha
003F02  1               
003F02  1  09 20                ORA     #$20            ; convert upper to lower case
003F04  1               NoUcase:
003F04  1  8B DA 48 A2          STAINDIRECTY Sutill     ; save byte back to string
003F08  1  01 B5 83 C9  
003F0C  1  00 D0 04 A2  
003F1A  1  98                   TYA                     ; test index
003F1B  1  D0 C9                BNE     LC_loop         ; loop if not all done
003F1D  1               
003F1D  1  F0 47                BEQ     NoString        ; tidy up and exit, branch always
003F1F  1               
003F1F  1               ; perform UCASE$()
003F1F  1               
003F1F  1               LAB_UCASE:
003F1F  1  20 52 3D             JSR     LAB_EVST        ; evaluate string
003F22  1  85 AC                STA     <str_ln         ; set string length
003F24  1  A8                   TAY                     ; copy length to Y
003F25  1  F0 3F                BEQ     NoString        ; branch if null string
003F27  1               
003F27  1  20 6E 3A             JSR     LAB_MSSP        ; make string space A bytes long A=length,
003F2A  1               ; X=<Sutill=ptr low byte, Y=<Sutilh=ptr high byte
003F2A  1  86 AD                STX     <str_pl         ; save string pointer low byte
003F2C  1  84 AE                STY     <str_ph         ; save string pointer high byte
003F2E  1  A8                   TAY                     ; get string length back
003F2F  1               
003F2F  1               UC_loop:
003F2F  1  88                   DEY                     ; decrement index
003F30  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get byte from string
003F34  1  B5 71 C9 00  
003F38  1  D0 04 A2 00  
003F46  1  20 B7 36             JSR     LAB_CASC        ; is character "a" to "z" (or "A" to "Z")
003F49  1  90 02                BCC     NoLcase         ; branch if not alpha
003F4B  1               
003F4B  1  29 DF                AND     #$DF            ; convert lower to upper case
003F4D  1               NoLcase:
003F4D  1  8B DA 48 A2          STAINDIRECTY Sutill     ; save byte back to string
003F51  1  01 B5 83 C9  
003F55  1  00 D0 04 A2  
003F63  1  98                   TYA                     ; test index
003F64  1  D0 C9                BNE     UC_loop         ; loop if not all done
003F66  1               
003F66  1               NoString:
003F66  1  4C D1 3A             JMP     LAB_RTST        ; check for space on descriptor stack then put string
003F69  1               ; address and length on descriptor stack and update stack
003F69  1               ; pointers
003F69  1               
003F69  1               ; perform SADD()
003F69  1               
003F69  1               LAB_SADD:
003F69  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003F6D  1  20 3F 36             JSR     LAB_GVAR        ; get var address
003F70  1               
003F70  1  20 53 34             JSR     LAB_1BFB        ; scan for ")", else do syntax error then warm start
003F73  1  20 33 33             JSR     LAB_CTST        ; check if source is string, else do type mismatch
003F76  1               
003F76  1  A0 02                LDY     #$02            ; index to string pointer high byte
003F78  1  8B DA A2 01          LDAINDIRECTY Cvaral     ; get string pointer high byte
003F7C  1  B5 95 C9 00  
003F80  1  D0 04 A2 00  
003F8E  1  AA                   TAX                     ; copy string pointer high byte to X
003F8F  1  88                   DEY                     ; index to string pointer low byte
003F90  1  8B DA A2 01          LDAINDIRECTY Cvaral     ; get string pointer low byte
003F94  1  B5 95 C9 00  
003F98  1  D0 04 A2 00  
003FA6  1  A8                   TAY                     ; copy string pointer low byte to Y
003FA7  1  8A                   TXA                     ; copy string pointer high byte to A
003FA8  1  4C FD 38             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
003FAB  1               
003FAB  1               ; perform LEN()
003FAB  1               
003FAB  1               LAB_LENS:
003FAB  1  20 B1 3F             JSR     LAB_ESGL        ; evaluate string, get length in A (and Y)
003FAE  1  4C 0A 39             JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return
003FB1  1               
003FB1  1               ; evaluate string, get length in Y
003FB1  1               
003FB1  1               LAB_ESGL:
003FB1  1  20 52 3D             JSR     LAB_EVST        ; evaluate string
003FB4  1  A8                   TAY                     ; copy length to Y
003FB5  1  60                   RTS
003FB6  1               
003FB6  1               ; perform ASC()
003FB6  1               
003FB6  1               LAB_ASC:
003FB6  1  20 B1 3F             JSR     LAB_ESGL        ; evaluate string, get length in A (and Y)
003FB9  1  F0 1C                BEQ     LAB_23A8        ; if null do function call error then warm start
003FBB  1               
003FBB  1  A0 00                LDY     #$00            ; set index to first character
003FBD  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get byte
003FC1  1  B5 71 C9 00  
003FC5  1  D0 04 A2 00  
003FD3  1  A8                   TAY                     ; copy to Y
003FD4  1  4C 0A 39             JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return
003FD7  1               
003FD7  1               ; do function call error then warm start
003FD7  1               
003FD7  1               LAB_23A8:
003FD7  1  4C C7 37             JMP     LAB_FCER        ; do function call error then warm start
003FDA  1               
003FDA  1               ; scan and get byte parameter
003FDA  1               
003FDA  1               LAB_SGBY:
003FDA  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
003FDE  1               
003FDE  1               ; get byte parameter
003FDE  1               
003FDE  1               LAB_GTBY:
003FDE  1  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
003FE1  1               ; else do type mismatch
003FE1  1               
003FE1  1               ; evaluate byte expression, result in X
003FE1  1               
003FE1  1               LAB_EVBY:
003FE1  1  20 3C 37             JSR     LAB_EVPI        ; evaluate integer expression (no check)
003FE4  1               
003FE4  1  A4 AE                LDY     <FAC1_2         ; get FAC1 mantissa2
003FE6  1  D0 EF                BNE     LAB_23A8        ; if top byte <> 0 do function call error then warm start
003FE8  1               
003FE8  1  A6 AF                LDX     <FAC1_3         ; get FAC1 mantissa3
003FEA  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory and return
003FEE  1  60                   RTS
003FEF  1               
003FEF  1               ; perform VAL()
003FEF  1               
003FEF  1               LAB_VAL:
003FEF  1  20 B1 3F             JSR     LAB_ESGL        ; evaluate string, get length in A (and Y)
003FF2  1  D0 03                BNE     LAB_23C5        ; branch if not null string
003FF4  1               
003FF4  1               ; string was null so set result = $00
003FF4  1  4C 3F 42             JMP     LAB_24F1        ; clear FAC1 exponent and sign and return
003FF7  1               
003FF7  1               LAB_23C5:
003FF7  1  A6 C3                LDX     <Bpntrl         ; get BASIC execute pointer low byte
003FF9  1  A4 C4                LDY     <Bpntrh         ; get BASIC execute pointer high byte
003FFB  1  86 BA                STX     <Btmpl          ; save BASIC execute pointer low byte
003FFD  1  84 BB                STY     <Btmph          ; save BASIC execute pointer high byte
003FFF  1  A6 71                LDX     <ut1_pl         ; get string pointer low byte
004001  1  86 C3                STX     <Bpntrl         ; save as BASIC execute pointer low byte
004003  1  18                   CLC                     ; clear carry
004004  1  65 71                ADC     <ut1_pl         ; add string length
004006  1  85 73                STA     <ut2_pl         ; save string end low byte
004008  1  A5 72                LDA     <ut1_ph         ; get string pointer high byte
00400A  1  85 C4                STA     <Bpntrh         ; save as BASIC execute pointer high byte
00400C  1  69 00                ADC     #$00            ; add carry to high byte
00400E  1  85 74                STA     <ut2_ph         ; save string end high byte
004010  1  A0 00                LDY     #$00            ; set index to $00
004012  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get string end +1 byte
004016  1  B5 73 C9 00  
00401A  1  D0 04 A2 00  
004028  1  48                   PHA                     ; push it
004029  1  98                   TYA                     ; clear A
00402A  1  8B DA 48 A2          STAINDIRECTY ut2_pl     ; terminate string with $00
00402E  1  01 B5 73 C9  
004032  1  00 D0 04 A2  
004040  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
004044  1  20 E9 46             JSR     LAB_2887        ; get FAC1 from string
004047  1  68                   PLA                     ; restore string end +1 byte
004048  1  A0 00                LDY     #$00            ; set index to zero
00404A  1  8B DA 48 A2          STAINDIRECTY ut2_pl     ; put string end byte back
00404E  1  01 B5 73 C9  
004052  1  00 D0 04 A2  
004060  1               
004060  1               ; restore BASIC execute pointer from temp (<Btmpl/<Btmph)
004060  1               
004060  1               LAB_23F3:
004060  1  A6 BA                LDX     <Btmpl          ; get BASIC execute pointer low byte back
004062  1  A4 BB                LDY     <Btmph          ; get BASIC execute pointer high byte back
004064  1  86 C3                STX     <Bpntrl         ; save BASIC execute pointer low byte
004066  1  84 C4                STY     <Bpntrh         ; save BASIC execute pointer high byte
004068  1  60                   RTS
004069  1               
004069  1               ; get two parameters for POKE or WAIT
004069  1               
004069  1               LAB_GADB:
004069  1  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
00406C  1               ; else do type mismatch
00406C  1  20 82 40             JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
00406F  1               
00406F  1               ; scan for "," and get byte, else do Syntax error then warm start
00406F  1               
00406F  1               LAB_SCGB:
00406F  1  20 64 34             JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
004072  1  A5 12                LDA     <Itemph         ; save temporary integer high byte
004074  1  48                   PHA                     ; on stack
004075  1  A5 11                LDA     <Itempl         ; save temporary integer low byte
004077  1  48                   PHA                     ; on stack
004078  1  20 DE 3F             JSR     LAB_GTBY        ; get byte parameter
00407B  1  68                   PLA                     ; pull low byte
00407C  1  85 11                STA     <Itempl         ; restore temporary integer low byte
00407E  1  68                   PLA                     ; pull high byte
00407F  1  85 12                STA     <Itemph         ; restore temporary integer high byte
004081  1  60                   RTS
004082  1               
004082  1               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
004082  1               ; -ve and converts it into a right truncated integer in <Itempl and <Itemph
004082  1               
004082  1               ; save unsigned 16 bit integer part of FAC1 in temporary integer
004082  1               
004082  1               LAB_F2FX:
004082  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
004084  1  C9 98                CMP     #$98            ; compare with exponent = 2^24
004086  1  B0 03                BCS     LAB_23A8_1      ; do function call error then warm start
004088  1  4C 8E 40             JMP     LAB_F2FU
00408B  1               LAB_23A8_1:
00408B  1  4C D7 3F             JMP     LAB_23A8
00408E  1               LAB_F2FU:
00408E  1  20 93 46             JSR     LAB_2831        ; convert FAC1 floating-to-fixed
004091  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
004093  1  A4 AF                LDY     <FAC1_3         ; get FAC1 mantissa3
004095  1  84 11                STY     <Itempl         ; save temporary integer low byte
004097  1  85 12                STA     <Itemph         ; save temporary integer high byte
004099  1  60                   RTS
00409A  1               
00409A  1               ; perform PEEK()
00409A  1               
00409A  1               LAB_PEEK:
00409A  1  20 82 40             JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
00409D  1  A2 00                LDX     #$00            ; clear index
00409F  1  8B                   PHB
0040A0  1  DA A2 00 DA          SETBANK 0
0040A4  1  AB FA        
0040A6  1  A1 11                LDA     (<Itempl,X)     ; get byte via temporary integer (addr)
0040A8  1  AB                   PLB
0040A9  1  A8                   TAY                     ; copy byte to Y
0040AA  1  4C 0A 39             JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return
0040AD  1               
0040AD  1               ; perform POKE
0040AD  1               
0040AD  1               LAB_POKE:
0040AD  1  20 69 40             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
0040B0  1  8A                   TXA                     ; copy byte argument to A
0040B1  1  A2 00                LDX     #$00            ; clear index
0040B3  1  8B                   PHB
0040B4  1  DA A2 00 DA          SETBANK 0
0040B8  1  AB FA        
0040BA  1  81 11                STA     (<Itempl,X)     ; save byte via temporary integer (addr)
0040BC  1  AB                   PLB
0040BD  1  60                   RTS
0040BE  1               
0040BE  1               ; perform SYS
0040BE  1               
0040BE  1               LAB_SYS:
0040BE  1  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
0040C1  1               ; else do type mismatch
0040C1  1  20 82 40             JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
0040C4  1               
0040C4  1  A5 11                LDA     <Itempl
0040C6  1  85 0B                STA     <Usrjpl
0040C8  1  A5 12                LDA     <Itemph
0040CA  1  85 0C                STA     <Usrjph
0040CC  1  22 0A 00 00          JSL     Usrjmp
0040D0  1  60                   RTS
0040D1  1               
0040D1  1               ; perform SWAP
0040D1  1               
0040D1  1               LAB_SWAP:
0040D1  1  20 3F 36             JSR     LAB_GVAR        ; get var1 address
0040D4  1  85 97                STA     <Lvarpl         ; save var1 address low byte
0040D6  1  84 98                STY     <Lvarph         ; save var1 address high byte
0040D8  1  A5 5F                LDA     <Dtypef         ; get data type flag, $FF=string, $00=numeric
0040DA  1  48                   PHA                     ; save data type flag
0040DB  1               
0040DB  1  20 64 34             JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
0040DE  1  20 3F 36             JSR     LAB_GVAR        ; get var2 address (pointer in <Cvaral/h)
0040E1  1  68                   PLA                     ; pull var1 data type flag
0040E2  1  45 5F                EOR     <Dtypef         ; compare with var2 data type
0040E4  1  10 60                BPL     SwapErr         ; exit if not both the same type
0040E6  1               
0040E6  1  A0 03                LDY     #$03            ; four bytes to swap (either value or descriptor+1)
0040E8  1               SwapLp:
0040E8  1  8B DA A2 01          LDAINDIRECTY Lvarpl     ; get byte from var1
0040EC  1  B5 97 C9 00  
0040F0  1  D0 04 A2 00  
0040FE  1  AA                   TAX                     ; save var1 byte
0040FF  1  8B DA A2 01          LDAINDIRECTY Cvaral     ; get byte from var2
004103  1  B5 95 C9 00  
004107  1  D0 04 A2 00  
004115  1  8B DA 48 A2          STAINDIRECTY Lvarpl     ; save byte to var1
004119  1  01 B5 97 C9  
00411D  1  00 D0 04 A2  
00412B  1  8A                   TXA                     ; restore var1 byte
00412C  1  8B DA 48 A2          STAINDIRECTY Cvaral     ; save byte to var2
004130  1  01 B5 95 C9  
004134  1  00 D0 04 A2  
004142  1  88                   DEY                     ; decrement index
004143  1  10 A3                BPL     SwapLp          ; loop until done
004145  1               
004145  1  60                   RTS
004146  1               
004146  1               SwapErr:
004146  1  4C 3D 33             JMP     LAB_1ABC        ; do "Type mismatch" error then warm start
004149  1               
004149  1               ; perform CALL
004149  1               
004149  1               LAB_CALL:
004149  1  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
00414C  1               ; else do type mismatch
00414C  1  20 82 40             JSR     LAB_F2FX        ; convert floating-to-fixed
00414F  1  A9 41                LDA     #>CallExit      ; set return address high byte
004151  1  48                   PHA                     ; put on stack
004152  1  A9 57                LDA     #<CallExit-1    ; set return address low byte
004154  1  48                   PHA                     ; put on stack
004155  1  6C 11 00             JMP     (Itempl)        ; do indirect jump to user routine
004158  1               
004158  1               ; if the called routine exits correctly then it will return to here. this will then get
004158  1               ; the next byte for the interpreter and return
004158  1               
004158  1               CallExit:
004158  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory and return
00415C  1  60                   RTS
00415D  1               ; perform WAIT
00415D  1               
00415D  1               LAB_WAIT:
00415D  1  20 69 40             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
004160  1  86 97                STX     <Frnxtl         ; save byte
004162  1  A2 00                LDX     #$00            ; clear mask
004164  1  22 C2 00 00          JSL     LAB_GBYT        ; scan memory
004168  1  F0 03                BEQ     LAB_2441        ; skip if no third argument
00416A  1               
00416A  1  20 6F 40             JSR     LAB_SCGB        ; scan for "," and get byte, else SN error then warm start
00416D  1               LAB_2441:
00416D  1  86 98                STX     <Frnxth         ; save EOR argument
00416F  1               LAB_2445:
00416F  1  8B DA A2 01          LDAINDIRECTY Itempl     ; get byte via temporary integer (addr)
004173  1  B5 11 C9 00  
004177  1  D0 04 A2 00  
004185  1  45 98                EOR     <Frnxth         ; EOR with second argument (mask)
004187  1  25 97                AND     <Frnxtl         ; AND with first argument (byte)
004189  1  F0 E4                BEQ     LAB_2445        ; loop if result is zero
00418B  1               
00418B  1               LAB_244D:
00418B  1  60                   RTS
00418C  1               
00418C  1               ; perform subtraction, FAC1 from (AY)
00418C  1               
00418C  1               LAB_2455:
00418C  1  20 7A 43             JSR     LAB_264D        ; unpack memory (AY) into FAC2
00418F  1               
00418F  1               ; perform subtraction, FAC1 from FAC2
00418F  1               
00418F  1               LAB_SUBTRACT:
00418F  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
004191  1  49 FF                EOR     #$FF            ; complement it
004193  1  85 B0                STA     <FAC1_s         ; save FAC1 sign (b7)
004195  1  45 B7                EOR     <FAC2_s         ; EOR with FAC2 sign (b7)
004197  1  85 B8                STA     <FAC_sc         ; save sign compare (FAC1 EOR FAC2)
004199  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
00419B  1  4C AA 41             JMP     LAB_ADD         ; go add FAC2 to FAC1
00419E  1               
00419E  1               ; perform addition
00419E  1               
00419E  1               LAB_2467:
00419E  1  20 C9 42             JSR     LAB_257B        ; shift FACX A times right (>8 shifts)
0041A1  1  90 4D                BCC     LAB_24A8        ;.go subtract mantissas
0041A3  1               
0041A3  1               ; add 0.5 to FAC1
0041A3  1               
0041A3  1               LAB_244E:
0041A3  1  A9 A3                LDA     #<LAB_2A96      ; set 0.5 pointer low byte
0041A5  1  A0 18                LDY     #>LAB_2A96      ; set 0.5 pointer high byte
0041A7  1               
0041A7  1               ; add (AY) to FAC1
0041A7  1               
0041A7  1               LAB_246C:
0041A7  1  20 7A 43             JSR     LAB_264D        ; unpack memory (AY) into FAC2
0041AA  1               
0041AA  1               ; add FAC2 to FAC1
0041AA  1               
0041AA  1               LAB_ADD:
0041AA  1  D0 10                BNE     LAB_2474        ; branch if FAC1 was not zero
0041AC  1               
0041AC  1               ; copy FAC2 to FAC1
0041AC  1               
0041AC  1               LAB_279B:
0041AC  1  A5 B7                LDA     <FAC2_s         ; get FAC2 sign (b7)
0041AE  1               
0041AE  1               ; save FAC1 sign and copy ABS(FAC2) to FAC1
0041AE  1               
0041AE  1               LAB_279D:
0041AE  1  85 B0                STA     <FAC1_s         ; save FAC1 sign (b7)
0041B0  1  A2 04                LDX     #$04            ; 4 bytes to copy
0041B2  1               LAB_27A1:
0041B2  1  B5 B2                LDA     <FAC1_o,X       ; get byte from FAC2,X
0041B4  1  95 AB                STA     <FAC1_e-1,X     ; save byte at FAC1,X
0041B6  1  CA                   DEX                     ; decrement count
0041B7  1  D0 F9                BNE     LAB_27A1        ; loop if not all done
0041B9  1               
0041B9  1  86 B9                STX     <FAC1_r         ; clear FAC1 rounding byte
0041BB  1  60                   RTS
0041BC  1               
0041BC  1               ; FAC1 is non zero
0041BC  1               LAB_2474:
0041BC  1  A6 B9                LDX     <FAC1_r         ; get FAC1 rounding byte
0041BE  1  86 A3                STX     <FAC2_r         ; save as FAC2 rounding byte
0041C0  1  A2 B3                LDX     #<FAC2_e        ; set index to FAC2 exponent addr
0041C2  1  A5 B3                LDA     <FAC2_e         ; get FAC2 exponent
0041C4  1               LAB_247C:
0041C4  1  A8                   TAY                     ; copy exponent
0041C5  1  F0 C4                BEQ     LAB_244D        ; exit if zero
0041C7  1  38                   SEC                     ; set carry for subtract
0041C8  1  E5 AC                SBC     <FAC1_e         ; subtract FAC1 exponent
0041CA  1  F0 24                BEQ     LAB_24A8        ; branch if = (go add mantissa)
0041CC  1  90 12                BCC     LAB_2498        ; branch if <
0041CE  1               ; FAC2>FAC1
0041CE  1  84 AC                STY     <FAC1_e         ; save FAC1 exponent
0041D0  1  A4 B7                LDY     <FAC2_s         ; get FAC2 sign (b7)
0041D2  1  84 B0                STY     <FAC1_s         ; save FAC1 sign (b7)
0041D4  1  49 FF                EOR     #$FF            ; complement A
0041D6  1  69 00                ADC     #$00            ; +1 (twos complement, carry is set)
0041D8  1  A0 00                LDY     #$00            ; clear Y
0041DA  1  84 A3                STY     <FAC2_r         ; clear FAC2 rounding byte
0041DC  1  A2 AC                LDX     #<FAC1_e        ; set index to FAC1 exponent addr
0041DE  1  D0 04                BNE     LAB_249C        ; branch always
0041E0  1               LAB_2498:
0041E0  1  A0 00                LDY     #$00            ; clear Y
0041E2  1  84 B9                STY     <FAC1_r         ; clear FAC1 rounding byte
0041E4  1               LAB_249C:
0041E4  1  C9 F9                CMP     #$F9            ; compare exponent diff with $F9
0041E6  1  30 B6                BMI     LAB_2467        ; branch if range $79-$F8
0041E8  1  A8                   TAY                     ; copy exponent difference to Y
0041E9  1  A5 B9                LDA     <FAC1_r         ; get FAC1 rounding byte
0041EB  1  56 01                LSR     <PLUS_1,X       ; shift FAC? mantissa1
0041ED  1  20 E0 42             JSR     LAB_2592        ; shift FACX Y times right
0041F0  1               ; exponents are equal now do mantissa subtract
0041F0  1               LAB_24A8:
0041F0  1  24 B8                BIT     <FAC_sc         ; test sign compare (FAC1 EOR FAC2)
0041F2  1  10 52                BPL     LAB_24F8        ; if = add FAC2 mantissa to FAC1 mantissa and return
0041F4  1               
0041F4  1  A0 AC                LDY     #<FAC1_e        ; set index to FAC1 exponent addr
0041F6  1  E0 B3                CPX     #<FAC2_e        ; compare X to FAC2 exponent addr
0041F8  1  F0 02                BEQ     LAB_24B4        ; branch if =
0041FA  1               
0041FA  1  A0 B3                LDY     #<FAC2_e        ; else set index to FAC2 exponent addr
0041FC  1               
0041FC  1               ; subtract smaller from bigger (take sign of bigger)
0041FC  1               LAB_24B4:
0041FC  1  38                   SEC                     ; set carry for subtract
0041FD  1  49 FF                EOR     #$FF            ; ones complement A
0041FF  1  65 A3                ADC     <FAC2_r         ; add FAC2 rounding byte
004201  1  85 B9                STA     <FAC1_r         ; save FAC1 rounding byte
004203  1  DA                   PHX
004204  1  BB                   TYX
004205  1  B5 03                LDA     <PLUS_3,X       ; get FACY mantissa3
004207  1  FA                   PLX
004208  1  F5 03                SBC     <PLUS_3,X       ; subtract FACX mantissa3
00420A  1  85 AF                STA     <FAC1_3         ; save FAC1 mantissa3
00420C  1  DA                   PHX
00420D  1  BB                   TYX
00420E  1  B5 02                LDA     <PLUS_2,x       ; get FACY mantissa2
004210  1  FA                   PLX
004211  1  F5 02                SBC     <PLUS_2,X       ; subtract FACX mantissa2
004213  1  85 AE                STA     <FAC1_2         ; save FAC1 mantissa2
004215  1  DA                   PHX
004216  1  BB                   TYX
004217  1  B5 01                LDA     <PLUS_1,x       ; get FACY mantissa1
004219  1  FA                   PLX
00421A  1  F5 01                SBC     <PLUS_1,X       ; subtract FACX mantissa1
00421C  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
00421E  1               
00421E  1               ; do ABS and normalise FAC1
00421E  1               
00421E  1               LAB_24D0:
00421E  1  B0 03                BCS     LAB_24D5        ; branch if number is +ve
004220  1               
004220  1  20 85 42             JSR     LAB_2537        ; negate FAC1
004223  1               
004223  1               ; normalise FAC1
004223  1               
004223  1               LAB_24D5:
004223  1  A0 00                LDY     #$00            ; clear Y
004225  1  98                   TYA                     ; clear A
004226  1  18                   CLC                     ; clear carry for add
004227  1               LAB_24D9:
004227  1  A6 AD                LDX     <FAC1_1         ; get FAC1 mantissa1
004229  1  D0 3E                BNE     LAB_251B        ; if not zero normalise FAC1
00422B  1               
00422B  1  A6 AE                LDX     <FAC1_2         ; get FAC1 mantissa2
00422D  1  86 AD                STX     <FAC1_1         ; save FAC1 mantissa1
00422F  1  A6 AF                LDX     <FAC1_3         ; get FAC1 mantissa3
004231  1  86 AE                STX     <FAC1_2         ; save FAC1 mantissa2
004233  1  A6 B9                LDX     <FAC1_r         ; get FAC1 rounding byte
004235  1  86 AF                STX     <FAC1_3         ; save FAC1 mantissa3
004237  1  84 B9                STY     <FAC1_r         ; clear FAC1 rounding byte
004239  1  69 08                ADC     #$08            ; add x to exponent offset
00423B  1  C9 18                CMP     #$18            ; compare with $18 (max offset, all bits would be =0)
00423D  1  D0 E8                BNE     LAB_24D9        ; loop if not max
00423F  1               
00423F  1               ; clear FAC1 exponent and sign
00423F  1               
00423F  1               LAB_24F1:
00423F  1  A9 00                LDA     #$00            ; clear A
004241  1               LAB_24F3:
004241  1  85 AC                STA     <FAC1_e         ; set FAC1 exponent
004243  1               
004243  1               ; save FAC1 sign
004243  1               
004243  1               LAB_24F5:
004243  1  85 B0                STA     <FAC1_s         ; save FAC1 sign (b7)
004245  1  60                   RTS
004246  1               
004246  1               ; add FAC2 mantissa to FAC1 mantissa
004246  1               
004246  1               LAB_24F8:
004246  1  65 A3                ADC     <FAC2_r         ; add FAC2 rounding byte
004248  1  85 B9                STA     <FAC1_r         ; save FAC1 rounding byte
00424A  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
00424C  1  65 B6                ADC     <FAC2_3         ; add FAC2 mantissa3
00424E  1  85 AF                STA     <FAC1_3         ; save FAC1 mantissa3
004250  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
004252  1  65 B5                ADC     <FAC2_2         ; add FAC2 mantissa2
004254  1  85 AE                STA     <FAC1_2         ; save FAC1 mantissa2
004256  1  A5 AD                LDA     <FAC1_1         ; get FAC1 mantissa1
004258  1  65 B4                ADC     <FAC2_1         ; add FAC2 mantissa1
00425A  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
00425C  1  B0 1A                BCS     LAB_252A        ; if carry then normalise FAC1 for C=1
00425E  1               
00425E  1  60                   RTS                     ; else just exit
00425F  1               
00425F  1               LAB_2511:
00425F  1  69 01                ADC     #$01            ; add 1 to exponent offset
004261  1  06 B9                ASL     <FAC1_r         ; shift FAC1 rounding byte
004263  1  26 AF                ROL     <FAC1_3         ; shift FAC1 mantissa3
004265  1  26 AE                ROL     <FAC1_2         ; shift FAC1 mantissa2
004267  1  26 AD                ROL     <FAC1_1         ; shift FAC1 mantissa1
004269  1               
004269  1               ; normalise FAC1
004269  1               
004269  1               LAB_251B:
004269  1  10 F4                BPL     LAB_2511        ; loop if not normalised
00426B  1               
00426B  1  38                   SEC                     ; set carry for subtract
00426C  1  E5 AC                SBC     <FAC1_e         ; subtract FAC1 exponent
00426E  1  B0 CF                BCS     LAB_24F1        ; branch if underflow (set result = $0)
004270  1               
004270  1  49 FF                EOR     #$FF            ; complement exponent
004272  1  69 01                ADC     #$01            ; +1 (twos complement)
004274  1  85 AC                STA     <FAC1_e         ; save FAC1 exponent
004276  1               
004276  1               ; test and normalise FAC1 for C=0/1
004276  1               
004276  1               LAB_2528:
004276  1  90 0C                BCC     LAB_2536        ; exit if no overflow
004278  1               
004278  1               ; normalise FAC1 for C=1
004278  1               
004278  1               LAB_252A:
004278  1  E6 AC                INC     <FAC1_e         ; increment FAC1 exponent
00427A  1  F0 36                BEQ     LAB_2564        ; if zero do overflow error and warm start
00427C  1               
00427C  1  66 AD                ROR     <FAC1_1         ; shift FAC1 mantissa1
00427E  1  66 AE                ROR     <FAC1_2         ; shift FAC1 mantissa2
004280  1  66 AF                ROR     <FAC1_3         ; shift FAC1 mantissa3
004282  1  66 B9                ROR     <FAC1_r         ; shift FAC1 rounding byte
004284  1               LAB_2536:
004284  1  60                   RTS
004285  1               
004285  1               ; negate FAC1
004285  1               
004285  1               LAB_2537:
004285  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
004287  1  49 FF                EOR     #$FF            ; complement it
004289  1  85 B0                STA     <FAC1_s         ; save FAC1 sign (b7)
00428B  1               
00428B  1               ; twos complement FAC1 mantissa
00428B  1               
00428B  1               LAB_253D:
00428B  1  A5 AD                LDA     <FAC1_1         ; get FAC1 mantissa1
00428D  1  49 FF                EOR     #$FF            ; complement it
00428F  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
004291  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
004293  1  49 FF                EOR     #$FF            ; complement it
004295  1  85 AE                STA     <FAC1_2         ; save FAC1 mantissa2
004297  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
004299  1  49 FF                EOR     #$FF            ; complement it
00429B  1  85 AF                STA     <FAC1_3         ; save FAC1 mantissa3
00429D  1  A5 B9                LDA     <FAC1_r         ; get FAC1 rounding byte
00429F  1  49 FF                EOR     #$FF            ; complement it
0042A1  1  85 B9                STA     <FAC1_r         ; save FAC1 rounding byte
0042A3  1  E6 B9                INC     <FAC1_r         ; increment FAC1 rounding byte
0042A5  1  D0 0A                BNE     LAB_2563        ; exit if no overflow
0042A7  1               
0042A7  1               ; increment FAC1 mantissa
0042A7  1               
0042A7  1               LAB_2559:
0042A7  1  E6 AF                INC     <FAC1_3         ; increment FAC1 mantissa3
0042A9  1  D0 06                BNE     LAB_2563        ; finished if no rollover
0042AB  1               
0042AB  1  E6 AE                INC     <FAC1_2         ; increment FAC1 mantissa2
0042AD  1  D0 02                BNE     LAB_2563        ; finished if no rollover
0042AF  1               
0042AF  1  E6 AD                INC     <FAC1_1         ; increment FAC1 mantissa1
0042B1  1               LAB_2563:
0042B1  1  60                   RTS
0042B2  1               
0042B2  1               ; do overflow error (overflow exit)
0042B2  1               
0042B2  1               LAB_2564:
0042B2  1  A2 0A                LDX     #$0A            ; error code $0A ("Overflow" error)
0042B4  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
0042B7  1               
0042B7  1               ; shift FCAtemp << A+8 times
0042B7  1               
0042B7  1               LAB_2569:
0042B7  1  A2 74                LDX     #<FACt_1-1      ; set offset to FACtemp
0042B9  1               LAB_256B:
0042B9  1  B4 03                LDY     <PLUS_3,X       ; get FACX mantissa3
0042BB  1  84 B9                STY     <FAC1_r         ; save as FAC1 rounding byte
0042BD  1  B4 02                LDY     <PLUS_2,X       ; get FACX mantissa2
0042BF  1  94 03                STY     <PLUS_3,X       ; save FACX mantissa3
0042C1  1  B4 01                LDY     <PLUS_1,X       ; get FACX mantissa1
0042C3  1  94 02                STY     <PLUS_2,X       ; save FACX mantissa2
0042C5  1  A4 B2                LDY     <FAC1_o         ; get FAC1 overflow byte
0042C7  1  94 01                STY     <PLUS_1,X       ; save FACX mantissa1
0042C9  1               
0042C9  1               ; shift FACX -A times right (> 8 shifts)
0042C9  1               
0042C9  1               LAB_257B:
0042C9  1  69 08                ADC     #$08            ; add 8 to shift count
0042CB  1  30 EC                BMI     LAB_256B        ; go do 8 shift if still -ve
0042CD  1               
0042CD  1  F0 EA                BEQ     LAB_256B        ; go do 8 shift if zero
0042CF  1               
0042CF  1  E9 08                SBC     #$08            ; else subtract 8 again
0042D1  1  A8                   TAY                     ; save count to Y
0042D2  1  A5 B9                LDA     <FAC1_r         ; get FAC1 rounding byte
0042D4  1  B0 12                BCS     LAB_259A        ;.
0042D6  1               
0042D6  1               LAB_2588:
0042D6  1  16 01                ASL     <PLUS_1,X       ; shift FACX mantissa1
0042D8  1  90 02                BCC     LAB_258E        ; branch if +ve
0042DA  1               
0042DA  1  F6 01                INC     <PLUS_1,X       ; this sets b7 eventually
0042DC  1               LAB_258E:
0042DC  1  76 01                ROR     <PLUS_1,X       ; shift FACX mantissa1 (correct for ASL)
0042DE  1  76 01                ROR     <PLUS_1,X       ; shift FACX mantissa1 (put carry in b7)
0042E0  1               
0042E0  1               ; shift FACX Y times right
0042E0  1               
0042E0  1               LAB_2592:
0042E0  1  76 02                ROR     <PLUS_2,X       ; shift FACX mantissa2
0042E2  1  76 03                ROR     <PLUS_3,X       ; shift FACX mantissa3
0042E4  1  6A                   ROR     A               ; shift FACX rounding byte
0042E5  1  C8                   INY                     ; increment exponent diff
0042E6  1  D0 EE                BNE     LAB_2588        ; branch if range adjust not complete
0042E8  1               
0042E8  1               LAB_259A:
0042E8  1  18                   CLC                     ; just clear it
0042E9  1  60                   RTS
0042EA  1               
0042EA  1               ; perform LOG()
0042EA  1               
0042EA  1               LAB_LOG:
0042EA  1  20 C8 45             JSR     LAB_27CA        ; test sign and zero
0042ED  1  F0 02                BEQ     LAB_25C4        ; if zero do function call error then warm start
0042EF  1               
0042EF  1  10 03                BPL     LAB_25C7        ; skip error if +ve
0042F1  1               
0042F1  1               LAB_25C4:
0042F1  1  4C C7 37             JMP     LAB_FCER        ; do function call error then warm start (-ve)
0042F4  1               
0042F4  1               LAB_25C7:
0042F4  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
0042F6  1  E9 7F                SBC     #$7F            ; normalise it
0042F8  1  48                   PHA                     ; save it
0042F9  1  A9 80                LDA     #$80            ; set exponent to zero
0042FB  1  85 AC                STA     <FAC1_e         ; save FAC1 exponent
0042FD  1  A9 23                LDA     #<LAB_25AD      ; set 1/root2 pointer low byte
0042FF  1  A0 18                LDY     #>LAB_25AD      ; set 1/root2 pointer high byte
004301  1  20 A7 41             JSR     LAB_246C        ; add (AY) to FAC1 (1/root2)
004304  1  A9 27                LDA     #<LAB_25B1      ; set root2 pointer low byte
004306  1  A0 18                LDY     #>LAB_25B1      ; set root2 pointer high byte
004308  1  20 40 44             JSR     LAB_26CA        ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
00430B  1  A9 9A                LDA     #<LAB_259C      ; set 1 pointer low byte
00430D  1  A0 18                LDY     #>LAB_259C      ; set 1 pointer high byte
00430F  1  20 8C 41             JSR     LAB_2455        ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
004312  1  A9 16                LDA     #<LAB_25A0      ; set pointer low byte to counter
004314  1  A0 18                LDY     #>LAB_25A0      ; set pointer high byte to counter
004316  1  20 C9 49             JSR     LAB_2B6E        ; ^2 then series evaluation
004319  1  A9 2B                LDA     #<LAB_25B5      ; set -0.5 pointer low byte
00431B  1  A0 18                LDY     #>LAB_25B5      ; set -0.5 pointer high byte
00431D  1  20 A7 41             JSR     LAB_246C        ; add (AY) to FAC1
004320  1  68                   PLA                     ; restore FAC1 exponent
004321  1  20 8F 47             JSR     LAB_2912        ; evaluate new ASCII digit
004324  1  A9 2F                LDA     #<LAB_25B9      ; set LOG(2) pointer low byte
004326  1  A0 18                LDY     #>LAB_25B9      ; set LOG(2) pointer high byte
004328  1               
004328  1               ; do convert AY, FCA1*(AY)
004328  1               
004328  1               LAB_25FB:
004328  1  20 7A 43             JSR     LAB_264D        ; unpack memory (AY) into FAC2
00432B  1               LAB_MULTIPLY:
00432B  1  F0 4C                BEQ     LAB_264C        ; exit if zero
00432D  1               
00432D  1  20 F0 43             JSR     LAB_2673        ; test and adjust accumulators
004330  1  A9 00                LDA     #$00            ; clear A
004332  1  85 75                STA     <FACt_1         ; clear temp mantissa1
004334  1  85 76                STA     <FACt_2         ; clear temp mantissa2
004336  1  85 77                STA     <FACt_3         ; clear temp mantissa3
004338  1  A5 B9                LDA     <FAC1_r         ; get FAC1 rounding byte
00433A  1  20 4F 43             JSR     LAB_2622        ; go do shift/add FAC2
00433D  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
00433F  1  20 4F 43             JSR     LAB_2622        ; go do shift/add FAC2
004342  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
004344  1  20 4F 43             JSR     LAB_2622        ; go do shift/add FAC2
004347  1  A5 AD                LDA     <FAC1_1         ; get FAC1 mantissa1
004349  1  20 54 43             JSR     LAB_2627        ; go do shift/add FAC2
00434C  1  4C AD 44             JMP     LAB_273C        ; copy temp to FAC1, normalise and return
00434F  1               
00434F  1               LAB_2622:
00434F  1  D0 03                BNE     LAB_2627        ; branch if byte <> zero
004351  1               
004351  1  4C B7 42             JMP     LAB_2569        ; shift FCAtemp << A+8 times
004354  1               
004354  1               ; else do shift and add
004354  1               LAB_2627:
004354  1  4A                   LSR     A               ; shift byte
004355  1  09 80                ORA     #$80            ; set top bit (mark for 8 times)
004357  1               LAB_262A:
004357  1  A8                   TAY                     ; copy result
004358  1  90 13                BCC     LAB_2640        ; skip next if bit was zero
00435A  1               
00435A  1  18                   CLC                     ; clear carry for add
00435B  1  A5 77                LDA     <FACt_3         ; get temp mantissa3
00435D  1  65 B6                ADC     <FAC2_3         ; add FAC2 mantissa3
00435F  1  85 77                STA     <FACt_3         ; save temp mantissa3
004361  1  A5 76                LDA     <FACt_2         ; get temp mantissa2
004363  1  65 B5                ADC     <FAC2_2         ; add FAC2 mantissa2
004365  1  85 76                STA     <FACt_2         ; save temp mantissa2
004367  1  A5 75                LDA     <FACt_1         ; get temp mantissa1
004369  1  65 B4                ADC     <FAC2_1         ; add FAC2 mantissa1
00436B  1  85 75                STA     <FACt_1         ; save temp mantissa1
00436D  1               LAB_2640:
00436D  1  66 75                ROR     <FACt_1         ; shift temp mantissa1
00436F  1  66 76                ROR     <FACt_2         ; shift temp mantissa2
004371  1  66 77                ROR     <FACt_3         ; shift temp mantissa3
004373  1  66 B9                ROR     <FAC1_r         ; shift temp rounding byte
004375  1  98                   TYA                     ; get byte back
004376  1  4A                   LSR     A               ; shift byte
004377  1  D0 DE                BNE     LAB_262A        ; loop if all bits not done
004379  1               
004379  1               LAB_264C:
004379  1  60                   RTS
00437A  1               
00437A  1               ; unpack memory (AY) into FAC2
00437A  1               
00437A  1               LAB_264D:
00437A  1  85 71                STA     <ut1_pl         ; save pointer low byte
00437C  1  84 72                STY     <ut1_ph         ; save pointer high byte
00437E  1  A0 03                LDY     #$03            ; 4 bytes to get (0-3)
004380  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get mantissa3
004384  1  B5 71 C9 00  
004388  1  D0 04 A2 00  
004396  1  85 B6                STA     <FAC2_3         ; save FAC2 mantissa3
004398  1  88                   DEY                     ; decrement index
004399  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get mantissa2
00439D  1  B5 71 C9 00  
0043A1  1  D0 04 A2 00  
0043AF  1  85 B5                STA     <FAC2_2         ; save FAC2 mantissa2
0043B1  1  88                   DEY                     ; decrement index
0043B2  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get mantissa1+sign
0043B6  1  B5 71 C9 00  
0043BA  1  D0 04 A2 00  
0043C8  1  85 B7                STA     <FAC2_s         ; save FAC2 sign (b7)
0043CA  1  45 B0                EOR     <FAC1_s         ; EOR with FAC1 sign (b7)
0043CC  1  85 B8                STA     <FAC_sc         ; save sign compare (FAC1 EOR FAC2)
0043CE  1  A5 B7                LDA     <FAC2_s         ; recover FAC2 sign (b7)
0043D0  1  09 80                ORA     #$80            ; set 1xxx xxx (set normal bit)
0043D2  1  85 B4                STA     <FAC2_1         ; save FAC2 mantissa1
0043D4  1  88                   DEY                     ; decrement index
0043D5  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get exponent byte
0043D9  1  B5 71 C9 00  
0043DD  1  D0 04 A2 00  
0043EB  1  85 B3                STA     <FAC2_e         ; save FAC2 exponent
0043ED  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
0043EF  1  60                   RTS
0043F0  1               
0043F0  1               ; test and adjust accumulators
0043F0  1               
0043F0  1               LAB_2673:
0043F0  1  A5 B3                LDA     <FAC2_e         ; get FAC2 exponent
0043F2  1               LAB_2675:
0043F2  1  F0 1D                BEQ     LAB_2696        ; branch if FAC2 = $00 (handle underflow)
0043F4  1               
0043F4  1  18                   CLC                     ; clear carry for add
0043F5  1  65 AC                ADC     <FAC1_e         ; add FAC1 exponent
0043F7  1  90 04                BCC     LAB_2680        ; branch if sum of exponents <$0100
0043F9  1               
0043F9  1  30 31                BMI     LAB_269B        ; do overflow error
0043FB  1               
0043FB  1  18                   CLC                     ; clear carry for the add
0043FC  1  2C                   .BYTE   $2C             ; makes next line BIT $1410
0043FD  1               LAB_2680:
0043FD  1  10 12                BPL     LAB_2696        ; if +ve go handle underflow
0043FF  1               
0043FF  1  69 80                ADC     #$80            ; adjust exponent
004401  1  85 AC                STA     <FAC1_e         ; save FAC1 exponent
004403  1  D0 03                BNE     LAB_268B        ; branch if not zero
004405  1               
004405  1  4C 43 42             JMP     LAB_24F5        ; save FAC1 sign and return
004408  1               
004408  1               LAB_268B:
004408  1  A5 B8                LDA     <FAC_sc         ; get sign compare (FAC1 EOR FAC2)
00440A  1  85 B0                STA     <FAC1_s         ; save FAC1 sign (b7)
00440C  1               LAB_268F:
00440C  1  60                   RTS
00440D  1               
00440D  1               ; handle overflow and underflow
00440D  1               
00440D  1               LAB_2690:
00440D  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
00440F  1  10 1B                BPL     LAB_269B        ; do overflow error
004411  1               
004411  1               ; handle underflow
004411  1               LAB_2696:
004411  1  68                   PLA                     ; pop return address low byte
004412  1  68                   PLA                     ; pop return address high byte
004413  1  4C 3F 42             JMP     LAB_24F1        ; clear FAC1 exponent and sign and return
004416  1               
004416  1               ; multiply by 10
004416  1               
004416  1               LAB_269E:
004416  1  20 A9 45             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
004419  1  AA                   TAX                     ; copy exponent (set the flags)
00441A  1  F0 F0                BEQ     LAB_268F        ; exit if zero
00441C  1  18                   CLC                     ; clear carry for add
00441D  1  69 02                ADC     #$02            ; add two to exponent (*4)
00441F  1  B0 0B                BCS     LAB_269B        ; do overflow error if > $FF
004421  1  A2 00                LDX     #$00            ; clear byte
004423  1  86 B8                STX     <FAC_sc         ; clear sign compare (FAC1 EOR FAC2)
004425  1  20 C4 41             JSR     LAB_247C        ; add FAC2 to FAC1 (*5)
004428  1  E6 AC                INC     <FAC1_e         ; increment FAC1 exponent (*10)
00442A  1  D0 E0                BNE     LAB_268F        ; if non zero just do RTS
00442C  1               
00442C  1               LAB_269B:
00442C  1  4C B2 42             JMP     LAB_2564        ; do overflow error and warm start
00442F  1               
00442F  1               ; divide by 10
00442F  1               
00442F  1               LAB_26B9:
00442F  1  20 A9 45             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
004432  1  A9 AB                LDA     #<LAB_26B5      ; set pointer to 10d low addr
004434  1  A0 18                LDY     #>LAB_26B5      ; set pointer to 10d high addr
004436  1  A2 00                LDX     #$00            ; clear sign
004438  1               
004438  1               ; divide by (AY) (X=sign)
004438  1               
004438  1               LAB_26C2:
004438  1  86 B8                STX     <FAC_sc         ; save sign compare (FAC1 EOR FAC2)
00443A  1  20 BC 44             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
00443D  1  4C 43 44             JMP     LAB_DIVIDE      ; do FAC2/FAC1
004440  1               
004440  1               ; Perform divide-by
004440  1               ; convert AY and do (AY)/FAC1
004440  1               
004440  1               LAB_26CA:
004440  1  20 7A 43             JSR     LAB_264D        ; unpack memory (AY) into FAC2
004443  1               
004443  1               ; Perform divide-into
004443  1               LAB_DIVIDE:
004443  1  F0 63                BEQ     LAB_2737        ; if zero go do /0 error
004445  1               
004445  1  20 B8 45             JSR     LAB_27BA        ; round FAC1
004448  1  A9 00                LDA     #$00            ; clear A
00444A  1  38                   SEC                     ; set carry for subtract
00444B  1  E5 AC                SBC     <FAC1_e         ; subtract FAC1 exponent (2s complement)
00444D  1  85 AC                STA     <FAC1_e         ; save FAC1 exponent
00444F  1  20 F0 43             JSR     LAB_2673        ; test and adjust accumulators
004452  1  E6 AC                INC     <FAC1_e         ; increment FAC1 exponent
004454  1  F0 D6                BEQ     LAB_269B        ; if zero do overflow error
004456  1               
004456  1  A2 FF                LDX     #$FF            ; set index for pre increment
004458  1  A9 01                LDA     #$01            ; set bit to flag byte save
00445A  1               LAB_26E4:
00445A  1  A4 B4                LDY     <FAC2_1         ; get FAC2 mantissa1
00445C  1  C4 AD                CPY     <FAC1_1         ; compare FAC1 mantissa1
00445E  1  D0 0A                BNE     LAB_26F4        ; branch if <>
004460  1               
004460  1  A4 B5                LDY     <FAC2_2         ; get FAC2 mantissa2
004462  1  C4 AE                CPY     <FAC1_2         ; compare FAC1 mantissa2
004464  1  D0 04                BNE     LAB_26F4        ; branch if <>
004466  1               
004466  1  A4 B6                LDY     <FAC2_3         ; get FAC2 mantissa3
004468  1  C4 AF                CPY     <FAC1_3         ; compare FAC1 mantissa3
00446A  1               LAB_26F4:
00446A  1  08                   PHP                     ; save FAC2-FAC1 compare status
00446B  1  2A                   ROL     A               ; shift the result byte
00446C  1  90 0E                BCC     LAB_2702        ; if no carry skip the byte save
00446E  1               
00446E  1  A0 01                LDY     #$01            ; set bit to flag byte save
004470  1  E8                   INX                     ; else increment the index to FACt
004471  1  E0 02                CPX     #$02            ; compare with the index to <FACt_3
004473  1  30 04                BMI     LAB_2701        ; if not last byte just go save it
004475  1               
004475  1  D0 28                BNE     LAB_272B        ; if all done go save FAC1 rounding byte, normalise and
004477  1               ; return
004477  1               
004477  1  A0 40                LDY     #$40            ; set bit to flag byte save for the rounding byte
004479  1               LAB_2701:
004479  1  95 75                STA     <FACt_1,X       ; write result byte to <FACt_1 + index
00447B  1  98                   TYA                     ; copy the next save byte flag
00447C  1               LAB_2702:
00447C  1  28                   PLP                     ; restore FAC2-FAC1 compare status
00447D  1  90 14                BCC     LAB_2704        ; if FAC2 < FAC1 then skip the subtract
00447F  1               
00447F  1  A8                   TAY                     ; save FAC2-FAC1 compare status
004480  1  A5 B6                LDA     <FAC2_3         ; get FAC2 mantissa3
004482  1  E5 AF                SBC     <FAC1_3         ; subtract FAC1 mantissa3
004484  1  85 B6                STA     <FAC2_3         ; save FAC2 mantissa3
004486  1  A5 B5                LDA     <FAC2_2         ; get FAC2 mantissa2
004488  1  E5 AE                SBC     <FAC1_2         ; subtract FAC1 mantissa2
00448A  1  85 B5                STA     <FAC2_2         ; save FAC2 mantissa2
00448C  1  A5 B4                LDA     <FAC2_1         ; get FAC2 mantissa1
00448E  1  E5 AD                SBC     <FAC1_1         ; subtract FAC1 mantissa1
004490  1  85 B4                STA     <FAC2_1         ; save FAC2 mantissa1
004492  1  98                   TYA                     ; restore FAC2-FAC1 compare status
004493  1               
004493  1               ; FAC2 = FAC2*2
004493  1               LAB_2704:
004493  1  06 B6                ASL     <FAC2_3         ; shift FAC2 mantissa3
004495  1  26 B5                ROL     <FAC2_2         ; shift FAC2 mantissa2
004497  1  26 B4                ROL     <FAC2_1         ; shift FAC2 mantissa1
004499  1  B0 CF                BCS     LAB_26F4        ; loop with no compare
00449B  1               
00449B  1  30 BD                BMI     LAB_26E4        ; loop with compare
00449D  1               
00449D  1  10 CB                BPL     LAB_26F4        ; loop always with no compare
00449F  1               
00449F  1               ; do A<<6, save as FAC1 rounding byte, normalise and return
00449F  1               
00449F  1               LAB_272B:
00449F  1  4A                   LSR     A               ; shift b1 - b0 ..
0044A0  1  6A                   ROR     A               ; ..
0044A1  1  6A                   ROR     A               ; .. to b7 - b6
0044A2  1  85 B9                STA     <FAC1_r         ; save FAC1 rounding byte
0044A4  1  28                   PLP                     ; dump FAC2-FAC1 compare status
0044A5  1  4C AD 44             JMP     LAB_273C        ; copy temp to FAC1, normalise and return
0044A8  1               
0044A8  1               ; do "Divide by zero" error
0044A8  1               
0044A8  1               LAB_2737:
0044A8  1  A2 14                LDX     #$14            ; error code $14 ("Divide by zero" error)
0044AA  1  4C 08 28             JMP     LAB_XERR        ; do error #X, then warm start
0044AD  1               
0044AD  1               ; copy temp to FAC1 and normalise
0044AD  1               
0044AD  1               LAB_273C:
0044AD  1  A5 75                LDA     <FACt_1         ; get temp mantissa1
0044AF  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
0044B1  1  A5 76                LDA     <FACt_2         ; get temp mantissa2
0044B3  1  85 AE                STA     <FAC1_2         ; save FAC1 mantissa2
0044B5  1  A5 77                LDA     <FACt_3         ; get temp mantissa3
0044B7  1  85 AF                STA     <FAC1_3         ; save FAC1 mantissa3
0044B9  1  4C 23 42             JMP     LAB_24D5        ; normalise FAC1 and return
0044BC  1               
0044BC  1               ; unpack memory (AY) into FAC1
0044BC  1               
0044BC  1               LAB_UFAC:
0044BC  1  85 71                STA     <ut1_pl         ; save pointer low byte
0044BE  1  84 72                STY     <ut1_ph         ; save pointer high byte
0044C0  1  A0 03                LDY     #$03            ; 4 bytes to do
0044C2  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get last byte
0044C6  1  B5 71 C9 00  
0044CA  1  D0 04 A2 00  
0044D8  1  85 AF                STA     <FAC1_3         ; save FAC1 mantissa3
0044DA  1  88                   DEY                     ; decrement index
0044DB  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get last-1 byte
0044DF  1  B5 71 C9 00  
0044E3  1  D0 04 A2 00  
0044F1  1  85 AE                STA     <FAC1_2         ; save FAC1 mantissa2
0044F3  1  88                   DEY                     ; decrement index
0044F4  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get second byte
0044F8  1  B5 71 C9 00  
0044FC  1  D0 04 A2 00  
00450A  1  85 B0                STA     <FAC1_s         ; save FAC1 sign (b7)
00450C  1  09 80                ORA     #$80            ; set 1xxx xxxx (add normal bit)
00450E  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
004510  1  88                   DEY                     ; decrement index
004511  1  8B DA A2 01          LDAINDIRECTY ut1_pl     ; get first byte (exponent)
004515  1  B5 71 C9 00  
004519  1  D0 04 A2 00  
004527  1  85 AC                STA     <FAC1_e         ; save FAC1 exponent
004529  1  84 B9                STY     <FAC1_r         ; clear FAC1 rounding byte
00452B  1  60                   RTS
00452C  1               
00452C  1               ; pack FAC1 into <Adatal
00452C  1               
00452C  1               LAB_276E:
00452C  1  A2 A4                LDX     #<Adatal        ; set pointer low byte
00452E  1               LAB_2770:
00452E  1  A0 00                LDY     #>Adatal        ; set pointer high byte
004530  1  F0 04                BEQ     LAB_2778        ; pack FAC1 into (XY) and return
004532  1               
004532  1               ; pack FAC1 into (<Lvarpl)
004532  1               
004532  1               LAB_PFAC:
004532  1  A6 97                LDX     <Lvarpl         ; get destination pointer low byte
004534  1  A4 98                LDY     <Lvarph         ; get destination pointer high byte
004536  1               
004536  1               ; pack FAC1 into (XY)
004536  1               
004536  1               LAB_2778:
004536  1  20 B8 45             JSR     LAB_27BA        ; round FAC1
004539  1  86 71                STX     <ut1_pl         ; save pointer low byte
00453B  1  84 72                STY     <ut1_ph         ; save pointer high byte
00453D  1  A0 03                LDY     #$03            ; set index
00453F  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
004541  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; store in destination
004545  1  01 B5 71 C9  
004549  1  00 D0 04 A2  
004557  1  88                   DEY                     ; decrement index
004558  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
00455A  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; store in destination
00455E  1  01 B5 71 C9  
004562  1  00 D0 04 A2  
004570  1  88                   DEY                     ; decrement index
004571  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
004573  1  09 7F                ORA     #$7F            ; set bits x111 1111
004575  1  25 AD                AND     <FAC1_1         ; AND in FAC1 mantissa1
004577  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; store in destination
00457B  1  01 B5 71 C9  
00457F  1  00 D0 04 A2  
00458D  1  88                   DEY                     ; decrement index
00458E  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
004590  1  8B DA 48 A2          STAINDIRECTY ut1_pl     ; store in destination
004594  1  01 B5 71 C9  
004598  1  00 D0 04 A2  
0045A6  1  84 B9                STY     <FAC1_r         ; clear FAC1 rounding byte
0045A8  1  60                   RTS
0045A9  1               
0045A9  1               ; round and copy FAC1 to FAC2
0045A9  1               
0045A9  1               LAB_27AB:
0045A9  1  20 B8 45             JSR     LAB_27BA        ; round FAC1
0045AC  1               
0045AC  1               ; copy FAC1 to FAC2
0045AC  1               
0045AC  1               LAB_27AE:
0045AC  1  A2 05                LDX     #$05            ; 5 bytes to copy
0045AE  1               LAB_27B0:
0045AE  1  B5 AB                LDA     <FAC1_e-1,X     ; get byte from FAC1,X
0045B0  1  95 B2                STA     <FAC1_o,X       ; save byte at FAC2,X
0045B2  1  CA                   DEX                     ; decrement count
0045B3  1  D0 F9                BNE     LAB_27B0        ; loop if not all done
0045B5  1               
0045B5  1  86 B9                STX     <FAC1_r         ; clear FAC1 rounding byte
0045B7  1               LAB_27B9:
0045B7  1  60                   RTS
0045B8  1               
0045B8  1               ; round FAC1
0045B8  1               
0045B8  1               LAB_27BA:
0045B8  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
0045BA  1  F0 FB                BEQ     LAB_27B9        ; exit if zero
0045BC  1               
0045BC  1  06 B9                ASL     <FAC1_r         ; shift FAC1 rounding byte
0045BE  1  90 F7                BCC     LAB_27B9        ; exit if no overflow
0045C0  1               
0045C0  1               ; round FAC1 (no check)
0045C0  1               
0045C0  1               LAB_27C2:
0045C0  1  20 A7 42             JSR     LAB_2559        ; increment FAC1 mantissa
0045C3  1  D0 F2                BNE     LAB_27B9        ; branch if no overflow
0045C5  1               
0045C5  1  4C 78 42             JMP     LAB_252A        ; normalise FAC1 for C=1 and return
0045C8  1               
0045C8  1               ; get FAC1 sign
0045C8  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
0045C8  1               
0045C8  1               LAB_27CA:
0045C8  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
0045CA  1  F0 09                BEQ     LAB_27D7        ; exit if zero (already correct SGN(0)=0)
0045CC  1               
0045CC  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
0045CC  1               ; no = 0 check
0045CC  1               
0045CC  1               LAB_27CE:
0045CC  1  A5 B0                LDA     <FAC1_s         ; else get FAC1 sign (b7)
0045CE  1               
0045CE  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
0045CE  1               ; no = 0 check, sign in A
0045CE  1               
0045CE  1               LAB_27D0:
0045CE  1  2A                   ROL     A               ; move sign bit to carry
0045CF  1  A9 FF                LDA     #$FF            ; set byte for -ve result
0045D1  1  B0 02                BCS     LAB_27D7        ; return if sign was set (-ve)
0045D3  1               
0045D3  1  A9 01                LDA     #$01            ; else set byte for +ve result
0045D5  1               LAB_27D7:
0045D5  1  60                   RTS
0045D6  1               
0045D6  1               ; perform SGN()
0045D6  1               
0045D6  1               LAB_SGN:
0045D6  1  20 C8 45             JSR     LAB_27CA        ; get FAC1 sign
0045D9  1               ; return A=$FF/-ve A=$01/+ve
0045D9  1               ; save A as integer byte
0045D9  1               
0045D9  1               LAB_27DB:
0045D9  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
0045DB  1  A9 00                LDA     #$00            ; clear A
0045DD  1  85 AE                STA     <FAC1_2         ; clear FAC1 mantissa2
0045DF  1  A2 88                LDX     #$88            ; set exponent
0045E1  1               
0045E1  1               ; set exp=X, clearFAC1 mantissa3 and normalise
0045E1  1               
0045E1  1               LAB_27E3:
0045E1  1  A5 AD                LDA     <FAC1_1         ; get FAC1 mantissa1
0045E3  1  49 FF                EOR     #$FF            ; complement it
0045E5  1  2A                   ROL     A               ; sign bit into carry
0045E6  1               
0045E6  1               ; set exp=X, clearFAC1 mantissa3 and normalise
0045E6  1               
0045E6  1               LAB_STFA:
0045E6  1  A9 00                LDA     #$00            ; clear A
0045E8  1  85 AF                STA     <FAC1_3         ; clear FAC1 mantissa3
0045EA  1  86 AC                STX     <FAC1_e         ; set FAC1 exponent
0045EC  1  85 B9                STA     <FAC1_r         ; clear FAC1 rounding byte
0045EE  1  85 B0                STA     <FAC1_s         ; clear FAC1 sign (b7)
0045F0  1  4C 1E 42             JMP     LAB_24D0        ; do ABS and normalise FAC1
0045F3  1               
0045F3  1               ; perform ABS()
0045F3  1               
0045F3  1               LAB_ABS:
0045F3  1  46 B0                LSR     <FAC1_s         ; clear FAC1 sign (put zero in b7)
0045F5  1  60                   RTS
0045F6  1               
0045F6  1               ; compare FAC1 with (AY)
0045F6  1               ; returns A=$00 if FAC1 = (AY)
0045F6  1               ; returns A=$01 if FAC1 > (AY)
0045F6  1               ; returns A=$FF if FAC1 < (AY)
0045F6  1               
0045F6  1               LAB_27F8:
0045F6  1  85 73                STA     <ut2_pl         ; save pointer low byte
0045F8  1               LAB_27FA:
0045F8  1  84 74                STY     <ut2_ph         ; save pointer high byte
0045FA  1  A0 00                LDY     #$00            ; clear index
0045FC  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get exponent
004600  1  B5 73 C9 00  
004604  1  D0 04 A2 00  
004612  1  C8                   INY                     ; increment index
004613  1  AA                   TAX                     ; copy (AY) exponent to X
004614  1  F0 B2                BEQ     LAB_27CA        ; branch if (AY) exponent=0 and get FAC1 sign
004616  1               ; A=FF,C=1/-ve A=01,C=0/+ve
004616  1               
004616  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get (AY) mantissa1 (with sign)
00461A  1  B5 73 C9 00  
00461E  1  D0 04 A2 00  
00462C  1  45 B0                EOR     <FAC1_s         ; EOR FAC1 sign (b7)
00462E  1  30 9C                BMI     LAB_27CE        ; if signs <> do return A=FF,C=1/-ve
004630  1               ; A=01,C=0/+ve and return
004630  1               
004630  1  E4 AC                CPX     <FAC1_e         ; compare (AY) exponent with FAC1 exponent
004632  1  D0 56                BNE     LAB_2828        ; branch if different
004634  1               
004634  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get (AY) mantissa1 (with sign)
004638  1  B5 73 C9 00  
00463C  1  D0 04 A2 00  
00464A  1  09 80                ORA     #$80            ; normalise top bit
00464C  1  C5 AD                CMP     <FAC1_1         ; compare with FAC1 mantissa1
00464E  1  D0 3A                BNE     LAB_2828        ; branch if different
004650  1               
004650  1  C8                   INY                     ; increment index
004651  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get mantissa2
004655  1  B5 73 C9 00  
004659  1  D0 04 A2 00  
004667  1  C5 AE                CMP     <FAC1_2         ; compare with FAC1 mantissa2
004669  1  D0 1F                BNE     LAB_2828        ; branch if different
00466B  1               
00466B  1  C8                   INY                     ; increment index
00466C  1  A9 7F                LDA     #$7F            ; set for 1/2 value rounding byte
00466E  1  C5 B9                CMP     <FAC1_r         ; compare with FAC1 rounding byte (set carry)
004670  1  8B DA A2 01          LDAINDIRECTY ut2_pl     ; get mantissa3
004674  1  B5 73 C9 00  
004678  1  D0 04 A2 00  
004686  1  E5 AF                SBC     <FAC1_3         ; subtract FAC1 mantissa3
004688  1  F0 28                BEQ     LAB_2850        ; exit if mantissa3 equal
00468A  1               
00468A  1               ; gets here if number <> FAC1
00468A  1               
00468A  1               LAB_2828:
00468A  1               
00468A  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
00468C  1  90 02                BCC     LAB_282E        ; branch if FAC1 > (AY)
00468E  1               
00468E  1  49 FF                EOR     #$FF            ; else toggle FAC1 sign
004690  1               LAB_282E:
004690  1  4C CE 45             JMP     LAB_27D0        ; return A=FF,C=1/-ve A=01,C=0/+ve
004693  1               
004693  1               ; convert FAC1 floating-to-fixed
004693  1               
004693  1               LAB_2831:
004693  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
004695  1  F0 4A                BEQ     LAB_287F        ; if zero go clear FAC1 and return
004697  1               
004697  1  38                   SEC                     ; set carry for subtract
004698  1  E9 98                SBC     #$98            ; subtract maximum integer range exponent
00469A  1  24 B0                BIT     <FAC1_s         ; test FAC1 sign (b7)
00469C  1  10 09                BPL     LAB_2845        ; branch if FAC1 +ve
00469E  1               
00469E  1               ; FAC1 was -ve
00469E  1  AA                   TAX                     ; copy subtracted exponent
00469F  1  A9 FF                LDA     #$FF            ; overflow for -ve number
0046A1  1  85 B2                STA     <FAC1_o         ; set FAC1 overflow byte
0046A3  1  20 8B 42             JSR     LAB_253D        ; twos complement FAC1 mantissa
0046A6  1  8A                   TXA                     ; restore subtracted exponent
0046A7  1               LAB_2845:
0046A7  1  A2 AC                LDX     #<FAC1_e        ; set index to FAC1
0046A9  1  C9 F9                CMP     #$F9            ; compare exponent result
0046AB  1  10 06                BPL     LAB_2851        ; if < 8 shifts shift FAC1 A times right and return
0046AD  1               
0046AD  1  20 C9 42             JSR     LAB_257B        ; shift FAC1 A times right (> 8 shifts)
0046B0  1  84 B2                STY     <FAC1_o         ; clear FAC1 overflow byte
0046B2  1               LAB_2850:
0046B2  1  60                   RTS
0046B3  1               
0046B3  1               ; shift FAC1 A times right
0046B3  1               
0046B3  1               LAB_2851:
0046B3  1  A8                   TAY                     ; copy shift count
0046B4  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
0046B6  1  29 80                AND     #$80            ; mask sign bit only (x000 0000)
0046B8  1  46 AD                LSR     <FAC1_1         ; shift FAC1 mantissa1
0046BA  1  05 AD                ORA     <FAC1_1         ; OR sign in b7 FAC1 mantissa1
0046BC  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
0046BE  1  20 E0 42             JSR     LAB_2592        ; shift FAC1 Y times right
0046C1  1  84 B2                STY     <FAC1_o         ; clear FAC1 overflow byte
0046C3  1  60                   RTS
0046C4  1               
0046C4  1               ; perform INT()
0046C4  1               
0046C4  1               LAB_INT:
0046C4  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
0046C6  1  C9 98                CMP     #$98            ; compare with max int
0046C8  1  B0 1E                BCS     LAB_2886        ; exit if >= (already int, too big for fractional part!)
0046CA  1               
0046CA  1  20 93 46             JSR     LAB_2831        ; convert FAC1 floating-to-fixed
0046CD  1  84 B9                STY     <FAC1_r         ; save FAC1 rounding byte
0046CF  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
0046D1  1  84 B0                STY     <FAC1_s         ; save FAC1 sign (b7)
0046D3  1  49 80                EOR     #$80            ; toggle FAC1 sign
0046D5  1  2A                   ROL     A               ; shift into carry
0046D6  1  A9 98                LDA     #$98            ; set new exponent
0046D8  1  85 AC                STA     <FAC1_e         ; save FAC1 exponent
0046DA  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
0046DC  1  85 5B                STA     <Temp3          ; save for EXP() function
0046DE  1  4C 1E 42             JMP     LAB_24D0        ; do ABS and normalise FAC1
0046E1  1               
0046E1  1               ; clear FAC1 and return
0046E1  1               
0046E1  1               LAB_287F:
0046E1  1  85 AD                STA     <FAC1_1         ; clear FAC1 mantissa1
0046E3  1  85 AE                STA     <FAC1_2         ; clear FAC1 mantissa2
0046E5  1  85 AF                STA     <FAC1_3         ; clear FAC1 mantissa3
0046E7  1  A8                   TAY                     ; clear Y
0046E8  1               LAB_2886:
0046E8  1  60                   RTS
0046E9  1               
0046E9  1               ; get FAC1 from string
0046E9  1               ; this routine now handles hex and binary values from strings
0046E9  1               ; starting with "$" and "%" respectively
0046E9  1               
0046E9  1               LAB_2887:
0046E9  1  A0 00                LDY     #$00            ; clear Y
0046EB  1  84 5F                STY     <Dtypef         ; clear data type flag, $FF=string, $00=numeric
0046ED  1  A2 09                LDX     #$09            ; set index
0046EF  1               LAB_288B:
0046EF  1  94 A8                STY     <numexp,x       ; clear byte
0046F1  1  CA                   DEX                     ; decrement index
0046F2  1  10 FB                BPL     LAB_288B        ; loop until <numexp to <negnum (and FAC1) = $00
0046F4  1               
0046F4  1  B0 03                BCS     LAB_s28FE       ; branch if 1st NOT character numeric
0046F6  1  4C 7C 47             JMP     LAB_28FE        ; branch if 1st character numeric
0046F9  1               LAB_s28FE:
0046F9  1               
0046F9  1               ; get FAC1 from string .. first character wasn't numeric
0046F9  1               
0046F9  1  C9 2D                CMP     #'-'            ; else compare with "-"
0046FB  1  D0 04                BNE     LAB_289A        ; branch if not "-"
0046FD  1               
0046FD  1  86 B1                STX     <negnum         ; set flag for -ve number (X = $FF)
0046FF  1  F0 04                BEQ     LAB_289C        ; branch always (go scan and check for hex/bin)
004701  1               
004701  1               ; get FAC1 from string .. first character wasn't numeric or -
004701  1               
004701  1               LAB_289A:
004701  1  C9 2B                CMP     #'+'            ; else compare with "+"
004703  1  D0 06                BNE     LAB_289D        ; branch if not "+" (go check for hex/bin)
004705  1               
004705  1               ; was "+" or "-" to start, so get next character
004705  1               
004705  1               LAB_289C:
004705  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
004709  1  90 71                BCC     LAB_28FE        ; branch if numeric character
00470B  1               
00470B  1               ; code here for hex and binary numbers
00470B  1               
00470B  1               LAB_289D:
00470B  1  C9 24                CMP     #'$'            ; else compare with "$"
00470D  1  D0 03                BNE     LAB_NHEX        ; branch if not "$"
00470F  1               
00470F  1  4C 3A 4C             JMP     LAB_CHEX        ; branch if "$"
004712  1               
004712  1               LAB_NHEX:
004712  1  C9 25                CMP     #'%'            ; else compare with "%"
004714  1  D0 09                BNE     LAB_28A3        ; branch if not "%" (continue original code)
004716  1               
004716  1  4C 69 4C             JMP     LAB_CBIN        ; branch if "%"
004719  1               
004719  1               LAB_289E:
004719  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory (ignore + or get next number)
00471D  1               LAB_28A1:
00471D  1  90 5D                BCC     LAB_28FE        ; branch if numeric character
00471F  1               
00471F  1               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
00471F  1               
00471F  1               LAB_28A3:
00471F  1  C9 2E                CMP     #'.'            ; else compare with "."
004721  1  F0 30                BEQ     LAB_28D5        ; branch if "."
004723  1               
004723  1               ; get FAC1 from string .. character wasn't numeric, -, + or .
004723  1               
004723  1  C9 45                CMP     #'E'            ; else compare with "E"
004725  1  D0 32                BNE     LAB_28DB        ; branch if not "E"
004727  1               
004727  1               ; was "E" so evaluate exponential part
004727  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
00472B  1  90 18                BCC     LAB_28C7        ; branch if numeric character
00472D  1               
00472D  1  C9 CC                CMP     #TK_MINUS       ; else compare with token for -
00472F  1  F0 0E                BEQ     LAB_28C2        ; branch if token for -
004731  1               
004731  1  C9 2D                CMP     #'-'            ; else compare with "-"
004733  1  F0 0A                BEQ     LAB_28C2        ; branch if "-"
004735  1               
004735  1  C9 CB                CMP     #TK_PLUS        ; else compare with token for +
004737  1  F0 08                BEQ     LAB_28C4        ; branch if token for +
004739  1               
004739  1  C9 2B                CMP     #'+'            ; else compare with "+"
00473B  1  F0 04                BEQ     LAB_28C4        ; branch if "+"
00473D  1               
00473D  1  D0 08                BNE     LAB_28C9        ; branch always
00473F  1               
00473F  1               LAB_28C2:
00473F  1  66 AB                ROR     <expneg         ; set exponent -ve flag (C, which=1, into b7)
004741  1               LAB_28C4:
004741  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
004745  1               LAB_28C7:
004745  1  90 5B                BCC     LAB_2925        ; branch if numeric character
004747  1               
004747  1               LAB_28C9:
004747  1  24 AB                BIT     <expneg         ; test exponent -ve flag
004749  1  10 0E                BPL     LAB_28DB        ; if +ve go evaluate exponent
00474B  1               
00474B  1               ; else do exponent = -exponent
00474B  1  A9 00                LDA     #$00            ; clear result
00474D  1  38                   SEC                     ; set carry for subtract
00474E  1  E5 A9                SBC     <expcnt         ; subtract exponent byte
004750  1  4C 5B 47             JMP     LAB_28DD        ; go evaluate exponent
004753  1               
004753  1               LAB_28D5:
004753  1  66 AA                ROR     <numdpf         ; set decimal point flag
004755  1  24 AA                BIT     <numdpf         ; test decimal point flag
004757  1  50 C0                BVC     LAB_289E        ; branch if only one decimal point so far
004759  1               
004759  1               ; evaluate exponent
004759  1               LAB_28DB:
004759  1  A5 A9                LDA     <expcnt         ; get exponent count byte
00475B  1               LAB_28DD:
00475B  1  38                   SEC                     ; set carry for subtract
00475C  1  E5 A8                SBC     <numexp         ; subtract numerator exponent
00475E  1  85 A9                STA     <expcnt         ; save exponent count byte
004760  1  F0 12                BEQ     LAB_28F6        ; branch if no adjustment
004762  1               
004762  1  10 09                BPL     LAB_28EF        ; else if +ve go do FAC1*10^<expcnt
004764  1               
004764  1               ; else go do FAC1/10^(0-<expcnt)
004764  1               LAB_28E6:
004764  1  20 2F 44             JSR     LAB_26B9        ; divide by 10
004767  1  E6 A9                INC     <expcnt         ; increment exponent count byte
004769  1  D0 F9                BNE     LAB_28E6        ; loop until all done
00476B  1               
00476B  1  F0 07                BEQ     LAB_28F6        ; branch always
00476D  1               
00476D  1               LAB_28EF:
00476D  1  20 16 44             JSR     LAB_269E        ; multiply by 10
004770  1  C6 A9                DEC     <expcnt         ; decrement exponent count byte
004772  1  D0 F9                BNE     LAB_28EF        ; loop until all done
004774  1               
004774  1               LAB_28F6:
004774  1  A5 B1                LDA     <negnum         ; get -ve flag
004776  1  30 01                BMI     LAB_28FB        ; if -ve do - FAC1 and return
004778  1               
004778  1  60                   RTS
004779  1               
004779  1               ; do - FAC1 and return
004779  1               
004779  1               LAB_28FB:
004779  1  4C 6C 49             JMP     LAB_GTHAN       ; do - FAC1 and return
00477C  1               
00477C  1               ; do unsigned FAC1*10+number
00477C  1               
00477C  1               LAB_28FE:
00477C  1  48                   PHA                     ; save character
00477D  1  24 AA                BIT     <numdpf         ; test decimal point flag
00477F  1  10 02                BPL     LAB_2905        ; skip exponent increment if not set
004781  1               
004781  1  E6 A8                INC     <numexp         ; else increment number exponent
004783  1               LAB_2905:
004783  1  20 16 44             JSR     LAB_269E        ; multiply FAC1 by 10
004786  1  68                   PLA                     ; restore character
004787  1  29 0F                AND     #$0F            ; convert to binary
004789  1  20 8F 47             JSR     LAB_2912        ; evaluate new ASCII digit
00478C  1  4C 19 47             JMP     LAB_289E        ; go do next character
00478F  1               
00478F  1               ; evaluate new ASCII digit
00478F  1               
00478F  1               LAB_2912:
00478F  1  48                   PHA                     ; save digit
004790  1  20 A9 45             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
004793  1  68                   PLA                     ; restore digit
004794  1  20 D9 45             JSR     LAB_27DB        ; save A as integer byte
004797  1  A5 B7                LDA     <FAC2_s         ; get FAC2 sign (b7)
004799  1  45 B0                EOR     <FAC1_s         ; toggle with FAC1 sign (b7)
00479B  1  85 B8                STA     <FAC_sc         ; save sign compare (FAC1 EOR FAC2)
00479D  1  A6 AC                LDX     <FAC1_e         ; get FAC1 exponent
00479F  1  4C AA 41             JMP     LAB_ADD         ; add FAC2 to FAC1 and return
0047A2  1               
0047A2  1               ; evaluate next character of exponential part of number
0047A2  1               
0047A2  1               LAB_2925:
0047A2  1  A5 A9                LDA     <expcnt         ; get exponent count byte
0047A4  1  C9 0A                CMP     #$0A            ; compare with 10 decimal
0047A6  1  90 09                BCC     LAB_2934        ; branch if less
0047A8  1               
0047A8  1  A9 64                LDA     #$64            ; make all -ve exponents = -100 decimal (causes underflow)
0047AA  1  24 AB                BIT     <expneg         ; test exponent -ve flag
0047AC  1  30 25                BMI     LAB_2942        ; branch if -ve
0047AE  1               
0047AE  1  4C B2 42             JMP     LAB_2564        ; else do overflow error
0047B1  1               
0047B1  1               LAB_2934:
0047B1  1  0A                   ASL     A               ; * 2
0047B2  1  0A                   ASL     A               ; * 4
0047B3  1  65 A9                ADC     <expcnt         ; * 5
0047B5  1  0A                   ASL     A               ; * 10
0047B6  1  A0 00                LDY     #$00            ; set index
0047B8  1  8B 48 DA A2          ADCINDIRECTY Bpntrl     ; add character (will be $30 too much!)
0047BC  1  01 B5 C3 C9  
0047C0  1  00 D0 04 A2  
0047D1  1  E9 2F                SBC     #'0'-1          ; convert character to binary
0047D3  1               LAB_2942:
0047D3  1  85 A9                STA     <expcnt         ; save exponent count byte
0047D5  1  4C 41 47             JMP     LAB_28C4        ; go get next character
0047D8  1               
0047D8  1               ; print " in line [LINE #]"
0047D8  1               
0047D8  1               LAB_2953:
0047D8  1  A9 D1                LDA     #<LAB_LMSG      ; point to " in line " message low byte
0047DA  1  A0 17                LDY     #>LAB_LMSG      ; point to " in line " message high byte
0047DC  1  20 CA 30             JSR     LAB_18C3        ; print null terminated string from memory
0047DF  1               
0047DF  1               ; print Basic line #
0047DF  1  A5 88                LDA     <Clineh         ; get current line high byte
0047E1  1  A6 87                LDX     <Clinel         ; get current line low byte
0047E3  1               
0047E3  1               ; print XA as unsigned integer
0047E3  1               
0047E3  1               LAB_295E:
0047E3  1  85 AD                STA     <FAC1_1         ; save low byte as FAC1 mantissa1
0047E5  1  86 AE                STX     <FAC1_2         ; save high byte as FAC1 mantissa2
0047E7  1  A2 90                LDX     #$90            ; set exponent to 16d bits
0047E9  1  38                   SEC                     ; set integer is +ve flag
0047EA  1  20 E6 45             JSR     LAB_STFA        ; set exp=X, clearFAC1 mantissa3 and normalise
0047ED  1  A0 00                LDY     #$00            ; clear index
0047EF  1  98                   TYA                     ; clear A
0047F0  1  20 05 48             JSR     LAB_297B        ; convert FAC1 to string, skip sign character save
0047F3  1  4C CA 30             JMP     LAB_18C3        ; print null terminated string from memory and return
0047F6  1               
0047F6  1               ; convert FAC1 to ASCII string result in (AY)
0047F6  1               ; not any more, moved scratchpad to page 0
0047F6  1               
0047F6  1               LAB_296E:
0047F6  1  A0 01                LDY     #$01            ; set index = 1
0047F8  1  A9 20                LDA     #$20            ; character = " " (assume +ve)
0047FA  1  24 B0                BIT     <FAC1_s         ; test FAC1 sign (b7)
0047FC  1  10 02                BPL     LAB_2978        ; branch if +ve
0047FE  1               
0047FE  1  A9 2D                LDA     #$2D            ; else character = "-"
004800  1               LAB_2978:
004800  1  DA                   PHX
004801  1  BB                   TYX
004802  1  95 EF                STA     <Decss,X        ; save leading character (" " or "-")
004804  1  FA                   PLX
004805  1               LAB_297B:
004805  1  85 B0                STA     <FAC1_s         ; clear FAC1 sign (b7)
004807  1  84 BA                STY     <Sendl          ; save index
004809  1  C8                   INY                     ; increment index
00480A  1  A6 AC                LDX     <FAC1_e         ; get FAC1 exponent
00480C  1  D0 05                BNE     LAB_2989        ; branch if FAC1<>0
00480E  1               
00480E  1               ; exponent was $00 so FAC1 is 0
00480E  1  A9 30                LDA     #'0'            ; set character = "0"
004810  1  4C 22 49             JMP     LAB_2A89        ; save last character, [EOT] and exit
004813  1               
004813  1               ; FAC1 is some non zero value
004813  1               LAB_2989:
004813  1  A9 00                LDA     #$00            ; clear (number exponent count)
004815  1  E0 81                CPX     #$81            ; compare FAC1 exponent with $81 (>1.00000)
004817  1               
004817  1  B0 09                BCS     LAB_299A        ; branch if FAC1=>1
004819  1               
004819  1               ; FAC1<1
004819  1  A9 3B                LDA     #<LAB_294F      ; set pointer low byte to 1,000,000
00481B  1  A0 18                LDY     #>LAB_294F      ; set pointer high byte to 1,000,000
00481D  1  20 28 43             JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
004820  1  A9 FA                LDA     #$FA            ; set number exponent count (-6)
004822  1               LAB_299A:
004822  1  85 A8                STA     <numexp         ; save number exponent count
004824  1               LAB_299C:
004824  1  A9 37                LDA     #<LAB_294B      ; set pointer low byte to 999999.4375 (max before sci note)
004826  1  A0 18                LDY     #>LAB_294B      ; set pointer high byte to 999999.4375
004828  1  20 F6 45             JSR     LAB_27F8        ; compare FAC1 with (AY)
00482B  1  F0 1E                BEQ     LAB_29C3        ; exit if FAC1 = (AY)
00482D  1  10 12                BPL     LAB_29B9        ; go do /10 if FAC1 > (AY)
00482F  1               ; FAC1 < (AY)
00482F  1               LAB_29A7:
00482F  1  A9 33                LDA     #<LAB_2947      ; set pointer low byte to 99999.9375
004831  1  A0 18                LDY     #>LAB_2947      ; set pointer high byte to 99999.9375
004833  1  20 F6 45             JSR     LAB_27F8        ; compare FAC1 with (AY)
004836  1  F0 02                BEQ     LAB_29B2        ; branch if FAC1 = (AY) (allow decimal places)
004838  1  10 0E                BPL     LAB_29C0        ; branch if FAC1 > (AY) (no decimal places)
00483A  1               ; FAC1 <= (AY)
00483A  1               LAB_29B2:
00483A  1  20 16 44             JSR     LAB_269E        ; multiply by 10
00483D  1  C6 A8                DEC     <numexp         ; decrement number exponent count
00483F  1  D0 EE                BNE     LAB_29A7        ; go test again (branch always)
004841  1               
004841  1               LAB_29B9:
004841  1  20 2F 44             JSR     LAB_26B9        ; divide by 10
004844  1  E6 A8                INC     <numexp         ; increment number exponent count
004846  1  D0 DC                BNE     LAB_299C        ; go test again (branch always)
004848  1               
004848  1               ; now we have just the digits to do
004848  1               
004848  1               LAB_29C0:
004848  1  20 A3 41             JSR     LAB_244E        ; add 0.5 to FAC1 (round FAC1)
00484B  1               LAB_29C3:
00484B  1  20 93 46             JSR     LAB_2831        ; convert FAC1 floating-to-fixed
00484E  1  A2 01                LDX     #$01            ; set default digits before dp = 1
004850  1  A5 A8                LDA     <numexp         ; get number exponent count
004852  1  18                   CLC                     ; clear carry for add
004853  1  69 07                ADC     #$07            ; up to 6 digits before point
004855  1  30 09                BMI     LAB_29D8        ; if -ve then 1 digit before dp
004857  1               
004857  1  C9 08                CMP     #$08            ; A>=8 if n>=1E6
004859  1  B0 06                BCS     LAB_29D9        ; branch if >= $08
00485B  1               
00485B  1               ; carry is clear
00485B  1  69 FF                ADC     #$FF            ; take 1 from digit count
00485D  1  AA                   TAX                     ; copy to A
00485E  1  A9 02                LDA     #$02            ;.set exponent adjust
004860  1               LAB_29D8:
004860  1  38                   SEC                     ; set carry for subtract
004861  1               LAB_29D9:
004861  1  E9 02                SBC     #$02            ; -2
004863  1  85 A9                STA     <expcnt         ;.save exponent adjust
004865  1  86 A8                STX     <numexp         ; save digits before dp count
004867  1  8A                   TXA                     ; copy to A
004868  1  F0 02                BEQ     LAB_29E4        ; branch if no digits before dp
00486A  1               
00486A  1  10 17                BPL     LAB_29F7        ; branch if digits before dp
00486C  1               
00486C  1               LAB_29E4:
00486C  1  A4 BA                LDY     <Sendl          ; get output string index
00486E  1  A9 2E                LDA     #$2E            ; character "."
004870  1  C8                   INY                     ; increment index
004871  1  DA                   PHX
004872  1  BB                   TYX
004873  1  95 EF                STA     <Decss,X        ; save to output string
004875  1  FA                   PLX
004876  1  8A                   TXA                     ;.
004877  1  F0 08                BEQ     LAB_29F5        ;.
004879  1               
004879  1  A9 30                LDA     #'0'            ; character "0"
00487B  1  C8                   INY                     ; increment index
00487C  1  DA                   PHX
00487D  1  BB                   TYX
00487E  1  95 EF                STA     <Decss,X        ; save to output string
004880  1  FA                   PLX
004881  1               LAB_29F5:
004881  1  84 BA                STY     <Sendl          ; save output string index
004883  1               LAB_29F7:
004883  1  A0 00                LDY     #$00            ; clear index (point to 100,000)
004885  1  A2 80                LDX     #$80            ;
004887  1               LAB_29FB:
004887  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
004889  1  18                   CLC                     ; clear carry for add
00488A  1  79 B1 18             ADC     LAB_2A9C,Y      ; add -ve LSB
00488D  1  85 AF                STA     <FAC1_3         ; save FAC1 mantissa3
00488F  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
004891  1  79 B0 18             ADC     LAB_2A9B,Y      ; add -ve NMSB
004894  1  85 AE                STA     <FAC1_2         ; save FAC1 mantissa2
004896  1  A5 AD                LDA     <FAC1_1         ; get FAC1 mantissa1
004898  1  79 AF 18             ADC     LAB_2A9A,Y      ; add -ve MSB
00489B  1  85 AD                STA     <FAC1_1         ; save FAC1 mantissa1
00489D  1  E8                   INX                     ;
00489E  1  B0 04                BCS     LAB_2A18        ;
0048A0  1               
0048A0  1  10 E5                BPL     LAB_29FB        ; not -ve so try again
0048A2  1               
0048A2  1  30 02                BMI     LAB_2A1A        ;
0048A4  1               
0048A4  1               LAB_2A18:
0048A4  1  30 E1                BMI     LAB_29FB        ;
0048A6  1               
0048A6  1               LAB_2A1A:
0048A6  1  8A                   TXA                     ;
0048A7  1  90 04                BCC     LAB_2A21        ;
0048A9  1               
0048A9  1  49 FF                EOR     #$FF            ;
0048AB  1  69 0A                ADC     #$0A            ;
0048AD  1               LAB_2A21:
0048AD  1  69 2F                ADC     #'0'-1          ; add "0"-1 to result
0048AF  1  C8                   INY                     ; increment index ..
0048B0  1  C8                   INY                     ; .. to next less ..
0048B1  1  C8                   INY                     ; .. power of ten
0048B2  1  84 95                STY     <Cvaral         ; save as current var address low byte
0048B4  1  A4 BA                LDY     <Sendl          ; get output string index
0048B6  1  C8                   INY                     ; increment output string index
0048B7  1  AA                   TAX                     ; copy character to X
0048B8  1  29 7F                AND     #$7F            ; mask out top bit
0048BA  1  DA                   PHX
0048BB  1  BB                   TYX
0048BC  1  95 EF                STA     <Decss,X        ; save to output string
0048BE  1  FA                   PLX
0048BF  1  C6 A8                DEC     <numexp         ; decrement # of characters before the dp
0048C1  1  D0 08                BNE     LAB_2A3B        ; branch if still characters to do
0048C3  1               
0048C3  1               ; else output the point
0048C3  1  A9 2E                LDA     #$2E            ; character "."
0048C5  1  C8                   INY                     ; increment output string index
0048C6  1  DA                   PHX
0048C7  1  BB                   TYX
0048C8  1  95 EF                STA     <Decss,X        ; save to output string
0048CA  1  FA                   PLX
0048CB  1               LAB_2A3B:
0048CB  1  84 BA                STY     <Sendl          ; save output string index
0048CD  1  A4 95                LDY     <Cvaral         ; get current var address low byte
0048CF  1  8A                   TXA                     ; get character back
0048D0  1  49 FF                EOR     #$FF            ;
0048D2  1  29 80                AND     #$80            ;
0048D4  1  AA                   TAX                     ;
0048D5  1  C0 12                CPY     #$12            ; compare index with max
0048D7  1  D0 AE                BNE     LAB_29FB        ; loop if not max
0048D9  1               
0048D9  1               ; now remove trailing zeroes
0048D9  1  A4 BA                LDY     <Sendl          ; get output string index
0048DB  1               LAB_2A4B:
0048DB  1  DA                   PHX
0048DC  1  BB                   TYX
0048DD  1  B5 EF                LDA     <Decss,X        ; get character from output string
0048DF  1  FA                   PLX
0048E0  1  88                   DEY                     ; decrement output string index
0048E1  1  C9 30                CMP     #'0'            ; compare with "0"
0048E3  1  F0 F6                BEQ     LAB_2A4B        ; loop until non "0" character found
0048E5  1               
0048E5  1  C9 2E                CMP     #'.'            ; compare with "."
0048E7  1  F0 01                BEQ     LAB_2A58        ; branch if was dp
0048E9  1               
0048E9  1               ; restore last character
0048E9  1  C8                   INY                     ; increment output string index
0048EA  1               LAB_2A58:
0048EA  1  A9 2B                LDA     #$2B            ; character "+"
0048EC  1  A6 A9                LDX     <expcnt         ; get exponent count
0048EE  1  F0 37                BEQ     LAB_2A8C        ; if zero go set null terminator and exit
0048F0  1               
0048F0  1               ; exponent isn't zero so write exponent
0048F0  1  10 08                BPL     LAB_2A68        ; branch if exponent count +ve
0048F2  1               
0048F2  1  A9 00                LDA     #$00            ; clear A
0048F4  1  38                   SEC                     ; set carry for subtract
0048F5  1  E5 A9                SBC     <expcnt         ; subtract exponent count adjust (convert -ve to +ve)
0048F7  1  AA                   TAX                     ; copy exponent count to X
0048F8  1  A9 2D                LDA     #'-'            ; character "-"
0048FA  1               LAB_2A68:
0048FA  1  DA                   PHX
0048FB  1  BB                   TYX
0048FC  1  95 F1                STA     <Decss+2,X      ; save to output string
0048FE  1  A9 45                LDA     #$45            ; character "E"
004900  1  95 F0                STA     <Decss+1,X      ; save exponent sign to output string
004902  1  FA                   PLX
004903  1  8A                   TXA                     ; get exponent count back
004904  1  A2 2F                LDX     #'0'-1          ; one less than "0" character
004906  1  38                   SEC                     ; set carry for subtract
004907  1               LAB_2A74:
004907  1  E8                   INX                     ; increment 10's character
004908  1  E9 0A                SBC     #$0A            ;.subtract 10 from exponent count
00490A  1  B0 FB                BCS     LAB_2A74        ; loop while still >= 0
00490C  1               
00490C  1  69 3A                ADC     #':'            ; add character ":" ($30+$0A, result is 10 less that value)
00490E  1  DA                   PHX
00490F  1  BB                   TYX
004910  1  95 F3                STA     <Decss+4,X      ; save to output string
004912  1  FA                   PLX
004913  1  8A                   TXA                     ; copy 10's character
004914  1  DA                   PHX
004915  1  BB                   TYX
004916  1  95 F2                STA     <Decss+3,X      ; save to output string
004918  1  FA                   PLX
004919  1  A9 00                LDA     #$00            ; set null terminator
00491B  1  DA                   PHX
00491C  1  BB                   TYX
00491D  1  95 F4                STA     <Decss+5,X      ; save to output string
00491F  1  FA                   PLX
004920  1  F0 0C                BEQ     LAB_2A91        ; go set string pointer (AY) and exit (branch always)
004922  1               
004922  1               ; save last character, [EOT] and exit
004922  1               LAB_2A89:
004922  1  DA                   PHX
004923  1  BB                   TYX
004924  1  95 EF                STA     <Decss,X        ; save last character to output string
004926  1  FA                   PLX
004927  1               ; set null terminator and exit
004927  1               LAB_2A8C:
004927  1  A9 00                LDA     #$00            ; set null terminator
004929  1  DA                   PHX
00492A  1  BB                   TYX
00492B  1  95 F0                STA     <Decss+1,X      ; save after last character
00492D  1  FA                   PLX
00492E  1               ; set string pointer (AY) and exit
00492E  1               LAB_2A91:
00492E  1  A9 F0                LDA     #<Decssp1       ; set result string low pointer
004930  1  A0 00                LDY     #>Decssp1       ; set result string high pointer
004932  1  60                   RTS
004933  1               
004933  1               ; perform power function
004933  1               
004933  1               LAB_POWER:
004933  1  F0 42                BEQ     LAB_EXP         ; go do  EXP()
004935  1               
004935  1  A5 B3                LDA     <FAC2_e         ; get FAC2 exponent
004937  1  D0 03                BNE     LAB_2ABF        ; branch if FAC2<>0
004939  1               
004939  1  4C 41 42             JMP     LAB_24F3        ; clear FAC1 exponent and sign and return
00493C  1               
00493C  1               LAB_2ABF:
00493C  1  A2 9C                LDX     #<func_l        ; set destination pointer low byte
00493E  1  A0 00                LDY     #>func_l        ; set destination pointer high byte
004940  1  20 36 45             JSR     LAB_2778        ; pack FAC1 into (XY)
004943  1  A5 B7                LDA     <FAC2_s         ; get FAC2 sign (b7)
004945  1  10 0F                BPL     LAB_2AD9        ; branch if FAC2>0
004947  1               
004947  1               ; else FAC2 is -ve and can only be raised to an
004947  1               ; integer power which gives an x +j0 result
004947  1  20 C4 46             JSR     LAB_INT         ; perform INT
00494A  1  A9 9C                LDA     #<func_l        ; set source pointer low byte
00494C  1  A0 00                LDY     #>func_l        ; set source pointer high byte
00494E  1  20 F6 45             JSR     LAB_27F8        ; compare FAC1 with (AY)
004951  1  D0 03                BNE     LAB_2AD9        ; branch if FAC1 <> (AY) to allow Function Call error
004953  1               ; this will leave FAC1 -ve and cause a Function Call
004953  1               ; error when LOG() is called
004953  1               
004953  1  98                   TYA                     ; clear sign b7
004954  1  A4 5B                LDY     <Temp3          ; save mantissa 3 from INT() function as sign in Y
004956  1               ; for possible later negation, b0
004956  1               LAB_2AD9:
004956  1  20 AE 41             JSR     LAB_279D        ; save FAC1 sign and copy ABS(FAC2) to FAC1
004959  1  98                   TYA                     ; copy sign back ..
00495A  1  48                   PHA                     ; .. and save it
00495B  1  20 EA 42             JSR     LAB_LOG         ; do LOG(n)
00495E  1  A9 9C                LDA     #<garb_l        ; set pointer low byte
004960  1  A0 00                LDY     #>garb_l        ; set pointer high byte
004962  1  20 28 43             JSR     LAB_25FB        ; do convert AY, FCA1*(AY) (square the value)
004965  1  20 77 49             JSR     LAB_EXP         ; go do EXP(n)
004968  1  68                   PLA                     ; pull sign from stack
004969  1  4A                   LSR     A               ; b0 is to be tested, shift to Cb
00496A  1  90 0A                BCC     LAB_2AF9        ; if no bit then exit
00496C  1               
00496C  1               ; Perform negation
00496C  1               ; do - FAC1
00496C  1               
00496C  1               LAB_GTHAN:
00496C  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
00496E  1  F0 06                BEQ     LAB_2AF9        ; exit if <FAC1_e = $00
004970  1               
004970  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
004972  1  49 FF                EOR     #$FF            ; complement it
004974  1  85 B0                STA     <FAC1_s         ; save FAC1 sign (b7)
004976  1               LAB_2AF9:
004976  1  60                   RTS
004977  1               
004977  1               ; perform EXP()	(x^e)
004977  1               
004977  1               LAB_EXP:
004977  1  A9 3F                LDA     #<LAB_2AFA      ; set 1.443 pointer low byte
004979  1  A0 18                LDY     #>LAB_2AFA      ; set 1.443 pointer high byte
00497B  1  20 28 43             JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
00497E  1  A5 B9                LDA     <FAC1_r         ; get FAC1 rounding byte
004980  1  69 50                ADC     #$50            ; +$50/$100
004982  1  90 03                BCC     LAB_2B2B        ; skip rounding if no carry
004984  1               
004984  1  20 C0 45             JSR     LAB_27C2        ; round FAC1 (no check)
004987  1               LAB_2B2B:
004987  1  85 A3                STA     <FAC2_r         ; save FAC2 rounding byte
004989  1  20 AC 45             JSR     LAB_27AE        ; copy FAC1 to FAC2
00498C  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
00498E  1  C9 88                CMP     #$88            ; compare with EXP limit (256d)
004990  1  90 03                BCC     LAB_2B39        ; branch if less
004992  1               
004992  1               LAB_2B36:
004992  1  20 0D 44             JSR     LAB_2690        ; handle overflow and underflow
004995  1               LAB_2B39:
004995  1  20 C4 46             JSR     LAB_INT         ; perform INT
004998  1  A5 5B                LDA     <Temp3          ; get mantissa 3 from INT() function
00499A  1  18                   CLC                     ; clear carry for add
00499B  1  69 81                ADC     #$81            ; normalise +1
00499D  1  F0 F3                BEQ     LAB_2B36        ; if $00 go handle overflow
00499F  1               
00499F  1  38                   SEC                     ; set carry for subtract
0049A0  1  E9 01                SBC     #$01            ; now correct for exponent
0049A2  1  48                   PHA                     ; save FAC2 exponent
0049A3  1               
0049A3  1               ; swap FAC1 and FAC2
0049A3  1  A2 04                LDX     #$04            ; 4 bytes to do
0049A5  1               LAB_2B49:
0049A5  1  B5 B3                LDA     <FAC2_e,X       ; get FAC2,X
0049A7  1  B4 AC                LDY     <FAC1_e,X       ; get FAC1,X
0049A9  1  95 AC                STA     <FAC1_e,X       ; save FAC1,X
0049AB  1  94 B3                STY     <FAC2_e,X       ; save FAC2,X
0049AD  1  CA                   DEX                     ; decrement count/index
0049AE  1  10 F5                BPL     LAB_2B49        ; loop if not all done
0049B0  1               
0049B0  1  A5 A3                LDA     <FAC2_r         ; get FAC2 rounding byte
0049B2  1  85 B9                STA     <FAC1_r         ; save as FAC1 rounding byte
0049B4  1  20 8F 41             JSR     LAB_SUBTRACT    ; perform subtraction, FAC2 from FAC1
0049B7  1  20 6C 49             JSR     LAB_GTHAN       ; do - FAC1
0049BA  1  A9 43                LDA     #<LAB_2AFE      ; set counter pointer low byte
0049BC  1  A0 18                LDY     #>LAB_2AFE      ; set counter pointer high byte
0049BE  1  20 DF 49             JSR     LAB_2B84        ; go do series evaluation
0049C1  1  A9 00                LDA     #$00            ; clear A
0049C3  1  85 B8                STA     <FAC_sc         ; clear sign compare (FAC1 EOR FAC2)
0049C5  1  68                   PLA                     ;.get saved FAC2 exponent
0049C6  1  4C F2 43             JMP     LAB_2675        ; test and adjust accumulators and return
0049C9  1               
0049C9  1               ; ^2 then series evaluation
0049C9  1               
0049C9  1               LAB_2B6E:
0049C9  1  85 BA                STA     <Cptrl          ; save count pointer low byte
0049CB  1  84 BB                STY     <Cptrh          ; save count pointer high byte
0049CD  1  20 2C 45             JSR     LAB_276E        ; pack FAC1 into <Adatal
0049D0  1  A9 A4                LDA     #<Adatal        ; set pointer low byte (Y already $00)
0049D2  1  20 28 43             JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
0049D5  1  20 E3 49             JSR     LAB_2B88        ; go do series evaluation
0049D8  1  A9 A4                LDA     #<Adatal        ; pointer to original # low byte
0049DA  1  A0 00                LDY     #>Adatal        ; pointer to original # high byte
0049DC  1  4C 28 43             JMP     LAB_25FB        ; do convert AY, FCA1*(AY) and return
0049DF  1               
0049DF  1               ; series evaluation
0049DF  1               
0049DF  1               LAB_2B84:
0049DF  1  85 BA                STA     <Cptrl          ; save count pointer low byte
0049E1  1  84 BB                STY     <Cptrh          ; save count pointer high byte
0049E3  1               LAB_2B88:
0049E3  1  A2 A8                LDX     #<numexp        ; set pointer low byte
0049E5  1  20 2E 45             JSR     LAB_2770        ; set pointer high byte and pack FAC1 into <numexp
0049E8  1  8B DA A2 01          LDAINDIRECTY Cptrl      ; get constants count
0049EC  1  B5 BA C9 00  
0049F0  1  D0 04 A2 00  
0049FE  1  85 B1                STA     <numcon         ; save constants count
004A00  1  A4 BA                LDY     <Cptrl          ; get count pointer low byte
004A02  1  C8                   INY                     ; increment it (now constants pointer)
004A03  1  98                   TYA                     ; copy it
004A04  1  D0 02                BNE     LAB_2B97        ; skip next if no overflow
004A06  1               
004A06  1  E6 BB                INC     <Cptrh          ; else increment high byte
004A08  1               LAB_2B97:
004A08  1  85 BA                STA     <Cptrl          ; save low byte
004A0A  1  A4 BB                LDY     <Cptrh          ; get high byte
004A0C  1               LAB_2B9B:
004A0C  1  20 28 43             JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
004A0F  1  A5 BA                LDA     <Cptrl          ; get constants pointer low byte
004A11  1  A4 BB                LDY     <Cptrh          ; get constants pointer high byte
004A13  1  18                   CLC                     ; clear carry for add
004A14  1  69 04                ADC     #$04            ; +4 to  low pointer (4 bytes per constant)
004A16  1  90 01                BCC     LAB_2BA8        ; skip next if no overflow
004A18  1               
004A18  1  C8                   INY                     ; increment high byte
004A19  1               LAB_2BA8:
004A19  1  85 BA                STA     <Cptrl          ; save pointer low byte
004A1B  1  84 BB                STY     <Cptrh          ; save pointer high byte
004A1D  1  20 A7 41             JSR     LAB_246C        ; add (AY) to FAC1
004A20  1  A9 A8                LDA     #<numexp        ; set pointer low byte to partial @ <numexp
004A22  1  A0 00                LDY     #>numexp        ; set pointer high byte to partial @ <numexp
004A24  1  C6 B1                DEC     <numcon         ; decrement constants count
004A26  1  D0 E4                BNE     LAB_2B9B        ; loop until all done
004A28  1               
004A28  1  60                   RTS
004A29  1               
004A29  1               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
004A29  1               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
004A29  1               ; the Galois method and a sample of 65536 bytes produced gives the following values.
004A29  1               
004A29  1               ; Entropy = 7.997442 bits per byte
004A29  1               ; Optimum compression would reduce these 65536 bytes by 0 percent
004A29  1               
004A29  1               ; Chi square distribution for 65536 samples is 232.01, and
004A29  1               ; randomly would exceed this value 75.00 percent of the time
004A29  1               
004A29  1               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
004A29  1               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
004A29  1               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
004A29  1               
004A29  1               LAB_RND:
004A29  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
004A2B  1  F0 07                BEQ     NextPRN         ; do next random # if zero
004A2D  1               
004A2D  1               ; else get seed into random number store
004A2D  1  A2 E1                LDX     #<Rbyte4        ; set PRNG pointer low byte
004A2F  1  A0 00                LDY     #$00            ; set PRNG pointer high byte
004A31  1  20 36 45             JSR     LAB_2778        ; pack FAC1 into (XY)
004A34  1               NextPRN:
004A34  1  A2 AF                LDX     #$AF            ; set EOR byte
004A36  1  A0 13                LDY     #$13            ; do this nineteen times
004A38  1               LoopPRN:
004A38  1  06 E2                ASL     <Rbyte1         ; shift PRNG most significant byte
004A3A  1  26 E3                ROL     <Rbyte2         ; shift PRNG middle byte
004A3C  1  26 E4                ROL     <Rbyte3         ; shift PRNG least significant byte
004A3E  1  26 E1                ROL     <Rbyte4         ; shift PRNG extra byte
004A40  1  90 05                BCC     Ninc1           ; branch if bit 32 clear
004A42  1               
004A42  1  8A                   TXA                     ; set EOR byte
004A43  1  45 E2                EOR     <Rbyte1         ; EOR PRNG extra byte
004A45  1  85 E2                STA     <Rbyte1         ; save new PRNG extra byte
004A47  1               Ninc1:
004A47  1  88                   DEY                     ; decrement loop count
004A48  1  D0 EE                BNE     LoopPRN         ; loop if not all done
004A4A  1               
004A4A  1  A2 02                LDX     #$02            ; three bytes to copy
004A4C  1               CopyPRNG:
004A4C  1  B5 E2                LDA     <Rbyte1,X       ; get PRNG byte
004A4E  1  95 AD                STA     <FAC1_1,X       ; save FAC1 byte
004A50  1  CA                   DEX
004A51  1  10 F9                BPL     CopyPRNG        ; loop if not complete
004A53  1               
004A53  1  A9 80                LDA     #$80            ; set the exponent
004A55  1  85 AC                STA     <FAC1_e         ; save FAC1 exponent
004A57  1               
004A57  1  0A                   ASL     A               ; clear A
004A58  1  85 B0                STA     <FAC1_s         ; save FAC1 sign
004A5A  1               
004A5A  1  4C 23 42             JMP     LAB_24D5        ; normalise FAC1 and return
004A5D  1               
004A5D  1               ; perform COS()
004A5D  1               
004A5D  1               LAB_COS:
004A5D  1  A9 60                LDA     #<LAB_2C78      ; set (pi/2) pointer low byte
004A5F  1  A0 18                LDY     #>LAB_2C78      ; set (pi/2) pointer high byte
004A61  1  20 A7 41             JSR     LAB_246C        ; add (AY) to FAC1
004A64  1               
004A64  1               ; perform SIN()
004A64  1               
004A64  1               LAB_SIN:
004A64  1  20 A9 45             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
004A67  1  A9 75                LDA     #<LAB_2C7C      ; set (2*pi) pointer low byte
004A69  1  A0 18                LDY     #>LAB_2C7C      ; set (2*pi) pointer high byte
004A6B  1  A6 B7                LDX     <FAC2_s         ; get FAC2 sign (b7)
004A6D  1  20 38 44             JSR     LAB_26C2        ; divide by (AY) (X=sign)
004A70  1  20 A9 45             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
004A73  1  20 C4 46             JSR     LAB_INT         ; perform INT
004A76  1  A9 00                LDA     #$00            ; clear byte
004A78  1  85 B8                STA     <FAC_sc         ; clear sign compare (FAC1 EOR FAC2)
004A7A  1  20 8F 41             JSR     LAB_SUBTRACT    ; perform subtraction, FAC2 from FAC1
004A7D  1  A9 A7                LDA     #<LAB_2C80      ; set 0.25 pointer low byte
004A7F  1  A0 18                LDY     #>LAB_2C80      ; set 0.25 pointer high byte
004A81  1  20 8C 41             JSR     LAB_2455        ; perform subtraction, (AY) from FAC1
004A84  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
004A86  1  48                   PHA                     ; save FAC1 sign
004A87  1  10 0D                BPL     LAB_2C35        ; branch if +ve
004A89  1               
004A89  1               ; FAC1 sign was -ve
004A89  1  20 A3 41             JSR     LAB_244E        ; add 0.5 to FAC1
004A8C  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
004A8E  1  30 09                BMI     LAB_2C38        ; branch if -ve
004A90  1               
004A90  1  A5 63                LDA     <Cflag          ; get comparison evaluation flag
004A92  1  49 FF                EOR     #$FF            ; toggle flag
004A94  1  85 63                STA     <Cflag          ; save comparison evaluation flag
004A96  1               LAB_2C35:
004A96  1  20 6C 49             JSR     LAB_GTHAN       ; do - FAC1
004A99  1               LAB_2C38:
004A99  1  A9 A7                LDA     #<LAB_2C80      ; set 0.25 pointer low byte
004A9B  1  A0 18                LDY     #>LAB_2C80      ; set 0.25 pointer high byte
004A9D  1  20 A7 41             JSR     LAB_246C        ; add (AY) to FAC1
004AA0  1  68                   PLA                     ; restore FAC1 sign
004AA1  1  10 03                BPL     LAB_2C45        ; branch if was +ve
004AA3  1               
004AA3  1               ; else correct FAC1
004AA3  1  20 6C 49             JSR     LAB_GTHAN       ; do - FAC1
004AA6  1               LAB_2C45:
004AA6  1  A9 64                LDA     #<LAB_2C84      ; set pointer low byte to counter
004AA8  1  A0 18                LDY     #>LAB_2C84      ; set pointer high byte to counter
004AAA  1  4C C9 49             JMP     LAB_2B6E        ; ^2 then series evaluation and return
004AAD  1               
004AAD  1               ; perform TAN()
004AAD  1               
004AAD  1               LAB_TAN:
004AAD  1  20 2C 45             JSR     LAB_276E        ; pack FAC1 into <Adatal
004AB0  1  A9 00                LDA     #$00            ; clear byte
004AB2  1  85 63                STA     <Cflag          ; clear comparison evaluation flag
004AB4  1  20 64 4A             JSR     LAB_SIN         ; go do SIN(n)
004AB7  1  A2 9C                LDX     #<func_l        ; set sin(n) pointer low byte
004AB9  1  A0 00                LDY     #>func_l        ; set sin(n) pointer high byte
004ABB  1  20 36 45             JSR     LAB_2778        ; pack FAC1 into (XY)
004ABE  1  A9 A4                LDA     #<Adatal        ; set n pointer low addr
004AC0  1  A0 00                LDY     #>Adatal        ; set n pointer high addr
004AC2  1  20 BC 44             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
004AC5  1  A9 00                LDA     #$00            ; clear byte
004AC7  1  85 B0                STA     <FAC1_s         ; clear FAC1 sign (b7)
004AC9  1  A5 63                LDA     <Cflag          ; get comparison evaluation flag
004ACB  1  20 D5 4A             JSR     LAB_2C74        ; save flag and go do series evaluation
004ACE  1               
004ACE  1  A9 9C                LDA     #<func_l        ; set sin(n) pointer low byte
004AD0  1  A0 00                LDY     #>func_l        ; set sin(n) pointer high byte
004AD2  1  4C 40 44             JMP     LAB_26CA        ; convert AY and do (AY)/FAC1
004AD5  1               
004AD5  1               LAB_2C74:
004AD5  1  48                   PHA                     ; save comparison evaluation flag
004AD6  1  4C 96 4A             JMP     LAB_2C35        ; go do series evaluation
004AD9  1               
004AD9  1               ; perform USR()
004AD9  1               
004AD9  1               LAB_USR:
004AD9  1  20 0A 00             JSR     Usrjmp          ; call user code
004ADC  1  4C 53 34             JMP     LAB_1BFB        ; scan for ")", else do syntax error then warm start
004ADF  1               
004ADF  1               ; perform ATN()
004ADF  1               
004ADF  1               LAB_ATN:
004ADF  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign (b7)
004AE1  1  48                   PHA                     ; save sign
004AE2  1  10 03                BPL     LAB_2CA1        ; branch if +ve
004AE4  1               
004AE4  1  20 6C 49             JSR     LAB_GTHAN       ; else do - FAC1
004AE7  1               LAB_2CA1:
004AE7  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
004AE9  1  48                   PHA                     ; push exponent
004AEA  1  C9 81                CMP     #$81            ; compare with 1
004AEC  1  90 07                BCC     LAB_2CAF        ; branch if FAC1<1
004AEE  1               
004AEE  1  A9 9A                LDA     #<LAB_259C      ; set 1 pointer low byte
004AF0  1  A0 18                LDY     #>LAB_259C      ; set 1 pointer high byte
004AF2  1  20 40 44             JSR     LAB_26CA        ; convert AY and do (AY)/FAC1
004AF5  1               LAB_2CAF:
004AF5  1  A9 79                LDA     #<LAB_2CC9      ; set pointer low byte to counter
004AF7  1  A0 18                LDY     #>LAB_2CC9      ; set pointer high byte to counter
004AF9  1  20 C9 49             JSR     LAB_2B6E        ; ^2 then series evaluation
004AFC  1  68                   PLA                     ; restore old FAC1 exponent
004AFD  1  C9 81                CMP     #$81            ; compare with 1
004AFF  1  90 07                BCC     LAB_2CC2        ; branch if FAC1<1
004B01  1               
004B01  1  A9 60                LDA     #<LAB_2C78      ; set (pi/2) pointer low byte
004B03  1  A0 18                LDY     #>LAB_2C78      ; set (pi/2) pointer high byte
004B05  1  20 8C 41             JSR     LAB_2455        ; perform subtraction, (AY) from FAC1
004B08  1               LAB_2CC2:
004B08  1  68                   PLA                     ; restore FAC1 sign
004B09  1  10 16                BPL     LAB_2D04        ; exit if was +ve
004B0B  1               
004B0B  1  4C 6C 49             JMP     LAB_GTHAN       ; else do - FAC1 and return
004B0E  1               
004B0E  1               ; perform BITSET
004B0E  1               
004B0E  1               LAB_BITSET:
004B0E  1  20 69 40             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
004B11  1  E0 08                CPX     #$08            ; only 0 to 7 are allowed
004B13  1  B0 20                BCS     FCError         ; branch if > 7
004B15  1               
004B15  1  A9 00                LDA     #$00            ; clear A
004B17  1  38                   SEC                     ; set the carry
004B18  1               S_Bits:
004B18  1  2A                   ROL     A               ; shift bit
004B19  1  CA                   DEX                     ; decrement bit number
004B1A  1  10 FC                BPL     S_Bits          ; loop if still +ve
004B1C  1               
004B1C  1  E8                   INX                     ; make X = $00
004B1D  1  01 11                ORA     (<Itempl,X)     ; or with byte via temporary integer (addr)
004B1F  1  81 11                STA     (<Itempl,X)     ; save byte via temporary integer (addr)
004B21  1               LAB_2D04:
004B21  1  60                   RTS
004B22  1               
004B22  1               ; perform BITCLR
004B22  1               
004B22  1               LAB_BITCLR:
004B22  1  20 69 40             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
004B25  1  E0 08                CPX     #$08            ; only 0 to 7 are allowed
004B27  1  B0 0C                BCS     FCError         ; branch if > 7
004B29  1               
004B29  1  A9 FF                LDA     #$FF            ; set A
004B2B  1               S_Bitc:
004B2B  1  2A                   ROL     A               ; shift bit
004B2C  1  CA                   DEX                     ; decrement bit number
004B2D  1  10 FC                BPL     S_Bitc          ; loop if still +ve
004B2F  1               
004B2F  1  E8                   INX                     ; make X = $00
004B30  1  21 11                AND     (<Itempl,X)     ; and with byte via temporary integer (addr)
004B32  1  81 11                STA     (<Itempl,X)     ; save byte via temporary integer (addr)
004B34  1  60                   RTS
004B35  1               
004B35  1               FCError:
004B35  1  4C C7 37             JMP     LAB_FCER        ; do function call error then warm start
004B38  1               
004B38  1               ; perform BITTST()
004B38  1               
004B38  1               LAB_BTST:
004B38  1  22 BC 00 00          JSL     LAB_IGBY        ; increment BASIC pointer
004B3C  1  20 69 40             JSR     LAB_GADB        ; get two parameters for POKE or WAIT
004B3F  1  E0 08                CPX     #$08            ; only 0 to 7 are allowed
004B41  1  B0 F2                BCS     FCError         ; branch if > 7
004B43  1               
004B43  1  22 C2 00 00          JSL     LAB_GBYT        ; get next BASIC byte
004B47  1  C9 29                CMP     #')'            ; is next character ")"
004B49  1  F0 03                BEQ     TST_OK          ; if ")" go do rest of function
004B4B  1               
004B4B  1  4C 68 34             JMP     LAB_SNER        ; do syntax error then warm start
004B4E  1               
004B4E  1               TST_OK:
004B4E  1  22 BC 00 00          JSL     LAB_IGBY        ; update BASIC execute pointer (to character past ")")
004B52  1  A9 00                LDA     #$00            ; clear A
004B54  1  38                   SEC                     ; set the carry
004B55  1               T_Bits:
004B55  1  2A                   ROL     A               ; shift bit
004B56  1  CA                   DEX                     ; decrement bit number
004B57  1  10 FC                BPL     T_Bits          ; loop if still +ve
004B59  1               
004B59  1  E8                   INX                     ; make X = $00
004B5A  1  21 11                AND     (<Itempl,X)     ; AND with byte via temporary integer (addr)
004B5C  1  F0 02                BEQ     LAB_NOTT        ; branch if zero (already correct)
004B5E  1               
004B5E  1  A9 FF                LDA     #$FF            ; set for -1 result
004B60  1               LAB_NOTT:
004B60  1  4C D9 45             JMP     LAB_27DB        ; go do SGN tail
004B63  1               
004B63  1               ; perform BIN$()
004B63  1               
004B63  1               LAB_BINS:
004B63  1  E0 19                CPX     #$19            ; max + 1
004B65  1  B0 71                BCS     BinFErr         ; exit if too big ( > or = )
004B67  1               
004B67  1  86 78                STX     <TempB          ; save # of characters ($00 = leading zero remove)
004B69  1  A9 18                LDA     #$18            ; need A byte long space
004B6B  1  20 6E 3A             JSR     LAB_MSSP        ; make string space A bytes long
004B6E  1  A0 17                LDY     #$17            ; set index
004B70  1  A2 18                LDX     #$18            ; character count
004B72  1               NextB1:
004B72  1  46 11                LSR     <nums_1         ; shift highest byte
004B74  1  66 12                ROR     <nums_2         ; shift middle byte
004B76  1  66 13                ROR     <nums_3         ; shift lowest byte bit 0 to carry
004B78  1  8A                   TXA                     ; load with "0"/2
004B79  1  2A                   ROL     A               ; shift in carry
004B7A  1  8B DA 48 A2          STAINDIRECTY str_pl     ; save to temp string + index
004B7E  1  01 B5 AD C9  
004B82  1  00 D0 04 A2  
004B90  1  88                   DEY                     ; decrement index
004B91  1  10 DF                BPL     NextB1          ; loop if not done
004B93  1               
004B93  1  A5 78                LDA     <TempB          ; get # of characters
004B95  1  F0 0A                BEQ     EndBHS          ; branch if truncate
004B97  1               
004B97  1  AA                   TAX                     ; copy length to X
004B98  1  38                   SEC                     ; set carry for add !
004B99  1  49 FF                EOR     #$FF            ; 1's complement
004B9B  1  69 18                ADC     #$18            ; add 24d
004B9D  1  F0 30                BEQ     GoPr2           ; if zero print whole string
004B9F  1               
004B9F  1  D0 23                BNE     GoPr1           ; else go make output string
004BA1  1               
004BA1  1               ; this is the exit code and is also used by HEX$()
004BA1  1               ; truncate string to remove leading "0"s
004BA1  1               
004BA1  1               EndBHS:
004BA1  1  A8                   TAY                     ; clear index (A=0, X=length here)
004BA2  1               NextB2:
004BA2  1  8B DA A2 01          LDAINDIRECTY str_pl     ; get character from string
004BA6  1  B5 AD C9 00  
004BAA  1  D0 04 A2 00  
004BB8  1  C9 30                CMP     #'0'            ; compare with "0"
004BBA  1  D0 07                BNE     GoPr            ; if not "0" then go print string from here
004BBC  1               
004BBC  1  CA                   DEX                     ; decrement character count
004BBD  1  F0 03                BEQ     GoPr3           ; if zero then end of string so go print it
004BBF  1               
004BBF  1  C8                   INY                     ; else increment index
004BC0  1  10 E0                BPL     NextB2          ; loop always
004BC2  1               
004BC2  1               ; make fixed length output string - ignore overflows!
004BC2  1               
004BC2  1               GoPr3:
004BC2  1  E8                   INX                     ; need at least 1 character
004BC3  1               GoPr:
004BC3  1  98                   TYA                     ; copy result
004BC4  1               GoPr1:
004BC4  1  18                   CLC                     ; clear carry for add
004BC5  1  65 AD                ADC     <str_pl         ; add low address
004BC7  1  85 AD                STA     <str_pl         ; save low address
004BC9  1  A9 00                LDA     #$00            ; do high byte
004BCB  1  65 AE                ADC     <str_ph         ; add high address
004BCD  1  85 AE                STA     <str_ph         ; save high address
004BCF  1               GoPr2:
004BCF  1  86 AC                STX     <str_ln         ; X holds string length
004BD1  1  22 BC 00 00          JSL     LAB_IGBY        ; update BASIC execute pointer (to character past ")")
004BD5  1  4C D1 3A             JMP     LAB_RTST        ; check for space on descriptor stack then put address
004BD8  1               ; and length on descriptor stack and update stack pointers
004BD8  1               
004BD8  1               BinFErr:
004BD8  1  4C C7 37             JMP     LAB_FCER        ; do function call error then warm start
004BDB  1               
004BDB  1               ; perform HEX$()
004BDB  1               
004BDB  1               LAB_HEXS:
004BDB  1  E0 07                CPX     #$07            ; max + 1
004BDD  1  B0 F9                BCS     BinFErr         ; exit if too big ( > or = )
004BDF  1               
004BDF  1  86 78                STX     <TempB          ; save # of characters
004BE1  1               
004BE1  1  A9 06                LDA     #$06            ; need 6 bytes for string
004BE3  1  20 6E 3A             JSR     LAB_MSSP        ; make string space A bytes long
004BE6  1  A0 05                LDY     #$05            ; set string index
004BE8  1               
004BE8  1  F8                   SED                     ; need decimal mode for nibble convert
004BE9  1  A5 13                LDA     <nums_3         ; get lowest byte
004BEB  1  20 09 4C             JSR     LAB_A2HX        ; convert A to ASCII hex byte and output
004BEE  1  A5 12                LDA     <nums_2         ; get middle byte
004BF0  1  20 09 4C             JSR     LAB_A2HX        ; convert A to ASCII hex byte and output
004BF3  1  A5 11                LDA     <nums_1         ; get highest byte
004BF5  1  20 09 4C             JSR     LAB_A2HX        ; convert A to ASCII hex byte and output
004BF8  1  D8                   CLD                     ; back to binary
004BF9  1               
004BF9  1  A2 06                LDX     #$06            ; character count
004BFB  1  A5 78                LDA     <TempB          ; get # of characters
004BFD  1  F0 A2                BEQ     EndBHS          ; branch if truncate
004BFF  1               
004BFF  1  AA                   TAX                     ; copy length to X
004C00  1  38                   SEC                     ; set carry for add !
004C01  1  49 FF                EOR     #$FF            ; 1's complement
004C03  1  69 06                ADC     #$06            ; add 6d
004C05  1  F0 C8                BEQ     GoPr2           ; if zero print whole string
004C07  1               
004C07  1  D0 BB                BNE     GoPr1           ; else go make output string (branch always)
004C09  1               
004C09  1               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
004C09  1               
004C09  1               LAB_A2HX:
004C09  1  AA                   TAX                     ; save byte
004C0A  1  29 0F                AND     #$0F            ; mask off top bits
004C0C  1  20 14 4C             JSR     LAB_AL2X        ; convert low nibble to ASCII and output
004C0F  1  8A                   TXA                     ; get byte back
004C10  1  4A                   LSR     A               ; /2	shift high nibble to low nibble
004C11  1  4A                   LSR     A               ; /4
004C12  1  4A                   LSR     A               ; /8
004C13  1  4A                   LSR     A               ; /16
004C14  1               LAB_AL2X:
004C14  1  C9 0A                CMP     #$0A            ; set carry for +1 if >9
004C16  1  69 30                ADC     #'0'            ; add ASCII "0"
004C18  1  8B DA 48 A2          STAINDIRECTY str_pl     ; save to temp string
004C1C  1  01 B5 AD C9  
004C20  1  00 D0 04 A2  
004C2E  1  88                   DEY                     ; decrement counter
004C2F  1  60                   RTS
004C30  1               
004C30  1               LAB_NLTO:
004C30  1  85 AC                STA     <FAC1_e         ; save FAC1 exponent
004C32  1  A9 00                LDA     #$00            ; clear sign compare
004C34  1               LAB_MLTE:
004C34  1  85 B8                STA     <FAC_sc         ; save sign compare (FAC1 EOR FAC2)
004C36  1  8A                   TXA                     ; restore character
004C37  1  20 8F 47             JSR     LAB_2912        ; evaluate new ASCII digit
004C3A  1               
004C3A  1               ; gets here if the first character was "$" for hex
004C3A  1               ; get hex number
004C3A  1               
004C3A  1               LAB_CHEX:
004C3A  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
004C3E  1  90 0A                BCC     LAB_ISHN        ; branch if numeric character
004C40  1               
004C40  1  09 20                ORA     #$20            ; case convert, allow "A" to "F" and "a" to "f"
004C42  1  E9 61                SBC     #'a'            ; subtract "a" (carry set here)
004C44  1  C9 06                CMP     #$06            ; compare normalised with $06 (max+1)
004C46  1  B0 2B                BCS     LAB_EXCH        ; exit if >"f" or <"0"
004C48  1               
004C48  1  69 0A                ADC     #$0A            ; convert to nibble
004C4A  1               LAB_ISHN:
004C4A  1  29 0F                AND     #$0F            ; convert to binary
004C4C  1  AA                   TAX                     ; save nibble
004C4D  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
004C4F  1  F0 E3                BEQ     LAB_MLTE        ; skip multiply if zero
004C51  1               
004C51  1  69 04                ADC     #$04            ; add four to exponent (*16 - carry clear here)
004C53  1  90 DB                BCC     LAB_NLTO        ; if no overflow do evaluate digit
004C55  1               
004C55  1               LAB_MLTO:
004C55  1  4C B2 42             JMP     LAB_2564        ; do overflow error and warm start
004C58  1               
004C58  1               LAB_NXCH:
004C58  1  AA                   TAX                     ; save bit
004C59  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
004C5B  1  F0 06                BEQ     LAB_MLBT        ; skip multiply if zero
004C5D  1               
004C5D  1  E6 AC                INC     <FAC1_e         ; increment FAC1 exponent (*2)
004C5F  1  F0 F4                BEQ     LAB_MLTO        ; do overflow error if = $00
004C61  1               
004C61  1  A9 00                LDA     #$00            ; clear sign compare
004C63  1               LAB_MLBT:
004C63  1  85 B8                STA     <FAC_sc         ; save sign compare (FAC1 EOR FAC2)
004C65  1  8A                   TXA                     ; restore bit
004C66  1  20 8F 47             JSR     LAB_2912        ; evaluate new ASCII digit
004C69  1               
004C69  1               ; gets here if the first character was  "%" for binary
004C69  1               ; get binary number
004C69  1               
004C69  1               LAB_CBIN:
004C69  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
004C6D  1  49 30                EOR     #'0'            ; convert "0" to 0 etc.
004C6F  1  C9 02                CMP     #$02            ; compare with max+1
004C71  1  90 E5                BCC     LAB_NXCH        ; branch exit if < 2
004C73  1               
004C73  1               LAB_EXCH:
004C73  1  4C 74 47             JMP     LAB_28F6        ; evaluate -ve flag and return
004C76  1               
004C76  1               ; ctrl-c check routine. .includes limited "life" byte save for INGET routine
004C76  1               ; now also the code that checks to see if an interrupt has occurred
004C76  1               
004C76  1               CTRLC:
004C76  1  A5 02                LDA     >ccflag         ; get [CTRL-C] check flag
004C78  1  D0 17                BNE     LAB_FBA2        ; exit if inhibited
004C7A  1               
004C7A  1  20 C1 18             JSR     V_INPT          ; scan input device
004C7D  1  B0 0B                BCS     LAB_FBA0        ; exit if buffer empty
004C7F  1               
004C7F  1  85 02                STA     >ccbyte         ; save received byte
004C81  1  A9 20                LDA     #$20            ; "life" timer for bytes
004C83  1  85 02                STA     >ccnull         ; set countdown
004C85  1  A5 02                LDA     >ccbyte
004C87  1  4C 19 2C             JMP     LAB_1636        ; return to BASIC
004C8A  1               
004C8A  1               LAB_FBA0:
004C8A  1  A5 02                LDA     >ccnull         ; get countdown byte
004C8C  1  F0 03                BEQ     LAB_FBA2        ; exit if finished
004C8E  1  3A                   DEC     A
004C8F  1  85 02                STA     >ccnull         ; else decrement countdown
004C91  1               LAB_FBA2:
004C91  1  A2 E5                LDX     #<NmiBase       ; set pointer to NMI values
004C93  1  20 9E 4C             JSR     LAB_CKIN        ; go check interrupt
004C96  1  A2 E8                LDX     #<IrqBase       ; set pointer to IRQ values
004C98  1  20 9E 4C             JSR     LAB_CKIN        ; go check interrupt
004C9B  1  A5 02                LDA     >ccbyte
004C9D  1               LAB_CRTS:
004C9D  1  60                   RTS
004C9E  1               
004C9E  1               ; check whichever interrupt is indexed by X
004C9E  1               
004C9E  1               LAB_CKIN:
004C9E  1  B5 00                LDA     <PLUS_0,X       ; get interrupt flag byte
004CA0  1  10 FB                BPL     LAB_CRTS        ; branch if interrupt not enabled
004CA2  1               
004CA2  1               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
004CA2  1               ; automatically enable the interrupt when we exit
004CA2  1               
004CA2  1  0A                   ASL     A               ; move happened bit to setup bit
004CA3  1  29 40                AND     #$40            ; mask happened bits
004CA5  1  F0 F6                BEQ     LAB_CRTS        ; if no interrupt then exit
004CA7  1               
004CA7  1  95 00                STA     <PLUS_0,X       ; save interrupt flag byte
004CA9  1               
004CA9  1  8A                   TXA                     ; copy index ..
004CAA  1  A8                   TAY                     ; .. to Y
004CAB  1               
004CAB  1  68                   PLA                     ; dump return address low byte, call from CTRL-C
004CAC  1  68                   PLA                     ; dump return address high byte
004CAD  1               
004CAD  1  A9 05                LDA     #$05            ; need 5 bytes for GOSUB
004CAF  1  20 BF 27             JSR     LAB_1212        ; check room on stack for A bytes
004CB2  1  A5 C4                LDA     <Bpntrh         ; get BASIC execute pointer high byte
004CB4  1  48                   PHA                     ; push on stack
004CB5  1  A5 C3                LDA     <Bpntrl         ; get BASIC execute pointer low byte
004CB7  1  48                   PHA                     ; push on stack
004CB8  1  A5 88                LDA     <Clineh         ; get current line high byte
004CBA  1  48                   PHA                     ; push on stack
004CBB  1  A5 87                LDA     <Clinel         ; get current line low byte
004CBD  1  48                   PHA                     ; push on stack
004CBE  1  A9 8F                LDA     #TK_GOSUB       ; token for GOSUB
004CC0  1  48                   PHA                     ; push on stack
004CC1  1  DA                   PHX
004CC2  1  BB                   TYX
004CC3  1  B5 01                LDA     <PLUS_1,X       ; get interrupt code pointer low byte
004CC5  1  85 C3                STA     <Bpntrl         ; save as BASIC execute pointer low byte
004CC7  1  B5 02                LDA     <PLUS_2,X       ; get interrupt code pointer high byte
004CC9  1  85 C4                STA     <Bpntrh         ; save as BASIC execute pointer high byte
004CCB  1  FA                   PLX
004CCC  1  4C BB 2B             JMP     LAB_15C2        ; go do interpreter inner loop
004CCF  1               ; can't RTS, we used the stack! the RTS from the ctrl-c
004CCF  1               ; check will be taken when the RETIRQ/RETNMI/RETURN is
004CCF  1               ; executed at the end of the subroutine
004CCF  1               
004CCF  1               ; get byte from input device, no waiting
004CCF  1               ; returns with carry set if byte in A
004CCF  1               
004CCF  1               INGET:
004CCF  1  20 C1 18             JSR     V_INPT          ; call scan input device
004CD2  1  90 07                BCC     LAB_FB95        ; if byte go reset timer
004CD4  1               
004CD4  1  A5 02                LDA     >ccnull         ; get countdown
004CD6  1  F0 09                BEQ     LAB_FB96        ; exit if empty
004CD8  1               
004CD8  1  A5 02                LDA     >ccbyte         ; get last received byte
004CDA  1  38                   SEC                     ; flag we got a byte
004CDB  1               LAB_FB95:
004CDB  1  A9 00                LDA     #$00            ; clear X
004CDD  1  85 02                STA     >ccnull         ; clear timer because we got a byte
004CDF  1  A5 02                LDA     >ccbyte         ; get last received byte
004CE1  1               LAB_FB96:
004CE1  1  60                   RTS
004CE2  1               
004CE2  1               ; these routines only enable the interrupts if the set-up flag is set
004CE2  1               ; if not they have no effect
004CE2  1               
004CE2  1               ; perform IRQ {ON|OFF|CLEAR}
004CE2  1               
004CE2  1               LAB_IRQ:
004CE2  1  A2 E8                LDX     #<IrqBase       ; set pointer to IRQ values
004CE4  1  2C                   .BYTE   $2C             ; make next line BIT abs.
004CE5  1               
004CE5  1               ; perform NMI {ON|OFF|CLEAR}
004CE5  1               
004CE5  1               LAB_NMI:
004CE5  1  A2 E5                LDX     #<NmiBase       ; set pointer to NMI values
004CE7  1  C9 93                CMP     #TK_ON          ; compare with token for ON
004CE9  1  F0 11                BEQ     LAB_INON        ; go turn on interrupt
004CEB  1               
004CEB  1  C9 CA                CMP     #TK_OFF         ; compare with token for OFF
004CED  1  F0 07                BEQ     LAB_IOFF        ; go turn off interrupt
004CEF  1               
004CEF  1  49 A1                EOR     #TK_CLEAR       ; compare with token for CLEAR, A = $00 if = TK_CLEAR
004CF1  1  F0 0E                BEQ     LAB_INEX        ; go clear interrupt flags and return
004CF3  1               
004CF3  1  4C 68 34             JMP     LAB_SNER        ; do syntax error then warm start
004CF6  1               
004CF6  1               LAB_IOFF:
004CF6  1  A9 7F                LDA     #$7F            ; clear A
004CF8  1  35 00                AND     <PLUS_0,X       ; AND with interrupt setup flag
004CFA  1  10 05                BPL     LAB_INEX        ; go clear interrupt enabled flag and return
004CFC  1               
004CFC  1               LAB_INON:
004CFC  1  B5 00                LDA     <PLUS_0,X       ; get interrupt setup flag
004CFE  1  0A                   ASL     A               ; Shift bit to enabled flag
004CFF  1  15 00                ORA     <PLUS_0,X       ; OR with flag byte
004D01  1               LAB_INEX:
004D01  1  95 00                STA     <PLUS_0,X       ; save interrupt flag byte
004D03  1  22 BC 00 00          JSL     LAB_IGBY        ; update BASIC execute pointer and return
004D07  1  60                   RTS
004D08  1               ; these routines set up the pointers and flags for the interrupt routines
004D08  1               ; note that the interrupts are also enabled by these commands
004D08  1               
004D08  1               
004D08  1               ; MAX() MIN() pre process
004D08  1               
004D08  1               LAB_MMPP:
004D08  1  20 4A 33             JSR     LAB_EVEZ        ; process expression
004D0B  1  4C 31 33             JMP     LAB_CTNM        ; check if source is numeric, else do type mismatch
004D0E  1               
004D0E  1               ; perform MAX()
004D0E  1               
004D0E  1               LAB_MAX:
004D0E  1  20 3E 4D             JSR     LAB_PHFA        ; push FAC1, evaluate expression,
004D11  1               ; pull FAC2 and compare with FAC1
004D11  1  10 FB                BPL     LAB_MAX         ; branch if no swap to do
004D13  1               
004D13  1  A5 B4                LDA     <FAC2_1         ; get FAC2 mantissa1
004D15  1  09 80                ORA     #$80            ; set top bit (clear sign from compare)
004D17  1  85 B4                STA     <FAC2_1         ; save FAC2 mantissa1
004D19  1  20 AC 41             JSR     LAB_279B        ; copy FAC2 to FAC1
004D1C  1  F0 F0                BEQ     LAB_MAX         ; go do next (branch always)
004D1E  1               
004D1E  1               ; perform MIN()
004D1E  1               
004D1E  1               LAB_MIN:
004D1E  1  20 3E 4D             JSR     LAB_PHFA        ; push FAC1, evaluate expression,
004D21  1               ; pull FAC2 and compare with FAC1
004D21  1  30 FB                BMI     LAB_MIN         ; branch if no swap to do
004D23  1               
004D23  1  F0 F9                BEQ     LAB_MIN         ; branch if no swap to do
004D25  1               
004D25  1  A5 B4                LDA     <FAC2_1         ; get FAC2 mantissa1
004D27  1  09 80                ORA     #$80            ; set top bit (clear sign from compare)
004D29  1  85 B4                STA     <FAC2_1         ; save FAC2 mantissa1
004D2B  1  20 AC 41             JSR     LAB_279B        ; copy FAC2 to FAC1
004D2E  1  F0 EE                BEQ     LAB_MIN         ; go do next (branch always)
004D30  1               
004D30  1               ; exit routine. don't bother returning to the loop code
004D30  1               ; check for correct exit, else so syntax error
004D30  1               
004D30  1               LAB_MMEC:
004D30  1  C9 29                CMP     #')'            ; is it end of function?
004D32  1  D0 07                BNE     LAB_MMSE        ; if not do MAX MIN syntax error
004D34  1               
004D34  1  68                   PLA                     ; dump return address low byte
004D35  1  68                   PLA                     ; dump return address high byte
004D36  1  22 BC 00 00          JSL     LAB_IGBY        ; update BASIC execute pointer (to chr past ")")
004D3A  1  60                   RTS
004D3B  1               LAB_MMSE:
004D3B  1  4C 68 34             JMP     LAB_SNER        ; do syntax error then warm start
004D3E  1               
004D3E  1               ; check for next, evaluate and return or exit
004D3E  1               ; this is the routine that does most of the work
004D3E  1               
004D3E  1               LAB_PHFA:
004D3E  1  22 C2 00 00          JSL     LAB_GBYT        ; get next BASIC byte
004D42  1  C9 2C                CMP     #','            ; is there more ?
004D44  1  D0 EA                BNE     LAB_MMEC        ; if not go do end check
004D46  1               
004D46  1               ; push FAC1
004D46  1  20 B8 45             JSR     LAB_27BA        ; round FAC1
004D49  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign
004D4B  1  09 7F                ORA     #$7F            ; set all non sign bits
004D4D  1  25 AD                AND     <FAC1_1         ; AND FAC1 mantissa1 (AND in sign bit)
004D4F  1  48                   PHA                     ; push on stack
004D50  1  A5 AE                LDA     <FAC1_2         ; get FAC1 mantissa2
004D52  1  48                   PHA                     ; push on stack
004D53  1  A5 AF                LDA     <FAC1_3         ; get FAC1 mantissa3
004D55  1  48                   PHA                     ; push on stack
004D56  1  A5 AC                LDA     <FAC1_e         ; get FAC1 exponent
004D58  1  48                   PHA                     ; push on stack
004D59  1               
004D59  1  22 BC 00 00          JSL     LAB_IGBY        ; scan and get next BASIC byte (after ",")
004D5D  1  20 2E 33             JSR     LAB_EVNM        ; evaluate expression and check is numeric,
004D60  1               ; else do type mismatch
004D60  1               
004D60  1               ; pop FAC2 (MAX/MIN expression so far)
004D60  1  68                   PLA                     ; pop exponent
004D61  1  85 B3                STA     <FAC2_e         ; save FAC2 exponent
004D63  1  68                   PLA                     ; pop mantissa3
004D64  1  85 B6                STA     <FAC2_3         ; save FAC2 mantissa3
004D66  1  68                   PLA                     ; pop mantissa1
004D67  1  85 B5                STA     <FAC2_2         ; save FAC2 mantissa2
004D69  1  68                   PLA                     ; pop sign/mantissa1
004D6A  1  85 B4                STA     <FAC2_1         ; save FAC2 sign/mantissa1
004D6C  1  85 B7                STA     <FAC2_s         ; save FAC2 sign
004D6E  1               
004D6E  1               ; compare FAC1 with (packed) FAC2
004D6E  1  A9 B3                LDA     #<FAC2_e        ; set pointer low byte to FAC2
004D70  1  A0 00                LDY     #>FAC2_e        ; set pointer high byte to FAC2
004D72  1  4C F6 45             JMP     LAB_27F8        ; compare FAC1 with FAC2 (AY) and return
004D75  1               ; returns A=$00 if FAC1 = (AY)
004D75  1               ; returns A=$01 if FAC1 > (AY)
004D75  1               ; returns A=$FF if FAC1 < (AY)
004D75  1               
004D75  1               ; perform WIDTH
004D75  1               
004D75  1               LAB_WDTH:
004D75  1  C9 2C                CMP     #','            ; is next byte ","
004D77  1  F0 1C                BEQ     LAB_TBSZ        ; if so do tab size
004D79  1               
004D79  1  20 DE 3F             JSR     LAB_GTBY        ; get byte parameter
004D7C  1  8A                   TXA                     ; copy width to A
004D7D  1  F0 0A                BEQ     LAB_NSTT        ; branch if set for infinite line
004D7F  1               
004D7F  1  E0 10                CPX     #$10            ; else make min width = 16d
004D81  1  90 46                BCC     TabErr          ; if less do function call error and exit
004D83  1               
004D83  1               ; this next compare ensures that we can't exit WIDTH via an error leaving the
004D83  1               ; tab size greater than the line length.
004D83  1               
004D83  1  E4 64                CPX     <TabSiz         ; compare with tab size
004D85  1  B0 02                BCS     LAB_NSTT        ; branch if >= tab size
004D87  1               
004D87  1  86 64                STX     <TabSiz         ; else make tab size = terminal width
004D89  1               LAB_NSTT:
004D89  1  86 0F                STX     <TWidth         ; set the terminal width
004D8B  1  22 C2 00 00          JSL     LAB_GBYT        ; get BASIC byte back
004D8F  1  F0 1A                BEQ     WExit           ; exit if no following
004D91  1               
004D91  1  C9 2C                CMP     #','            ; else is it ","
004D93  1  D0 A6                BNE     LAB_MMSE        ; if not do syntax error
004D95  1               
004D95  1               LAB_TBSZ:
004D95  1  20 DA 3F             JSR     LAB_SGBY        ; scan and get byte parameter
004D98  1  8A                   TXA                     ; copy TAB size
004D99  1  30 2E                BMI     TabErr          ; if >127 do function call error and exit
004D9B  1               
004D9B  1  E0 01                CPX     #$01            ; compare with min-1
004D9D  1  90 2A                BCC     TabErr          ; if <=1 do function call error and exit
004D9F  1               
004D9F  1  A5 0F                LDA     <TWidth         ; set flags for width
004DA1  1  F0 06                BEQ     LAB_SVTB        ; skip check if infinite line
004DA3  1               
004DA3  1  E4 0F                CPX     <TWidth         ; compare TAB with width
004DA5  1  F0 02                BEQ     LAB_SVTB        ; ok if =
004DA7  1               
004DA7  1  B0 20                BCS     TabErr          ; branch if too big
004DA9  1               
004DA9  1               LAB_SVTB:
004DA9  1  86 64                STX     <TabSiz         ; save TAB size
004DAB  1               
004DAB  1               ; calculate tab column limit from TAB size. The <Iclim is set to the last tab
004DAB  1               ; position on a line that still has at least one whole tab width between it
004DAB  1               ; and the end of the line.
004DAB  1               
004DAB  1               WExit:
004DAB  1  A5 0F                LDA     <TWidth         ; get width
004DAD  1  F0 06                BEQ     LAB_SULP        ; branch if infinite line
004DAF  1               
004DAF  1  C5 64                CMP     <TabSiz         ; compare with tab size
004DB1  1  B0 03                BCS     LAB_WDLP        ; branch if >= tab size
004DB3  1               
004DB3  1  85 64                STA     <TabSiz         ; else make tab size = terminal width
004DB5  1               LAB_SULP:
004DB5  1  38                   SEC                     ; set carry for subtract
004DB6  1               LAB_WDLP:
004DB6  1  E5 64                SBC     <TabSiz         ; subtract tab size
004DB8  1  B0 FC                BCS     LAB_WDLP        ; loop while no borrow
004DBA  1               
004DBA  1  65 64                ADC     <TabSiz         ; add tab size back
004DBC  1  18                   CLC                     ; clear carry for add
004DBD  1  65 64                ADC     <TabSiz         ; add tab size back again
004DBF  1  85 10                STA     <Iclim          ; save for now
004DC1  1  A5 0F                LDA     <TWidth         ; get width back
004DC3  1  38                   SEC                     ; set carry for subtract
004DC4  1  E5 10                SBC     <Iclim          ; subtract remainder
004DC6  1  85 10                STA     <Iclim          ; save tab column limit
004DC8  1               LAB_NOSQ:
004DC8  1  60                   RTS
004DC9  1               
004DC9  1               TabErr:
004DC9  1  4C C7 37             JMP     LAB_FCER        ; do function call error then warm start
004DCC  1               
004DCC  1               ; perform SQR()
004DCC  1               
004DCC  1               LAB_SQR:
004DCC  1  A5 B0                LDA     <FAC1_s         ; get FAC1 sign
004DCE  1  30 F9                BMI     TabErr          ; if -ve do function call error
004DD0  1               
004DD0  1  A5 AC                LDA     <FAC1_e         ; get exponent
004DD2  1  F0 F4                BEQ     LAB_NOSQ        ; if zero just return
004DD4  1               
004DD4  1               ; else do root
004DD4  1  20 A9 45             JSR     LAB_27AB        ; round and copy FAC1 to FAC2
004DD7  1  A9 00                LDA     #$00            ; clear A
004DD9  1               
004DD9  1  85 77                STA     <FACt_3         ; clear remainder
004DDB  1  85 76                STA     <FACt_2         ; ..
004DDD  1  85 75                STA     <FACt_1         ; ..
004DDF  1  85 78                STA     <TempB          ; ..
004DE1  1               
004DE1  1  85 AF                STA     <FAC1_3         ; clear root
004DE3  1  85 AE                STA     <FAC1_2         ; ..
004DE5  1  85 AD                STA     <FAC1_1         ; ..
004DE7  1               
004DE7  1  A2 18                LDX     #$18            ; 24 pairs of bits to do
004DE9  1  A5 B3                LDA     <FAC2_e         ; get exponent
004DEB  1  4A                   LSR     A               ; check odd/even
004DEC  1  B0 0E                BCS     LAB_SQE2        ; if odd only 1 shift first time
004DEE  1               
004DEE  1               LAB_SQE1:
004DEE  1  06 B6                ASL     <FAC2_3         ; shift highest bit of number ..
004DF0  1  26 B5                ROL     <FAC2_2         ; ..
004DF2  1  26 B4                ROL     <FAC2_1         ; ..
004DF4  1  26 77                ROL     <FACt_3         ; .. into remainder
004DF6  1  26 76                ROL     <FACt_2         ; ..
004DF8  1  26 75                ROL     <FACt_1         ; ..
004DFA  1  26 78                ROL     <TempB          ; .. never overflows
004DFC  1               LAB_SQE2:
004DFC  1  06 B6                ASL     <FAC2_3         ; shift highest bit of number ..
004DFE  1  26 B5                ROL     <FAC2_2         ; ..
004E00  1  26 B4                ROL     <FAC2_1         ; ..
004E02  1  26 77                ROL     <FACt_3         ; .. into remainder
004E04  1  26 76                ROL     <FACt_2         ; ..
004E06  1  26 75                ROL     <FACt_1         ; ..
004E08  1  26 78                ROL     <TempB          ; .. never overflows
004E0A  1               
004E0A  1  06 AF                ASL     <FAC1_3         ; root = root * 2
004E0C  1  26 AE                ROL     <FAC1_2         ; ..
004E0E  1  26 AD                ROL     <FAC1_1         ; .. never overflows
004E10  1               
004E10  1  A5 AF                LDA     <FAC1_3         ; get root low byte
004E12  1  2A                   ROL     A               ; *2
004E13  1  85 5B                STA     <Temp3          ; save partial low byte
004E15  1  A5 AE                LDA     <FAC1_2         ; get root low mid byte
004E17  1  2A                   ROL     A               ; *2
004E18  1  85 5C                STA     <Temp3+1        ; save partial low mid byte
004E1A  1  A5 AD                LDA     <FAC1_1         ; get root high mid byte
004E1C  1  2A                   ROL     A               ; *2
004E1D  1  85 5D                STA     <Temp3+2        ; save partial high mid byte
004E1F  1  A9 00                LDA     #$00            ; get root high byte (always $00)
004E21  1  2A                   ROL     A               ; *2
004E22  1  85 5E                STA     <Temp3+3        ; save partial high byte
004E24  1               
004E24  1               ; carry clear for subtract +1
004E24  1  A5 77                LDA     <FACt_3         ; get remainder low byte
004E26  1  E5 5B                SBC     <Temp3          ; subtract partial low byte
004E28  1  85 5B                STA     <Temp3          ; save partial low byte
004E2A  1               
004E2A  1  A5 76                LDA     <FACt_2         ; get remainder low mid byte
004E2C  1  E5 5C                SBC     <Temp3+1        ; subtract partial low mid byte
004E2E  1  85 5C                STA     <Temp3+1        ; save partial low mid byte
004E30  1               
004E30  1  A5 75                LDA     <FACt_1         ; get remainder high mid byte
004E32  1  E5 5D                SBC     <Temp3+2        ; subtract partial high mid byte
004E34  1  A8                   TAY                     ; copy partial high mid byte
004E35  1               
004E35  1  A5 78                LDA     <TempB          ; get remainder high byte
004E37  1  E5 5E                SBC     <Temp3+3        ; subtract partial high byte
004E39  1  90 0E                BCC     LAB_SQNS        ; skip sub if remainder smaller
004E3B  1               
004E3B  1  85 78                STA     <TempB          ; save remainder high byte
004E3D  1               
004E3D  1  84 75                STY     <FACt_1         ; save remainder high mid byte
004E3F  1               
004E3F  1  A5 5C                LDA     <Temp3+1        ; get remainder low mid byte
004E41  1  85 76                STA     <FACt_2         ; save remainder low mid byte
004E43  1               
004E43  1  A5 5B                LDA     <Temp3          ; get partial low byte
004E45  1  85 77                STA     <FACt_3         ; save remainder low byte
004E47  1               
004E47  1  E6 AF                INC     <FAC1_3         ; increment root low byte (never any rollover)
004E49  1               LAB_SQNS:
004E49  1  CA                   DEX                     ; decrement bit pair count
004E4A  1  D0 A2                BNE     LAB_SQE1        ; loop if not all done
004E4C  1               LAB_SQNSA:
004E4C  1  38                   SEC                     ; set carry for subtract
004E4D  1  A5 B3                LDA     <FAC2_e         ; get exponent
004E4F  1  E9 80                SBC     #$80            ; normalise
004E51  1  6A                   ROR     A               ; /2 and re-bias to $80
004E52  1  69 00                ADC     #$00            ; add bit zero back in (allow for half shift)
004E54  1  85 AC                STA     <FAC1_e         ; save it
004E56  1  4C 23 42             JMP     LAB_24D5        ; normalise FAC1 and return
004E59  1               
004E59  1               ; perform VARPTR()
004E59  1               
004E59  1               LAB_VARPTR:
004E59  1  22 BC 00 00          JSL     LAB_IGBY        ; increment and scan memory
004E5D  1  20 3F 36             JSR     LAB_GVAR        ; get var address
004E60  1  20 53 34             JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
004E63  1  A4 95                LDY     <Cvaral         ; get var address low byte
004E65  1  A5 96                LDA     <Cvarah         ; get var address high byte
004E67  1  4C FD 38             JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return
004E6A  1               
004E6A  1               ; perform PI
004E6A  1               
004E6A  1               LAB_PI:
004E6A  1  A9 75                LDA     #<LAB_2C7C      ; set (2*pi) pointer low byte
004E6C  1  A0 18                LDY     #>LAB_2C7C      ; set (2*pi) pointer high byte
004E6E  1  20 BC 44             JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
004E71  1  C6 AC                DEC     <FAC1_e         ; make result = PI
004E73  1  60                   RTS
004E74  1               
004E74  1               
004E74  1               
004E74  1               
004E74  1               
004E74  1               AA_end_basic:
004E74  1               ENDOFBASIC:
004E74  1  44 45 52 49          .BYTE   "DERIVED FROM ehBASIC"
004E78  1  56 45 44 20  
004E7C  1  46 52 4F 4D  
004E88  1               
004E88  1               
004E88  1               
004E88  1               
004E88  1                       .END
